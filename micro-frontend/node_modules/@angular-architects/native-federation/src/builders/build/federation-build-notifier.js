"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.federationBuildNotifier = exports.FederationBuildNotifier = void 0;
const native_federation_runtime_1 = require("@softarc/native-federation-runtime");
const build_1 = require("@softarc/native-federation/build");
/**
 * Manages Server-Sent Events for federation hot reload in local development
 * Only active when running in development mode with dev server
 */
class FederationBuildNotifier {
    constructor() {
        this.connections = [];
        this.cleanupInterval = null;
        this.isActive = false;
    }
    /**
     * Initializes the SSE reloader for local development
     */
    initialize(endpoint) {
        if (this.isActive) {
            return;
        }
        this.endpoint = endpoint;
        this.isActive = true;
        this.startCleanup();
        build_1.logger.info(`[Federation SSE] Local reloader initialized with endpoint ${this.endpoint}`);
    }
    /**
     * Creates SSE middleware for federation events
     */
    createEventMiddleware(removeBaseHref) {
        if (!this.isActive) {
            return (req, res, next) => next();
        }
        return (req, res, next) => {
            const url = removeBaseHref(req);
            if (url !== this.endpoint) {
                return next();
            }
            this._setupSSEConnection(req, res);
        };
    }
    /**
     * Sets up a new SSE connection
     */
    _setupSSEConnection(req, res) {
        res.writeHead(200, {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            Connection: 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control',
        });
        // Send initial connection event
        this._sendEvent(res, {
            type: 'connected',
            timestamp: Date.now(),
        });
        // Store connection
        const connection = { response: res, request: req };
        this.connections.push(connection);
        // Handle disconnection
        req.on('close', () => this._removeConnection(connection));
        req.on('error', () => this._removeConnection(connection));
        build_1.logger.info(`[Federation SSE] Client connected. Active connections: ${this.connections.length}`);
    }
    /**
     * Removes a connection from the pool
     */
    _removeConnection(connection) {
        const index = this.connections.indexOf(connection);
        if (index !== -1) {
            this.connections.splice(index, 1);
            build_1.logger.info(`[Federation SSE] Client disconnected. Active connections: ${this.connections.length}`);
        }
    }
    /**
     * Broadcasts an event to all connected clients
     * Only works in local development mode
     */
    _broadcastEvent(event) {
        if (!this.isActive || this.connections.length === 0) {
            return;
        }
        const deadConnections = [];
        this.connections.forEach((connection) => {
            try {
                this._sendEvent(connection.response, event);
            }
            catch (error) {
                deadConnections.push(connection);
            }
        });
        // Remove dead connections
        deadConnections.forEach((connection) => this._removeConnection(connection));
        if (this.connections.length > 0) {
            build_1.logger.info(`[Federation SSE] Event '${event.type}' broadcast to ${this.connections.length} clients`);
        }
    }
    /**
     * Sends an event to a specific response stream
     */
    _sendEvent(res, event) {
        const data = JSON.stringify(event);
        res.write(`data: ${data}\n\n`);
    }
    /**
     * Starts periodic cleanup of dead connections
     */
    startCleanup() {
        if (this.cleanupInterval) {
            return;
        }
        this.cleanupInterval = setInterval(() => {
            const aliveBefore = this.connections.length;
            this.connections = this.connections.filter((connection) => !connection.response.destroyed &&
                !connection.request.destroyed &&
                connection.response.writable);
            if (this.connections.length !== aliveBefore) {
                build_1.logger.info(`[Federation SSE] Cleaned up ${aliveBefore - this.connections.length} dead connections`);
            }
        }, 30000); // Clean every 30 seconds
    }
    /**
     * Notifies about successful federation rebuild
     */
    broadcastBuildCompletion() {
        this._broadcastEvent({
            type: native_federation_runtime_1.BuildNotificationType.COMPLETED,
            timestamp: Date.now(),
        });
    }
    /**
     * Notifies about failed federation rebuild
     */
    broadcastBuildError(error) {
        this._broadcastEvent({
            type: native_federation_runtime_1.BuildNotificationType.ERROR,
            timestamp: Date.now(),
            error: error instanceof Error ? error.message : 'Unknown error',
        });
    }
    /**
     * Stops cleanup and closes all connections
     * Should be called when development server stops
     */
    stopEventServer() {
        if (!this.isActive) {
            return;
        }
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        this.connections.forEach((connection) => {
            try {
                connection.response.end();
            }
            catch (error) {
                // Connection might already be closed
            }
        });
        this.connections = [];
        this.isActive = false;
        build_1.logger.info('[Federation SSE] Local reloader disposed');
    }
    /**
     * Returns the number of active connections
     */
    get activeConnections() {
        return this.connections.length;
    }
    /**
     * Returns whether the reloader is active
     */
    get isRunning() {
        return this.isActive;
    }
}
exports.FederationBuildNotifier = FederationBuildNotifier;
// Singleton instance for local development
exports.federationBuildNotifier = new FederationBuildNotifier();
//# sourceMappingURL=federation-build-notifier.js.map