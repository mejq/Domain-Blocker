"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuilder = runBuilder;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const mrmime = tslib_1.__importStar(require("mrmime"));
const path = tslib_1.__importStar(require("path"));
const build_1 = require("@angular/build");
const private_1 = require("@angular/build/private");
const architect_1 = require("@angular-devkit/architect");
const options_1 = require("@angular-devkit/build-angular/src/builders/dev-server/options");
const build_2 = require("@softarc/native-federation/build");
const architect_2 = require("@angular-devkit/architect");
const build_3 = require("@softarc/native-federation/build");
const angular_esbuild_adapter_1 = require("../../utils/angular-esbuild-adapter");
const fs_1 = require("fs");
const fstart_as_data_url_1 = require("../../tools/fstart-as-data-url");
const i18n_1 = require("../../utils/i18n");
const mem_resuts_1 = require("../../utils/mem-resuts");
const rebuild_events_1 = require("../../utils/rebuild-events");
const shared_mappings_plugin_1 = require("../../utils/shared-mappings-plugin");
const updateIndexHtml_1 = require("../../utils/updateIndexHtml");
const federation_build_notifier_1 = require("./federation-build-notifier");
function _buildApplication(options, context, pluginsOrExtensions) {
    let extensions;
    if (pluginsOrExtensions && Array.isArray(pluginsOrExtensions)) {
        extensions = {
            codePlugins: pluginsOrExtensions,
        };
    }
    else {
        extensions = pluginsOrExtensions;
    }
    return (0, private_1.buildApplicationInternal)(options, context, extensions);
}
function runBuilder(nfOptions, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* runBuilder_1() {
        var _a, e_1, _b, _c;
        var _d;
        let target = (0, architect_2.targetFromTargetString)(nfOptions.target);
        let _options = (yield tslib_1.__await(context.getTargetOptions(target)));
        let builder = yield tslib_1.__await(context.getBuilderNameForTarget(target));
        if (builder === '@angular-devkit/build-angular:browser-esbuild') {
            build_2.logger.info('.: NATIVE FEDERATION - UPDATE NEEDED :.');
            build_2.logger.info('');
            build_2.logger.info("Since version 17.1, Native Federation uses Angular's");
            build_2.logger.info('Application-Builder and its Dev-Server.');
            build_2.logger.info('');
            build_2.logger.info('If you are sill on Angular 17.0.x, please update to');
            build_2.logger.info('Angular 17.1.x or downgrade to Native Federation 17.0.x.');
            build_2.logger.info('');
            build_2.logger.info('For working with Native Federation 17.1.x (recommented), ');
            build_2.logger.info('please update your project config, e.g. in angular.json');
            build_2.logger.info('');
            build_2.logger.info('This command performs the needed update for default configs:');
            build_2.logger.info('');
            build_2.logger.info('\tng g @angular-architects/native-federation:appbuilder');
            build_2.logger.info('');
            build_2.logger.info('You need to run it once per application to migrate');
            build_2.logger.info('Please find more information here: https://shorturl.at/gADJW');
            return yield tslib_1.__await(void 0);
        }
        let options = (yield tslib_1.__await(context.validateOptions(_options, builder)));
        const outerOptions = options;
        const normOuterOptions = nfOptions.dev
            ? yield tslib_1.__await((0, options_1.normalizeOptions)(context, context.target.project, outerOptions))
            : null;
        const runServer = nfOptions.dev && nfOptions.devServer !== false;
        const write = true;
        const watch = nfOptions.watch;
        if (runServer) {
            target = (0, architect_2.targetFromTargetString)(outerOptions.buildTarget);
            _options = (yield tslib_1.__await(context.getTargetOptions(target)));
            builder = yield tslib_1.__await(context.getBuilderNameForTarget(target));
            options = (yield tslib_1.__await(context.validateOptions(_options, builder)));
        }
        options.watch = watch;
        if (nfOptions.baseHref) {
            options.baseHref = nfOptions.baseHref;
        }
        if (nfOptions.outputPath) {
            options.outputPath = nfOptions.outputPath;
        }
        const rebuildEvents = new rebuild_events_1.RebuildHubs();
        const adapter = (0, angular_esbuild_adapter_1.createAngularBuildAdapter)(options, context, rebuildEvents);
        (0, build_3.setBuildAdapter)(adapter);
        (0, build_2.setLogLevel)(options.verbose ? 'verbose' : 'info');
        if (!options.outputPath) {
            options.outputPath = `dist/${context.target.project}`;
        }
        const outputPath = options.outputPath;
        const outputOptions = Object.assign(Object.assign({ browser: 'browser', server: 'server', media: 'media' }, (typeof outputPath === 'string' ? undefined : outputPath)), { base: typeof outputPath === 'string' ? outputPath : outputPath.base });
        const i18n = yield tslib_1.__await((0, i18n_1.getI18nConfig)(context));
        const localeFilter = getLocaleFilter(options, runServer);
        const browserOutputPath = path.join(outputOptions.base, outputOptions.browser, options.localize ? (i18n === null || i18n === void 0 ? void 0 : i18n.sourceLocale) || '' : '');
        const differentDevServerOutputPath = Array.isArray(localeFilter) && localeFilter.length === 1;
        const devServerOutputPath = !differentDevServerOutputPath
            ? browserOutputPath
            : path.join(outputOptions.base, outputOptions.browser, options.localize[0]);
        const entryPoint = path.join(path.dirname(options.tsConfig), 'src/main.ts');
        const fedOptions = {
            workspaceRoot: context.workspaceRoot,
            outputPath: browserOutputPath,
            federationConfig: infereConfigPath(options.tsConfig),
            tsConfig: options.tsConfig,
            verbose: options.verbose,
            watch: false, // options.watch,
            dev: !!nfOptions.dev,
            entryPoint,
            buildNotifications: nfOptions.buildNotifications,
        };
        const activateSsr = nfOptions.ssr && !nfOptions.dev;
        const config = yield tslib_1.__await((0, build_3.loadFederationConfig)(fedOptions));
        const externals = (0, build_3.getExternals)(config);
        const plugins = [
            (0, shared_mappings_plugin_1.createSharedMappingsPlugin)(config.sharedMappings),
            {
                name: 'externals',
                setup(build) {
                    if (!activateSsr && build.initialOptions.platform !== 'node') {
                        build.initialOptions.external = externals.filter((e) => e !== 'tslib');
                    }
                },
            },
        ];
        // SSR build fails when externals are provided via the plugin
        if (activateSsr) {
            options.externalDependencies = externals;
        }
        const isLocalDevelopment = runServer && nfOptions.dev;
        // Initialize SSE reloader only for local development
        if (isLocalDevelopment && ((_d = nfOptions.buildNotifications) === null || _d === void 0 ? void 0 : _d.enable)) {
            federation_build_notifier_1.federationBuildNotifier.initialize(nfOptions.buildNotifications.endpoint);
        }
        const middleware = [
            ...(isLocalDevelopment
                ? [
                    federation_build_notifier_1.federationBuildNotifier.createEventMiddleware((req) => removeBaseHref(req, options.baseHref)),
                ]
                : []),
            (req, res, next) => {
                const url = removeBaseHref(req, options.baseHref);
                const fileName = path.join(fedOptions.workspaceRoot, devServerOutputPath, url);
                const exists = fs.existsSync(fileName);
                if (url !== '/' && url !== '' && exists) {
                    const lookup = mrmime.lookup;
                    const mimeType = lookup(path.extname(fileName)) || 'text/javascript';
                    const rawBody = fs.readFileSync(fileName, 'utf-8');
                    // TODO: Evaluate need for debug infos
                    // const body = addDebugInformation(url, rawBody);
                    const body = rawBody;
                    res.writeHead(200, {
                        'Content-Type': mimeType,
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
                        'Access-Control-Allow-Headers': 'Content-Type',
                    });
                    res.end(body);
                }
                else {
                    next();
                }
            },
        ];
        const memResults = new mem_resuts_1.MemResults();
        let first = true;
        let lastResult;
        if ((0, fs_1.existsSync)(fedOptions.outputPath)) {
            (0, fs_1.rmSync)(fedOptions.outputPath, { recursive: true });
        }
        if (!(0, fs_1.existsSync)(fedOptions.outputPath)) {
            (0, fs_1.mkdirSync)(fedOptions.outputPath, { recursive: true });
        }
        if (!write) {
            (0, angular_esbuild_adapter_1.setMemResultHandler)((outFiles, outDir) => {
                const fullOutDir = outDir
                    ? path.join(fedOptions.workspaceRoot, outDir)
                    : null;
                memResults.add(outFiles.map((f) => new mem_resuts_1.EsBuildResult(f, fullOutDir)));
            });
        }
        let federationResult;
        try {
            federationResult = yield tslib_1.__await((0, build_3.buildForFederation)(config, fedOptions, externals));
        }
        catch (e) {
            console.error(e);
            if (!watch) {
                process.exit(1);
            }
        }
        if (activateSsr) {
            writeFstartScript(fedOptions);
        }
        const hasLocales = (i18n === null || i18n === void 0 ? void 0 : i18n.locales) && Object.keys(i18n.locales).length > 0;
        if (hasLocales && localeFilter) {
            (0, i18n_1.translateFederationArtefacts)(i18n, localeFilter, outputOptions.base, federationResult);
        }
        options.deleteOutputPath = false;
        const appBuilderName = '@angular-devkit/build-angular:application';
        const builderRun = runServer
            ? (0, private_1.serveWithVite)(normOuterOptions, appBuilderName, _buildApplication, context, nfOptions.skipHtmlTransform
                ? {}
                : { indexHtml: transformIndexHtml(nfOptions) }, {
                buildPlugins: plugins,
                middleware,
            })
            : (0, build_1.buildApplication)(options, context, {
                codePlugins: plugins,
                indexHtmlTransformer: transformIndexHtml(nfOptions),
            });
        try {
            try {
                // builderRun.output.subscribe(async (output) => {
                for (var _e = true, builderRun_1 = tslib_1.__asyncValues(builderRun), builderRun_1_1; builderRun_1_1 = yield tslib_1.__await(builderRun_1.next()), _a = builderRun_1_1.done, !_a; _e = true) {
                    _c = builderRun_1_1.value;
                    _e = false;
                    const output = _c;
                    lastResult = output;
                    if (!write && output['outputFiles']) {
                        memResults.add(output['outputFiles'].map((file) => new mem_resuts_1.EsBuildResult(file)));
                    }
                    if (!write && output['assetFiles']) {
                        memResults.add(output['assetFiles'].map((file) => new mem_resuts_1.NgCliAssetResult(file)));
                    }
                    // if (write && !runServer && !nfOptions.skipHtmlTransform) {
                    //   updateIndexHtml(fedOptions, nfOptions);
                    // }
                    // if (!runServer) {
                    //   yield output;
                    // }
                    if (!first && (nfOptions.dev || watch)) {
                        setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            try {
                                federationResult = yield (0, build_3.buildForFederation)(config, fedOptions, externals, {
                                    skipMappingsAndExposed: false,
                                    skipShared: true,
                                });
                                if (hasLocales && localeFilter) {
                                    (0, i18n_1.translateFederationArtefacts)(i18n, localeFilter, outputOptions.base, federationResult);
                                }
                                build_2.logger.info('Done!');
                                // Notifies about build completion
                                if (isLocalDevelopment) {
                                    federation_build_notifier_1.federationBuildNotifier.broadcastBuildCompletion();
                                }
                            }
                            catch (error) {
                                build_2.logger.error('Federation rebuild failed!');
                                // Notifies about build failure
                                if (isLocalDevelopment) {
                                    federation_build_notifier_1.federationBuildNotifier.broadcastBuildError(error);
                                }
                            }
                        }), nfOptions.rebuildDelay);
                    }
                    first = false;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_e && !_a && (_b = builderRun_1.return)) yield tslib_1.__await(_b.call(builderRun_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        finally {
            if (isLocalDevelopment) {
                federation_build_notifier_1.federationBuildNotifier.stopEventServer();
            }
        }
        yield yield tslib_1.__await(lastResult || { success: false });
    });
}
function removeBaseHref(req, baseHref) {
    let url = req.url;
    if (baseHref && url.startsWith(baseHref)) {
        url = url.substr(baseHref.length);
    }
    return url;
}
function writeFstartScript(fedOptions) {
    const serverOutpath = path.join(fedOptions.outputPath, '../server');
    const fstartPath = path.join(serverOutpath, 'fstart.mjs');
    const buffer = Buffer.from(fstart_as_data_url_1.fstart, 'base64');
    fs.mkdirSync(serverOutpath, { recursive: true });
    fs.writeFileSync(fstartPath, buffer, 'utf-8');
}
function getLocaleFilter(options, runServer) {
    let localize = options.localize || false;
    if (runServer && Array.isArray(localize) && localize.length > 1) {
        localize = false;
    }
    if (runServer && localize === true) {
        localize = false;
    }
    return localize;
}
function infereConfigPath(tsConfig) {
    const relProjectPath = path.dirname(tsConfig);
    const relConfigPath = path.join(relProjectPath, 'federation.config.js');
    return relConfigPath;
}
function transformIndexHtml(nfOptions) {
    return (content) => Promise.resolve((0, updateIndexHtml_1.updateScriptTags)(content, 'main.js', 'polyfills.js', nfOptions));
}
function addDebugInformation(fileName, rawBody) {
    if (fileName !== '/remoteEntry.json') {
        return rawBody;
    }
    const remoteEntry = JSON.parse(rawBody);
    const shared = remoteEntry.shared;
    if (!shared) {
        return rawBody;
    }
    const sharedForVite = shared.map((s) => (Object.assign(Object.assign({}, s), { packageName: `/@id/${s.packageName}` })));
    remoteEntry.shared = [...shared, ...sharedForVite];
    return JSON.stringify(remoteEntry, null, 2);
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.default = (0, architect_1.createBuilder)(runBuilder);
//# sourceMappingURL=builder.js.map