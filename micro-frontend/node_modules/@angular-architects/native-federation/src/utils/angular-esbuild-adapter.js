"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMemResultHandler = setMemResultHandler;
exports.createAngularBuildAdapter = createAngularBuildAdapter;
exports.loadEsmModule = loadEsmModule;
const tslib_1 = require("tslib");
const build_1 = require("@softarc/native-federation/build");
const esbuild = tslib_1.__importStar(require("esbuild"));
const private_1 = require("@angular/build/private");
const create_compiler_options_1 = require("./create-compiler-options");
const tailwind_1 = require("@angular-devkit/build-angular/src/utils/tailwind");
const utils_1 = require("@angular-devkit/build-angular/src/utils");
const node_module_1 = require("node:module");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const shared_mappings_plugin_1 = require("./shared-mappings-plugin");
const core_1 = require("@babel/core");
const rebuild_events_1 = require("./rebuild-events");
const json5_1 = tslib_1.__importDefault(require("json5"));
const node_util_1 = require("node:util");
let _memResultHandler;
function setMemResultHandler(handler) {
    _memResultHandler = handler;
}
function createAngularBuildAdapter(builderOptions, context, rebuildRequested = new rebuild_events_1.RebuildHubs()) {
    return (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { entryPoints, tsConfigPath, external, outdir, mappedPaths, kind, watch, dev, hash, platform, optimizedMappings, } = options;
        setNgServerMode();
        const files = yield runEsbuild(builderOptions, context, entryPoints, external, outdir, tsConfigPath, mappedPaths, watch, rebuildRequested, dev, kind, hash, undefined, undefined, undefined, platform, optimizedMappings);
        if (kind === 'shared-package') {
            const scriptFiles = files.filter((f) => f.endsWith('.js') || f.endsWith('.mjs'));
            for (const file of scriptFiles) {
                link(file, dev);
            }
        }
        return files.map((fileName) => ({ fileName }));
        // TODO: Do we still need rollup as esbuilt evolved?
        // if (kind === 'shared-package') {
        //   await runRollup(entryPoint, external, outfile);
        // } else {
        //   if (
        //     dev &&
        //     kind === 'shared-package' &&
        //     entryPoint.match(fesmFolderRegExp)
        //   ) {
        //     fs.copyFileSync(entryPoint, outfile);
        //   } else {
        //     await runEsbuild(
        //       builderOptions,
        //       context,
        //       entryPoint,
        //       external,
        //       outfile,
        //       tsConfigPath,
        //       mappedPaths,
        //       watch,
        //       rebuildRequested,
        //       dev,
        //       kind
        //     );
        //   }
        //   if (kind === 'shared-package' && fs.existsSync(outfile)) {
        //     await link(outfile, dev);
        //   }
        // }
    });
    function link(outfile, dev) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const code = fs.readFileSync(outfile, 'utf-8');
            try {
                const linkerEsm = yield loadEsmModule('@angular/compiler-cli/linker/babel');
                const linker = linkerEsm.default;
                const result = yield (0, core_1.transformAsync)(code, {
                    filename: outfile,
                    // inputSourceMap: (useInputSourcemap ? undefined : false) as undefined,
                    // sourceMaps: pluginOptions.sourcemap ? 'inline' : false,
                    compact: !dev,
                    configFile: false,
                    babelrc: false,
                    minified: !dev,
                    browserslistConfigFile: false,
                    plugins: [linker],
                });
                fs.writeFileSync(outfile, result.code, 'utf-8');
            }
            catch (e) {
                build_1.logger.error('error linking');
                if (fs.existsSync(`${outfile}.error`)) {
                    fs.unlinkSync(`${outfile}.error`);
                }
                fs.renameSync(outfile, `${outfile}.error`);
                throw e;
            }
        });
    }
}
function runEsbuild(builderOptions_1, context_1, entryPoints_1, external_1, outdir_1, tsConfigPath_1, mappedPaths_1, watch_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (builderOptions, context, entryPoints, external, outdir, tsConfigPath, mappedPaths, watch, rebuildRequested = new rebuild_events_1.RebuildHubs(), dev, kind, hash = false, plugins = null, absWorkingDir = undefined, logLevel = 'warning', platform, optimizedMappings) {
        const projectRoot = path.dirname(tsConfigPath);
        const browsers = (0, private_1.getSupportedBrowsers)(projectRoot, context.logger);
        const target = (0, private_1.transformSupportedBrowsersToTargets)(browsers);
        const workspaceRoot = context.workspaceRoot;
        const optimizationOptions = (0, utils_1.normalizeOptimization)(builderOptions.optimization);
        const sourcemapOptions = (0, utils_1.normalizeSourceMaps)(builderOptions.sourceMap);
        const tailwindConfigurationPath = yield (0, tailwind_1.findTailwindConfigurationFile)(workspaceRoot, projectRoot);
        const fullProjectRoot = path.join(workspaceRoot, projectRoot);
        const resolver = (0, node_module_1.createRequire)(fullProjectRoot + '/');
        const tailwindConfiguration = tailwindConfigurationPath
            ? {
                file: tailwindConfigurationPath,
                package: resolver.resolve('tailwindcss'),
            }
            : undefined;
        const outputNames = {
            bundles: '[name]',
            media: 'media/[name]',
        };
        let fileReplacements;
        if (builderOptions.fileReplacements) {
            for (const replacement of builderOptions.fileReplacements) {
                fileReplacements !== null && fileReplacements !== void 0 ? fileReplacements : (fileReplacements = {});
                fileReplacements[path.join(workspaceRoot, replacement.replace)] =
                    path.join(workspaceRoot, replacement.with);
            }
        }
        if (!optimizedMappings) {
            tsConfigPath = createTsConfigForFederation(workspaceRoot, tsConfigPath, entryPoints);
        }
        const pluginOptions = (0, create_compiler_options_1.createCompilerPluginOptions)({
            workspaceRoot,
            optimizationOptions,
            sourcemapOptions,
            tsconfig: tsConfigPath,
            outputNames,
            fileReplacements,
            externalDependencies: external,
            preserveSymlinks: builderOptions.preserveSymlinks,
            stylePreprocessorOptions: builderOptions.stylePreprocessorOptions,
            advancedOptimizations: !dev,
            inlineStyleLanguage: builderOptions.inlineStyleLanguage,
            jit: false,
            tailwindConfiguration,
        }, target, undefined);
        const commonjsPluginModule = yield import('@chialab/esbuild-plugin-commonjs');
        const commonjsPlugin = commonjsPluginModule.default;
        pluginOptions.styleOptions.externalDependencies = [];
        const config = {
            entryPoints: entryPoints.map((ep) => ({
                in: ep.fileName,
                out: path.parse(ep.outName).name,
            })),
            outdir,
            entryNames: hash ? '[name]-[hash]' : '[name]',
            write: false,
            absWorkingDir,
            external,
            logLevel,
            bundle: true,
            sourcemap: dev,
            minify: !dev,
            supported: {
                'async-await': false,
                'object-rest-spread': false,
            },
            splitting: true, //kind === 'mapping-or-exposed',
            platform: platform !== null && platform !== void 0 ? platform : 'browser',
            format: 'esm',
            target: target,
            logLimit: kind === 'shared-package' ? 1 : 0,
            plugins: plugins || [
                (0, private_1.createCompilerPlugin)(pluginOptions.pluginOptions, pluginOptions.styleOptions),
                ...(mappedPaths && mappedPaths.length > 0
                    ? [(0, shared_mappings_plugin_1.createSharedMappingsPlugin)(mappedPaths)]
                    : []),
                commonjsPlugin(),
            ],
            define: Object.assign(Object.assign({}, (!dev ? { ngDevMode: 'false' } : {})), { ngJitMode: 'false' }),
        };
        const ctx = yield esbuild.context(config);
        const result = yield ctx.rebuild();
        const memOnly = dev && kind === 'mapping-or-exposed' && !!_memResultHandler;
        const writtenFiles = writeResult(result, outdir, memOnly);
        if (watch) {
            registerForRebuilds(kind, rebuildRequested, ctx, entryPoints, outdir, hash, memOnly);
        }
        else {
            ctx.dispose();
        }
        return writtenFiles;
    });
}
function createTsConfigForFederation(workspaceRoot, tsConfigPath, entryPoints) {
    const fullTsConfigPath = path.join(workspaceRoot, tsConfigPath);
    console.log('root', workspaceRoot);
    const tsconfigDir = path.dirname(fullTsConfigPath);
    const filtered = entryPoints
        .filter((ep) => !ep.fileName.includes('/node_modules/') && !ep.fileName.startsWith('.'))
        .map((ep) => path.relative(tsconfigDir, ep.fileName).replace(/\\\\/g, '/'));
    console.log('path', fullTsConfigPath);
    const tsconfigAsString = fs.readFileSync(fullTsConfigPath, 'utf-8');

    const tsconfig = json5_1.default.parse(tsconfigAsString);
    if (!tsconfig.include) {
        tsconfig.include = [];
    }
    for (const ep of filtered) {
        if (!tsconfig.include.includes(ep)) {
            tsconfig.include.push(ep);
        }
    }
    const content = json5_1.default.stringify(tsconfig, null, 2);
    const tsconfigFedPath = path.join(tsconfigDir, 'tsconfig.federation.json');
    if (!doesFileExistAndJsonEqual(tsconfigFedPath, content)) {
        fs.writeFileSync(tsconfigFedPath, JSON.stringify(tsconfig, null, 2));
    }
    tsConfigPath = tsconfigFedPath;
    return tsConfigPath;
}
/**
 * Checks if a file exists and if its content is equal to the provided content.
 * If the file does not exist, it returns false.
 * If the file or its content is invalid JSON, it returns false.
 * @param {string} path - The path to the file
 * @param {string} content - The content to compare with
 * @returns {boolean} - Returns true if the file exists and its content is equal to the provided content
 */
function doesFileExistAndJsonEqual(path, content) {
    if (!fs.existsSync(path)) {
        return false;
    }
    try {
        const currentContent = fs.readFileSync(path, 'utf-8');
        const currentJson = json5_1.default.parse(currentContent);
        const newJson = json5_1.default.parse(content);
        return (0, node_util_1.isDeepStrictEqual)(currentJson, newJson);
    }
    catch (_error) {
        return false;
    }
}
function doesFileExist(path, content) {
    if (!fs.existsSync(path)) {
        return false;
    }
    const currentContent = fs.readFileSync(path, 'utf-8');
    return currentContent === content;
}
function writeResult(result, outdir, memOnly) {
    const writtenFiles = [];
    if (memOnly) {
        _memResultHandler(result.outputFiles, outdir);
    }
    for (const outFile of result.outputFiles) {
        const fileName = path.basename(outFile.path);
        const filePath = path.join(outdir, fileName);
        if (!memOnly) {
            fs.writeFileSync(filePath, outFile.text);
        }
        writtenFiles.push(filePath);
    }
    if (!memOnly) {
        // for (const asset of result.outputFiles)
    }
    return writtenFiles;
}
function registerForRebuilds(kind, rebuildRequested, ctx, entryPoints, outdir, hash, memOnly) {
    if (kind !== 'shared-package') {
        rebuildRequested.rebuild.register(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = yield ctx.rebuild();
            writeResult(result, outdir, memOnly);
        }));
    }
}
function loadEsmModule(modulePath) {
    return new Function('modulePath', `return import(modulePath);`)(modulePath);
}
//
//  Usually, ngServerMode is set during bundling. However, we need to infer this
//  value at runtime as we are using the same shared bundle for @angular/core
//  on the server and in the browser.
//
function setNgServerMode() {
    const fileToPatch = 'node_modules/@angular/core/fesm2022/core.mjs';
    const lineToAdd = `if (typeof globalThis.ngServerMode ==='undefined') globalThis.ngServerMode = (typeof window === 'undefined') ? true : false;`;
    try {
        if (fs.existsSync(fileToPatch)) {
            let content = fs.readFileSync(fileToPatch, 'utf-8');
            if (!content.includes(lineToAdd)) {
                content = lineToAdd + '\n' + content;
                fs.writeFileSync(fileToPatch, content);
            }
        }
    }
    catch (e) {
        console.error('Error patching file ', fileToPatch, '\nIs it write-protected?');
    }
}
//# sourceMappingURL=angular-esbuild-adapter.js.map