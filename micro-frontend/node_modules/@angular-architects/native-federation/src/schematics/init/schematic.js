"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePackageJson = updatePackageJson;
exports.default = config;
exports.patchAngularBuild = patchAngularBuild;
exports.getWorkspaceFileName = getWorkspaceFileName;
const tslib_1 = require("tslib");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const core_1 = require("@angular-devkit/core");
const patch_angular_build_1 = require("../../utils/patch-angular-build");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const path = tslib_1.__importStar(require("path"));
const SSR_VERSION = '^2.0.10';
function updatePackageJson(tree) {
    var _a;
    const packageJson = tree.readJson('package.json');
    const scriptCall = 'node node_modules/@angular-architects/native-federation/src/patch-angular-build.js';
    if (!packageJson['scripts']) {
        packageJson['scripts'] = {};
    }
    let postInstall = (((_a = packageJson['scripts']) === null || _a === void 0 ? void 0 : _a['postinstall']) || '');
    if (!postInstall) {
        return;
    }
    if (postInstall.includes(scriptCall)) {
        postInstall = postInstall.replace(scriptCall, '');
    }
    if (postInstall.endsWith(' && ')) {
        postInstall = postInstall.substring(0, postInstall.length - 4);
    }
    packageJson['scripts']['postinstall'] = postInstall;
    tree.overwrite('package.json', JSON.stringify(packageJson, null, 2));
}
function config(options) {
    return function (tree, context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const workspaceFileName = getWorkspaceFileName(tree);
            const workspace = JSON.parse(tree.read(workspaceFileName).toString('utf8'));
            const packageJson = JSON.parse(tree.read('package.json').toString('utf8'));
            const normalized = normalizeOptions(options, workspace, tree);
            const { polyfills, projectName, projectRoot, projectSourceRoot, manifestPath, manifestRelPath, main, } = normalized;
            updatePolyfills(tree, polyfills);
            const remoteMap = yield generateRemoteMap(workspace, projectName);
            if (options.type === 'dynamic-host' && !tree.exists(manifestPath)) {
                tree.create(manifestPath, JSON.stringify(remoteMap, null, '\t'));
            }
            const federationConfigPath = path.join(projectRoot, 'federation.config.js');
            const exists = tree.exists(federationConfigPath);
            const cand1 = path
                .join(projectSourceRoot, 'app', 'app.component.ts')
                .replace(/\\/g, '/');
            const cand2 = path
                .join(projectSourceRoot, 'app', 'app.ts')
                .replace(/\\/g, '/');
            const appComponent = tree.exists(cand1)
                ? cand1
                : tree.exists(cand2)
                    ? cand2
                    : 'update-this.ts';
            const generateRule = !exists
                ? yield generateFederationConfig(remoteMap, projectRoot, projectSourceRoot, appComponent, options)
                : schematics_1.noop;
            const ssr = isSsrProject(normalized);
            const server = ssr ? getSsrFilePath(normalized) : '';
            if (ssr) {
                console.log('SSR detected ...');
                console.log('Activating CORS ...');
                (0, dependencies_1.addPackageJsonDependency)(tree, {
                    name: 'cors',
                    type: dependencies_1.NodeDependencyType.Default,
                    version: '^2.8.5',
                    overwrite: false,
                });
            }
            updateWorkspaceConfig(tree, normalized, workspace, workspaceFileName, ssr);
            // updatePackageJson(tree);
            // patchAngularBuild(tree);
            (0, dependencies_1.addPackageJsonDependency)(tree, {
                name: '@angular/animations',
                type: dependencies_1.NodeDependencyType.Default,
                version: ((_a = (0, dependencies_1.getPackageJsonDependency)(tree, '@angular/core')) === null || _a === void 0 ? void 0 : _a.version) || 'latest',
                overwrite: false,
            });
            (0, dependencies_1.addPackageJsonDependency)(tree, {
                name: '@angular-devkit/build-angular',
                type: dependencies_1.NodeDependencyType.Dev,
                version: ((_b = (0, dependencies_1.getPackageJsonDependency)(tree, '@angular/build')) === null || _b === void 0 ? void 0 : _b.version) || 'latest',
                overwrite: false,
            });
            (0, dependencies_1.addPackageJsonDependency)(tree, {
                name: 'es-module-shims',
                type: dependencies_1.NodeDependencyType.Default,
                version: '^1.5.12',
                overwrite: false,
            });
            (0, dependencies_1.addPackageJsonDependency)(tree, {
                name: '@softarc/native-federation-node',
                type: dependencies_1.NodeDependencyType.Default,
                version: SSR_VERSION,
                overwrite: true,
            });
            context.addTask(new tasks_1.NodePackageInstallTask());
            return (0, schematics_1.chain)([
                generateRule,
                makeMainAsync(main, options, remoteMap, manifestRelPath),
                ssr
                    ? makeServerAsync(server, options, remoteMap, manifestRelPath)
                    : (0, schematics_1.noop)(),
            ]);
        });
    };
}
function isSsrProject(normalized) {
    var _a, _b, _c;
    return !!((_c = (_b = (_a = normalized.projectConfig) === null || _a === void 0 ? void 0 : _a.architect) === null || _b === void 0 ? void 0 : _b.build.options) === null || _c === void 0 ? void 0 : _c.ssr);
}
function getSsrFilePath(normalized) {
    return normalized.projectConfig.architect.build.options.ssr.entry;
}
function patchAngularBuild(tree) {
    const packagePath = 'node_modules/@angular/build/package.json';
    const privatePath = 'node_modules/@angular/build/private.js';
    if (!tree.exists(packagePath)) {
        return;
    }
    const packageJson = JSON.parse(tree.read(packagePath).toString('utf8'));
    (0, patch_angular_build_1.patchAngularBuildPackageJson)(packageJson);
    tree.overwrite(packagePath, JSON.stringify(packageJson, null, 2));
    if (!tree.exists(privatePath)) {
        tree.create(privatePath, patch_angular_build_1.privateEntrySrc);
    }
    else {
        tree.overwrite(privatePath, patch_angular_build_1.privateEntrySrc);
    }
}
function updateWorkspaceConfig(tree, options, workspace, workspaceFileName, ssr) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { projectConfig, projectName, port } = options;
    if (!((_a = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.architect) === null || _a === void 0 ? void 0 : _a.build) || !((_b = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.architect) === null || _b === void 0 ? void 0 : _b.serve)) {
        throw new Error(`The project doen't have a build or serve target in angular.json!`);
    }
    const originalBuild = projectConfig.architect.build;
    if (originalBuild.builder !== '@angular-devkit/build-angular:application') {
        console.log('Switching project to the application builder using esbuild ...');
        originalBuild.builder = '@angular-devkit/build-angular:application';
        (_d = (_c = originalBuild.configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? true : delete _d.buildOptimizer;
        (_f = (_e = originalBuild.configurations) === null || _e === void 0 ? void 0 : _e.development) === null || _f === void 0 ? true : delete _f.vendorChunk;
    }
    if (originalBuild.options.main) {
        const main = originalBuild.options.main;
        delete originalBuild.options.main;
        originalBuild.options.browser = main;
    }
    delete originalBuild.options.commonChunk;
    projectConfig.architect.esbuild = originalBuild;
    projectConfig.architect.build = {
        builder: '@angular-architects/native-federation:build',
        options: {},
        configurations: {
            production: {
                target: `${projectName}:esbuild:production`,
            },
            development: {
                target: `${projectName}:esbuild:development`,
                dev: true,
            },
        },
        defaultConfiguration: 'production',
    };
    if (ssr) {
        projectConfig.architect.build.options.ssr = true;
        // projectConfig.architect.esbuild.options.prerender = false;
    }
    const serve = projectConfig.architect.serve;
    (_g = serve.options) !== null && _g !== void 0 ? _g : (serve.options = {});
    serve.options.port = port;
    delete serve.options.commonChunk;
    const serveProd = (_h = projectConfig.architect.serve.configurations) === null || _h === void 0 ? void 0 : _h.production;
    if (serveProd) {
        serveProd.buildTarget = `${projectName}:esbuild:production`;
        delete serveProd.browserTarget;
    }
    const serveDev = (_j = projectConfig.architect.serve.configurations) === null || _j === void 0 ? void 0 : _j.development;
    if (serveDev) {
        serveDev.buildTarget = `${projectName}:esbuild:development`;
        delete serveDev.browserTarget;
    }
    projectConfig.architect['serve-original'] = projectConfig.architect.serve;
    projectConfig.architect.serve = {
        builder: '@angular-architects/native-federation:build',
        options: {
            target: `${projectName}:serve-original:development`,
            rebuildDelay: 0,
            dev: true,
            port: 0,
        },
    };
    const serveSsr = projectConfig.architect['serve-ssr'];
    if (serveSsr && !serveSsr.options) {
        serveSsr.options = {};
    }
    if (serveSsr) {
        serveSsr.options.port = port;
    }
    // projectConfig.architect.serve.builder = serveBuilder;
    // TODO: Register further builders when ready
    tree.overwrite(workspaceFileName, JSON.stringify(workspace, null, '\t'));
}
function normalizeOptions(options, workspace, tree) {
    var _a, _b;
    if (!options.project) {
        options.project = workspace.defaultProject;
    }
    const projects = Object.keys(workspace.projects);
    if (!options.project && projects.length === 0) {
        throw new Error(`No default project found. Please specifiy a project name!`);
    }
    if (!options.project) {
        console.log('Using first configured project as default project: ' + projects[0]);
        options.project = projects[0];
    }
    const projectName = options.project;
    const projectConfig = workspace.projects[projectName];
    if (!projectConfig) {
        throw new Error(`Project ${projectName} not found!`);
    }
    const projectRoot = (_a = projectConfig.root) === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/');
    const projectSourceRoot = (_b = projectConfig.sourceRoot) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/');
    const publicPath = path.join(projectRoot, 'public').replace(/\\/g, '/');
    let manifestPath = path
        .join(publicPath, 'federation.manifest.json')
        .replace(/\\/g, '/');
    let manifestRelPath = 'federation.manifest.json';
    const hasPublicFolder = tree
        .getDir(projectRoot)
        .subdirs.map((p) => String(p))
        .includes('public');
    if (!hasPublicFolder) {
        manifestPath = path
            .join(projectRoot, 'src/assets/federation.manifest.json')
            .replace(/\\/g, '/');
        manifestRelPath = 'assets/federation.manifest.json';
    }
    const main = projectConfig.architect.build.options.main ||
        projectConfig.architect.build.options.browser;
    if (!projectConfig.architect.build.options.polyfills) {
        projectConfig.architect.build.options.polyfills = [];
    }
    if (typeof projectConfig.architect.build.options.polyfills === 'string') {
        projectConfig.architect.build.options.polyfills = [
            projectConfig.architect.build.options.polyfills,
        ];
    }
    const polyfills = projectConfig.architect.build.options.polyfills;
    return {
        polyfills,
        projectName,
        projectRoot,
        projectSourceRoot,
        manifestPath,
        manifestRelPath,
        projectConfig,
        main,
        port: +(options.port || 4200),
    };
}
function updatePolyfills(tree, polyfills) {
    if (typeof polyfills === 'string') {
        updatePolyfillsFile(tree, polyfills);
    }
    else {
        updatePolyfillsArray(tree, polyfills);
    }
}
function updatePolyfillsFile(tree, polyfills) {
    let polyfillsContent = tree.readText(polyfills);
    if (!polyfillsContent.includes('es-module-shims')) {
        polyfillsContent += `\nimport 'es-module-shims';\n`;
        tree.overwrite(polyfills, polyfillsContent);
    }
}
function updatePolyfillsArray(tree, polyfills) {
    const polyfillsConfig = polyfills;
    if (!polyfillsConfig.includes('es-module-shims')) {
        polyfillsConfig.push('es-module-shims');
    }
}
function generateRemoteMap(workspace, projectName) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const result = {};
    for (const p in workspace.projects) {
        const project = workspace.projects[p];
        const projectType = (_a = project.projectType) !== null && _a !== void 0 ? _a : 'application';
        if (p !== projectName &&
            projectType === 'application' &&
            ((_b = project === null || project === void 0 ? void 0 : project.architect) === null || _b === void 0 ? void 0 : _b.serve) &&
            ((_c = project === null || project === void 0 ? void 0 : project.architect) === null || _c === void 0 ? void 0 : _c.build)) {
            const pPort = (_j = (_f = (_e = (_d = project.architect['serve-original']) === null || _d === void 0 ? void 0 : _d.options) === null || _e === void 0 ? void 0 : _e.port) !== null && _f !== void 0 ? _f : (_h = (_g = project.architect.serve) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.port) !== null && _j !== void 0 ? _j : 4200;
            result[core_1.strings.camelize(p)] = `http://localhost:${pPort}/remoteEntry.json`;
        }
    }
    if (Object.keys(result).length === 0) {
        result['mfe1'] = `http://localhost:3000/remoteEntry.json`;
    }
    return result;
}
function makeMainAsync(main, options, remoteMap, manifestRelPath) {
    return function (tree) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mainPath = path.dirname(main);
            const bootstrapName = path.join(mainPath, 'bootstrap.ts');
            if (tree.exists(bootstrapName)) {
                console.info(`${bootstrapName} already exists.`);
                return;
            }
            const mainContent = tree.read(main);
            tree.create(bootstrapName, mainContent);
            let newMainContent = '';
            if (options.type === 'dynamic-host') {
                newMainContent = `import { initFederation } from '@angular-architects/native-federation';

initFederation('${manifestRelPath}')
  .catch(err => console.error(err))
  .then(_ => import('./bootstrap'))
  .catch(err => console.error(err));
`;
            }
            else if (options.type === 'host') {
                const manifest = JSON.stringify(remoteMap, null, 2).replace(/"/g, "'");
                newMainContent = `import { initFederation } from '@angular-architects/native-federation';

initFederation(${manifest})
  .catch(err => console.error(err))
  .then(_ => import('./bootstrap'))
  .catch(err => console.error(err));
`;
            }
            else {
                newMainContent = `import { initFederation } from '@angular-architects/native-federation';

initFederation()
  .catch(err => console.error(err))
  .then(_ => import('./bootstrap'))
  .catch(err => console.error(err));
`;
            }
            tree.overwrite(main, newMainContent);
        });
    };
}
function makeServerAsync(server, options, remoteMap, manifestRelPath) {
    return function (tree) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mainPath = path.dirname(server);
            const bootstrapName = path.join(mainPath, 'bootstrap-server.ts');
            if (tree.exists(bootstrapName)) {
                console.info(`${bootstrapName} already exists.`);
                return;
            }
            const cors = `import { createRequire } from "module";
const require = createRequire(import.meta.url);
const cors = require("cors"); 
`;
            const mainContent = tree.read(server).toString('utf8');
            const updatedContent = (cors + mainContent)
                .replace(`const port = process.env['PORT'] || 4000`, `const port = process.env['PORT'] || ${options.port || 4000}`)
                .replace(`const app = express();`, `const app = express();\n\tapp.use(cors());\n  app.set('view engine', 'html');`)
                .replace(`if (isMainModule(import.meta.url)) {`, ``)
                .replace(/\}(?![\s\S]*\})/, '');
            tree.create(bootstrapName, updatedContent);
            let newMainContent = '';
            if (options.type === 'dynamic-host') {
                newMainContent = `import { initNodeFederation } from '@softarc/native-federation-node';

console.log('Starting SSR for Shell');

(async () => {

  await initNodeFederation({
    remotesOrManifestUrl: '../browser/federation.manifest.json',
    relBundlePath: '../browser/',
  });
  
  await import('./bootstrap-server');

})();
`;
            }
            else if (options.type === 'host') {
                const manifest = JSON.stringify(remoteMap, null, 2).replace(/"/g, "'");
                newMainContent = `import { initNodeFederation } from '@softarc/native-federation-node';

console.log('Starting SSR for Shell');

(async () => {

  await initNodeFederation({
    remotesOrManifestUrl: ${manifest},
    relBundlePath: '../browser/',
  });
  
  await import('./bootstrap-server');

})();
`;
            }
            else {
                newMainContent = `import { initNodeFederation } from '@softarc/native-federation-node';

(async () => {

  await initNodeFederation({
    relBundlePath: '../browser/'
  });
  
  await import('./bootstrap-server');

})();
`;
            }
            tree.overwrite(server, newMainContent);
        });
    };
}
function getWorkspaceFileName(tree) {
    if (tree.exists('angular.json')) {
        return 'angular.json';
    }
    if (tree.exists('workspace.json')) {
        return 'workspace.json';
    }
    throw new Error("angular.json or workspace.json expected! Did you call this in your project's root?");
}
function generateFederationConfig(remoteMap, projectRoot, projectSourceRoot, appComponentPath, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tmpl = (0, schematics_1.url)('./files');
        const applied = (0, schematics_1.apply)(tmpl, [
            (0, schematics_1.template)(Object.assign(Object.assign({ projectRoot,
                projectSourceRoot,
                appComponentPath,
                remoteMap }, options), { tmpl: '' })),
            (0, schematics_1.move)(projectRoot),
        ]);
        return (0, schematics_1.mergeWith)(applied);
    });
}
//# sourceMappingURL=schematic.js.map