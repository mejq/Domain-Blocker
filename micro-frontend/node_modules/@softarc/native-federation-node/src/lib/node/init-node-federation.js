import { __awaiter } from "tslib";
import { register } from 'node:module';
import { pathToFileURL } from 'node:url';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { mergeImportMaps, processHostInfo, processRemoteInfos, } from '@softarc/native-federation-runtime';
import { IMPORT_MAP_FILE_NAME } from '../utils/import-map-loader';
import { resolver } from '../utils/loader-as-data-url';
const defaultOptions = {
    remotesOrManifestUrl: {},
    relBundlePath: '../browser',
    throwIfRemoteNotFound: false,
};
export function initNodeFederation(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, defaultOptions), options);
        const importMap = yield createNodeImportMap(mergedOptions);
        // const normalized = resolveAndComposeImportMap(importMap) as ImportMap;
        // await writeImportMap(normalized);
        yield writeImportMap(importMap);
        yield writeResolver();
        register(pathToFileURL('./federation-resolver.mjs').href);
    });
}
function createNodeImportMap(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { remotesOrManifestUrl, relBundlePath } = options;
        const remotes = typeof remotesOrManifestUrl === 'object'
            ? remotesOrManifestUrl
            : yield loadFsManifest(remotesOrManifestUrl);
        const hostInfo = yield loadFsFederationInfo(relBundlePath);
        const hostImportMap = yield processHostInfo(hostInfo, './' + relBundlePath);
        const remotesImportMap = yield processRemoteInfos(remotes, {
            throwIfRemoteNotFound: options.throwIfRemoteNotFound,
            cacheTag: options.cacheTag,
        });
        const importMap = mergeImportMaps(hostImportMap, remotesImportMap);
        return importMap;
    });
}
function loadFsManifest(manifestUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield fs.readFile(manifestUrl, 'utf-8');
        const manifest = JSON.parse(content);
        return manifest;
    });
}
function loadFsFederationInfo(relBundlePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const manifestPath = path.join(relBundlePath, 'remoteEntry.json');
        const content = yield fs.readFile(manifestPath, 'utf-8');
        const manifest = JSON.parse(content);
        return manifest;
    });
}
function writeImportMap(map) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs.writeFile(IMPORT_MAP_FILE_NAME, JSON.stringify(map, null, 2), 'utf-8');
    });
}
function writeResolver() {
    return __awaiter(this, void 0, void 0, function* () {
        const buffer = Buffer.from(resolver, 'base64');
        yield fs.writeFile('federation-resolver.mjs', buffer, 'utf-8');
    });
}
//# sourceMappingURL=init-node-federation.js.map