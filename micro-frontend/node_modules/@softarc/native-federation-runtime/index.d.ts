type Type<T> = new () => T;
type ShareObject = {
    version: string;
    scope?: string;
    get: () => Promise<() => Type<unknown>>;
    shareConfig?: {
        singleton?: boolean;
        requiredVersion: string;
    };
};
type ShareConfig = {
    [pkgName: string]: Array<ShareObject>;
};
type ShareOptions = {
    singleton: boolean;
    requiredVersionPrefix: '^' | '~' | '>' | '>=' | '';
};
declare function getShared(options?: ShareOptions): ShareConfig;

type SharedInfo = {
    singleton: boolean;
    strictVersion: boolean;
    requiredVersion: string;
    version?: string;
    packageName: string;
    outFileName: string;
    dev?: {
        entryPoint: string;
    };
};
interface ExposesInfo {
    key: string;
    outFileName: string;
    dev?: {
        entryPoint: string;
    };
}
interface FederationInfo {
    name: string;
    exposes: ExposesInfo[];
    shared: SharedInfo[];
    buildNotificationsEndpoint?: string;
}
interface InitFederationOptions {
    cacheTag?: string;
}
interface ProcessRemoteInfoOptions extends InitFederationOptions {
    throwIfRemoteNotFound: boolean;
}

type Imports = Record<string, string>;
type Scopes = Record<string, Imports>;
type ImportMap = {
    imports: Imports;
    scopes: Scopes;
};
declare function mergeImportMaps(map1: ImportMap, map2: ImportMap): ImportMap;

/**
 * Initialize the federation runtime
 * @param remotesOrManifestUrl
 * @param options The cacheTag allows you to invalidate the cache of the remoteEntry.json files, pass a new value with every release (f.ex. the version number)
 */
declare function initFederation(remotesOrManifestUrl?: Record<string, string> | string, options?: InitFederationOptions): Promise<ImportMap>;
declare function processRemoteInfos(remotes: Record<string, string>, options?: ProcessRemoteInfoOptions): Promise<ImportMap>;
declare function processRemoteInfo(federationInfoUrl: string, remoteName?: string): Promise<ImportMap>;
declare function processHostInfo(hostInfo: FederationInfo, relBundlesPath?: string): Promise<ImportMap>;

type LoadRemoteModuleOptions<T = any> = {
    remoteEntry?: string;
    remoteName?: string;
    exposedModule: string;
    fallback?: T;
};
declare function loadRemoteModule<T = any>(options: LoadRemoteModuleOptions): Promise<T>;
declare function loadRemoteModule<T = any>(remoteName: string, exposedModule: string): Promise<T>;

interface BuildNotificationOptions {
    enable: boolean;
    endpoint: string;
}
declare const BUILD_NOTIFICATIONS_ENDPOINT = "/@angular-architects/native-federation:build-notifications";
declare enum BuildNotificationType {
    COMPLETED = "federation-rebuild-complete",
    ERROR = "federation-rebuild-error"
}

export { BUILD_NOTIFICATIONS_ENDPOINT, BuildNotificationType, getShared, initFederation, loadRemoteModule, mergeImportMaps, processHostInfo, processRemoteInfo, processRemoteInfos };
export type { BuildNotificationOptions, ExposesInfo, FederationInfo, ImportMap, Imports, InitFederationOptions, LoadRemoteModuleOptions, ProcessRemoteInfoOptions, Scopes, ShareConfig, ShareObject, ShareOptions, SharedInfo };
