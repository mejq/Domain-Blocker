const defaultShareOptions = {
    singleton: false,
    requiredVersionPrefix: '',
};
function getShared(options = defaultShareOptions) {
    const nfc = window;
    const externals = nfc.__NATIVE_FEDERATION__.externals;
    const shared = {};
    const allKeys = [...externals.keys()];
    const keys = allKeys
        .filter((k) => !k.startsWith('/@id/') &&
        !k.startsWith('@angular-architects/module-federation') &&
        !k.endsWith('@'))
        .sort();
    for (const key of keys) {
        const idx = key.lastIndexOf('@');
        const pkgName = key.substring(0, idx);
        const version = key.substring(idx + 1);
        const path = externals.get(key) ?? '';
        const shareObj = {
            version,
            get: async () => {
                const lib = await window.importShim(path);
                return () => lib;
            },
            shareConfig: {
                singleton: options.singleton,
                requiredVersion: options.requiredVersionPrefix + version,
            },
        };
        if (!shared[pkgName]) {
            shared[pkgName] = [];
        }
        shared[pkgName].push(shareObj);
    }
    return shared;
}

const nfNamespace = '__NATIVE_FEDERATION__';
const global = globalThis;
global[nfNamespace] ??= {
    externals: new Map(),
    remoteNamesToRemote: new Map(),
    baseUrlToRemoteNames: new Map(),
};
const globalCache = global[nfNamespace];

const externals = globalCache.externals;
function getExternalKey(shared) {
    return `${shared.packageName}@${shared.version}`;
}
function getExternalUrl(shared) {
    const packageKey = getExternalKey(shared);
    return externals.get(packageKey);
}
function setExternalUrl(shared, url) {
    const packageKey = getExternalKey(shared);
    externals.set(packageKey, url);
}

function mergeImportMaps(map1, map2) {
    return {
        imports: { ...map1.imports, ...map2.imports },
        scopes: { ...map1.scopes, ...map2.scopes },
    };
}

const remoteNamesToRemote = globalCache.remoteNamesToRemote;
const baseUrlToRemoteNames = globalCache.baseUrlToRemoteNames;
function addRemote(remoteName, remote) {
    remoteNamesToRemote.set(remoteName, remote);
    baseUrlToRemoteNames.set(remote.baseUrl, remoteName);
}
function getRemoteNameByBaseUrl(baseUrl) {
    return baseUrlToRemoteNames.get(baseUrl);
}
function isRemoteInitialized(baseUrl) {
    return baseUrlToRemoteNames.has(baseUrl);
}
function getRemote(remoteName) {
    return remoteNamesToRemote.get(remoteName);
}
function hasRemote(remoteName) {
    return remoteNamesToRemote.has(remoteName);
}

function appendImportMap(importMap) {
    document.head.appendChild(Object.assign(document.createElement('script'), {
        type: 'importmap-shim',
        innerHTML: JSON.stringify(importMap),
    }));
}

function getDirectory(url) {
    const parts = url.split('/');
    parts.pop();
    return parts.join('/');
}
function joinPaths(path1, path2) {
    while (path1.endsWith('/')) {
        path1 = path1.substring(0, path1.length - 1);
    }
    if (path2.startsWith('./')) {
        path2 = path2.substring(2, path2.length);
    }
    return `${path1}/${path2}`;
}

const BUILD_NOTIFICATIONS_ENDPOINT = '/@angular-architects/native-federation:build-notifications';
var BuildNotificationType;
(function (BuildNotificationType) {
    BuildNotificationType["COMPLETED"] = "federation-rebuild-complete";
    BuildNotificationType["ERROR"] = "federation-rebuild-error";
})(BuildNotificationType || (BuildNotificationType = {}));

/**
 * Watches for federation build completion events and automatically reloads the page.
 *
 * This function establishes a Server-Sent Events (SSE) connection to listen for
 * 'federation-rebuild-complete' notifications. When a build completes successfully,
 * it triggers a page reload to reflect the latest changes.
 * @param endpoint - The SSE endpoint URL to watch for build notifications.
 */
function watchFederationBuildCompletion(endpoint) {
    const eventSource = new EventSource(endpoint);
    eventSource.onmessage = function (event) {
        const data = JSON.parse(event.data);
        if (data.type === BuildNotificationType.COMPLETED) {
            console.log('[Federation] Rebuild completed, reloading...');
            window.location.reload();
        }
    };
    eventSource.onerror = function (event) {
        console.warn('[Federation] SSE connection error:', event);
    };
}

/**
 * Initialize the federation runtime
 * @param remotesOrManifestUrl
 * @param options The cacheTag allows you to invalidate the cache of the remoteEntry.json files, pass a new value with every release (f.ex. the version number)
 */
async function initFederation(remotesOrManifestUrl = {}, options) {
    const cacheOption = options?.cacheTag ? `?t=${options.cacheTag}` : '';
    const remotes = typeof remotesOrManifestUrl === 'string'
        ? await loadManifest(remotesOrManifestUrl + cacheOption)
        : remotesOrManifestUrl;
    const url = './remoteEntry.json' + cacheOption;
    const hostInfo = await loadFederationInfo(url);
    const hostImportMap = await processHostInfo(hostInfo);
    const remotesImportMap = await processRemoteInfos(remotes, {
        throwIfRemoteNotFound: false,
        ...options,
    });
    const importMap = mergeImportMaps(hostImportMap, remotesImportMap);
    appendImportMap(importMap);
    return importMap;
}
async function loadManifest(remotes) {
    return (await fetch(remotes).then((r) => r.json()));
}
async function processRemoteInfos(remotes, options = { throwIfRemoteNotFound: false }) {
    const processRemoteInfoPromises = Object.keys(remotes).map(async (remoteName) => {
        try {
            let url = remotes[remoteName];
            if (options.cacheTag) {
                const addAppend = remotes[remoteName].includes('?') ? '&' : '?';
                url += `${addAppend}t=${options.cacheTag}`;
            }
            return await processRemoteInfo(url, remoteName);
        }
        catch (e) {
            const error = `Error loading remote entry for ${remoteName} from file ${remotes[remoteName]}`;
            if (options.throwIfRemoteNotFound) {
                throw new Error(error);
            }
            console.error(error);
            return null;
        }
    });
    const remoteImportMaps = await Promise.all(processRemoteInfoPromises);
    const importMap = remoteImportMaps.reduce((acc, remoteImportMap) => remoteImportMap ? mergeImportMaps(acc, remoteImportMap) : acc, { imports: {}, scopes: {} });
    return importMap;
}
async function processRemoteInfo(federationInfoUrl, remoteName) {
    const baseUrl = getDirectory(federationInfoUrl);
    const remoteInfo = await loadFederationInfo(federationInfoUrl);
    if (!remoteName) {
        remoteName = remoteInfo.name;
    }
    if (remoteInfo.buildNotificationsEndpoint) {
        watchFederationBuildCompletion(baseUrl + remoteInfo.buildNotificationsEndpoint);
    }
    const importMap = createRemoteImportMap(remoteInfo, remoteName, baseUrl);
    addRemote(remoteName, { ...remoteInfo, baseUrl });
    return importMap;
}
function createRemoteImportMap(remoteInfo, remoteName, baseUrl) {
    const imports = processExposed(remoteInfo, remoteName, baseUrl);
    const scopes = processRemoteImports(remoteInfo, baseUrl);
    return { imports, scopes };
}
async function loadFederationInfo(url) {
    const info = (await fetch(url).then((r) => r.json()));
    return info;
}
function processRemoteImports(remoteInfo, baseUrl) {
    const scopes = {};
    const scopedImports = {};
    for (const shared of remoteInfo.shared) {
        const outFileName = getExternalUrl(shared) ?? joinPaths(baseUrl, shared.outFileName);
        setExternalUrl(shared, outFileName);
        scopedImports[shared.packageName] = outFileName;
    }
    scopes[baseUrl + '/'] = scopedImports;
    return scopes;
}
function processExposed(remoteInfo, remoteName, baseUrl) {
    const imports = {};
    for (const exposed of remoteInfo.exposes) {
        const key = joinPaths(remoteName, exposed.key);
        const value = joinPaths(baseUrl, exposed.outFileName);
        imports[key] = value;
    }
    return imports;
}
async function processHostInfo(hostInfo, relBundlesPath = './') {
    const imports = hostInfo.shared.reduce((acc, cur) => ({
        ...acc,
        [cur.packageName]: relBundlesPath + cur.outFileName,
    }), {});
    for (const shared of hostInfo.shared) {
        setExternalUrl(shared, relBundlesPath + shared.outFileName);
    }
    return { imports, scopes: {} };
}

/* eslint-disable @typescript-eslint/no-explicit-any */
async function loadRemoteModule(optionsOrRemoteName, exposedModule) {
    const options = normalizeOptions(optionsOrRemoteName, exposedModule);
    await ensureRemoteInitialized(options);
    const remoteName = getRemoteNameByOptions(options);
    const remote = getRemote(remoteName);
    const fallback = options.fallback;
    const remoteError = !remote ? 'unknown remote ' + remoteName : '';
    if (!remote && !fallback) {
        throw new Error(remoteError);
    }
    else if (!remote) {
        logClientError(remoteError);
        return Promise.resolve(fallback);
    }
    const exposed = remote.exposes.find((e) => e.key === options.exposedModule);
    const exposedError = !exposed
        ? `Unknown exposed module ${options.exposedModule} in remote ${remoteName}`
        : '';
    if (!exposed && !fallback) {
        throw new Error(exposedError);
    }
    else if (!exposed) {
        logClientError(exposedError);
        return Promise.resolve(fallback);
    }
    const url = joinPaths(remote.baseUrl, exposed.outFileName);
    try {
        const module = _import(url);
        return module;
    }
    catch (e) {
        if (fallback) {
            console.error('error loading remote module', e);
            return fallback;
        }
        throw e;
    }
}
function _import(url) {
    return typeof importShim !== 'undefined'
        ? importShim(url)
        : import(/* @vite-ignore */ url);
}
function getRemoteNameByOptions(options) {
    let remoteName;
    if (options.remoteName) {
        remoteName = options.remoteName;
    }
    else if (options.remoteEntry) {
        const baseUrl = getDirectory(options.remoteEntry);
        remoteName = getRemoteNameByBaseUrl(baseUrl);
    }
    else {
        throw new Error('unexpcted arguments: Please pass remoteName or remoteEntry');
    }
    if (!remoteName) {
        throw new Error('unknown remoteName ' + remoteName);
    }
    return remoteName;
}
async function ensureRemoteInitialized(options) {
    if (options.remoteEntry &&
        !isRemoteInitialized(getDirectory(options.remoteEntry))) {
        const importMap = await processRemoteInfo(options.remoteEntry);
        appendImportMap(importMap);
    }
}
function normalizeOptions(optionsOrRemoteName, exposedModule) {
    let options;
    if (typeof optionsOrRemoteName === 'string' && exposedModule) {
        options = {
            remoteName: optionsOrRemoteName,
            exposedModule,
        };
    }
    else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {
        options = optionsOrRemoteName;
    }
    else {
        throw new Error('unexpected arguments: please pass options or a remoteName/exposedModule-pair');
    }
    return options;
}
function logClientError(error) {
    if (typeof window !== 'undefined') {
        console.error(error);
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { BUILD_NOTIFICATIONS_ENDPOINT, BuildNotificationType, getShared, initFederation, loadRemoteModule, mergeImportMaps, processHostInfo, processRemoteInfo, processRemoteInfos };
//# sourceMappingURL=softarc-native-federation-runtime.mjs.map
