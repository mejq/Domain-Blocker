"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.list = list;
const fs_path_1 = require("../file-info/fs-path");
const calc_tags_for_module_1 = require("../tags/calc-tags-for-module");
const get_entry_from_cli_or_config_1 = require("./internal/get-entry-from-cli-or-config");
const getFs_1 = __importDefault(require("../fs/getFs"));
const cli_1 = require("./cli");
const log_info_for_missing_sheriff_config_1 = require("./internal/log-info-for-missing-sheriff-config");
function list(args) {
    const projectInfo = (0, get_entry_from_cli_or_config_1.getEntryFromCliOrConfig)(args[0]);
    (0, log_info_for_missing_sheriff_config_1.logInfoForMissingSheriffConfig)(projectInfo);
    // root doesn't count
    const modulesCount = projectInfo.modules.length - 1;
    cli_1.cli.log(`This project contains ${modulesCount} modules:`);
    cli_1.cli.log('');
    cli_1.cli.log('. (root)');
    const directory = mapModulesToDirectory(Array.from(projectInfo.modules
        .filter((module) => !module.isRoot)
        .map((module) => (0, fs_path_1.toFsPath)(module.path))), projectInfo);
    printDirectory(directory);
}
function mapModulesToDirectory(modulePaths, projectInfo) {
    const fs = (0, getFs_1.default)();
    const directory = {};
    for (const modulePath of modulePaths) {
        const cleanedModulePath = fs.relativeTo(projectInfo.rootDir, modulePath);
        const folders = cleanedModulePath.split('/');
        let currentEntry = directory;
        for (let i = 0; i < folders.length; i++) {
            const folder = folders[i];
            currentEntry[folder] = currentEntry[folder] || {
                children: {},
                tags: '',
                isModule: false,
            };
            if (i === folders.length - 1) {
                currentEntry[folder].tags =
                    ` (${getTags(modulePath, projectInfo).join(', ')})`;
                currentEntry[folder].isModule = true;
            }
            else {
                currentEntry = currentEntry[folder].children;
            }
        }
    }
    return directory;
}
function printDirectory(directory, indent = 0) {
    const entries = Object.entries(directory);
    // Iterate through each key in the directory
    entries.forEach(([key, { children, tags, isModule }], ix) => {
        const symbol = ix === entries.length - 1 ? '└── ' : '├── ';
        cli_1.cli.log(' '.repeat(indent) + symbol + (isModule ? cli_1.cli.bold(key) + tags : key));
        if (Object.entries(children).length) {
            printDirectory(children, indent + 2);
        }
    });
}
function getTags(module, projectInfo) {
    return (0, calc_tags_for_module_1.calcTagsForModule)(module, projectInfo.rootDir, projectInfo.config.modules, projectInfo.config.autoTagging);
}
//# sourceMappingURL=list.js.map