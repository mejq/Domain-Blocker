"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findModulePathsWithoutBarrel = findModulePathsWithoutBarrel;
const create_module_path_patterns_tree_1 = require("./create-module-path-patterns-tree");
const getFs_1 = __importDefault(require("../../fs/getFs"));
const calc_tags_for_module_1 = require("../../tags/calc-tags-for-module");
const flatten_modules_1 = require("./flatten-modules");
/**
 * The current criterion for finding modules is via
 * the SheriffConfig's property `modules`.
 *
 * We will traverse the filesystem and match directories
 * against the patterns.
 */
function findModulePathsWithoutBarrel(moduleConfig, rootDir, barrelFileName) {
    const paths = (0, flatten_modules_1.flattenModules)(moduleConfig, '');
    const modulePathsPatternTree = (0, create_module_path_patterns_tree_1.createModulePathPatternsTree)(paths);
    const modules = traverseAndMatch(modulePathsPatternTree, rootDir, barrelFileName);
    return new Set(modules);
}
/**
 * Recursively traverse the filesystem and match directories against patterns.
 */
function traverseAndMatch(groupedPatterns, basePath, barrelFileName) {
    const fs = (0, getFs_1.default)();
    const matchedDirectories = [];
    // Check if the current directory should be matched
    if ('' in groupedPatterns) {
        addAsModuleIfWithoutBarrel(matchedDirectories, basePath, barrelFileName);
    }
    const subDirectories = fs.readDirectory(basePath, 'directory');
    for (const subDirectory of subDirectories) {
        const currentSegment = fs.relativeTo(basePath, subDirectory);
        const patterns = Object.keys(groupedPatterns);
        const matchingPattern = patterns.find((pattern) => matchPattern(pattern, currentSegment));
        if (matchingPattern) {
            if (Object.keys(groupedPatterns[matchingPattern]).length === 0) {
                addAsModuleIfWithoutBarrel(matchedDirectories, subDirectory, barrelFileName);
            }
            else {
                const newDirectories = traverseAndMatch(groupedPatterns[matchingPattern], subDirectory, barrelFileName);
                for (const newDirectory of newDirectories) {
                    addAsModuleIfWithoutBarrel(matchedDirectories, newDirectory, barrelFileName);
                }
            }
        }
    }
    return matchedDirectories;
}
/**
 * Matches a given directory path against a pattern, allowing wildcards.
 */
function matchPattern(pattern, pathSegment) {
    if (pattern === '*' || pattern === pathSegment) {
        return true;
    }
    if (pattern.includes('*')) {
        const regexPattern = pattern.replace(/\*/g, `${calc_tags_for_module_1.FOLDER_CHARACTERS_REGEX_STRING}*`);
        const regex = new RegExp(`^${regexPattern}$`);
        return regex.test(pathSegment);
    }
    return false;
}
function addAsModuleIfWithoutBarrel(modulePaths, directory, barrelFileName) {
    const fs = (0, getFs_1.default)();
    if (fs.exists(fs.join(directory, barrelFileName))) {
        return;
    }
    modulePaths.push(directory);
}
//# sourceMappingURL=find-module-paths-without-barrel.js.map