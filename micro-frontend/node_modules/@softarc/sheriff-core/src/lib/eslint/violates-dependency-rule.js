"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.violatesDependencyRule = void 0;
const fs_path_1 = require("../file-info/fs-path");
const throw_if_null_1 = __importDefault(require("../util/throw-if-null"));
const log_1 = require("../log");
const init_1 = require("../main/init");
const check_for_dependency_rule_violation_1 = require("../checks/check-for-dependency-rule-violation");
let cache = {};
let cacheActive = false;
let fileInfo;
let configFileIsMissing = false;
const log = (0, log_1.logger)('core.eslint.dependency-rules');
const violatesDependencyRule = (filename, importCommand, isFirstRun, fileContent) => {
    var _a;
    if (isFirstRun) {
        cache = {};
        fileInfo = undefined;
        cacheActive = false;
        configFileIsMissing = false;
    }
    if (configFileIsMissing) {
        return '';
    }
    if (!cacheActive) {
        cacheActive = true;
        const projectInfo = (0, init_1.init)((0, fs_path_1.toFsPath)(filename), {
            traverse: false,
            entryFileContent: fileContent,
            returnOnMissingConfig: true,
        });
        if (!projectInfo) {
            log.info('no sheriff.config.ts present');
            configFileIsMissing = true;
            return '';
        }
        fileInfo = projectInfo.fileInfo;
        const violations = (0, check_for_dependency_rule_violation_1.checkForDependencyRuleViolation)((0, fs_path_1.toFsPath)(filename), projectInfo);
        const { rootDir } = projectInfo;
        for (const violation of violations) {
            cache[violation.rawImport] = formatViolation(violation, rootDir);
        }
    }
    if ((0, throw_if_null_1.default)(fileInfo).isUnresolvableImport(importCommand)) {
        return `import ${importCommand} cannot be resolved`;
    }
    return (_a = cache[importCommand]) !== null && _a !== void 0 ? _a : '';
};
exports.violatesDependencyRule = violatesDependencyRule;
function formatViolation(violation, rootDir) {
    const { fromModulePath, toModulePath, fromTag, toTags } = violation;
    return `module ${fromModulePath.substring(rootDir.length)} cannot access ${toModulePath.substring(rootDir.length)}. Tag ${fromTag} has no clearance for tags ${toTags.join(', ')}`;
}
//# sourceMappingURL=violates-dependency-rule.js.map