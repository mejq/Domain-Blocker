"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasEncapsulationViolations = hasEncapsulationViolations;
const getFs_1 = __importDefault(require("../fs/getFs"));
/**
 * verifies if an existing file has imports which break
 * the other module's encapsulation.
 *
 * Unresolvable imports are skipped.
 *
 * It is up to the caller to decide.
 */
function hasEncapsulationViolations(fsPath, { rootDir, config, getFileInfo }) {
    const encapsulationViolations = {};
    const assignedFileInfo = getFileInfo(fsPath);
    for (const importedFileInfo of assignedFileInfo.imports) {
        if (isSameModule(importedFileInfo, assignedFileInfo) ||
            isExcludedRootModule(rootDir, config, importedFileInfo) ||
            accessesBarrelFileForBarrelModules(importedFileInfo) ||
            accessesExposedFileForBarrelLessModules(importedFileInfo, config.enableBarrelLess, config.encapsulationPattern)) {
            // üëç all good
        }
        else {
            const rawImport = assignedFileInfo.getRawImportForImportedFileInfo(importedFileInfo.path);
            encapsulationViolations[rawImport] = importedFileInfo;
        }
    }
    return encapsulationViolations;
}
function accessesExposedFileForBarrelLessModules(fileInfo, enableBarrelLess, encapsulationPattern) {
    const fs = (0, getFs_1.default)();
    if (!enableBarrelLess) {
        return false;
    }
    if (fileInfo.moduleInfo.hasBarrel) {
        return false;
    }
    const relativePath = fs.relativeTo(fileInfo.moduleInfo.path, fileInfo.path);
    if (typeof encapsulationPattern === 'string') {
        return !relativePath.startsWith(encapsulationPattern);
    }
    else {
        const matches = relativePath.match(encapsulationPattern);
        return !matches;
    }
}
function accessesBarrelFileForBarrelModules(fileInfo) {
    if (!fileInfo.moduleInfo.hasBarrel) {
        return false;
    }
    return fileInfo.moduleInfo.barrelPath === fileInfo.path;
}
function isExcludedRootModule(rootDir, config, importedModule) {
    if (importedModule.moduleInfo.path !== rootDir) {
        return false;
    }
    return config.excludeRoot;
}
function isSameModule(importedFileInfo, assignedFileInfo) {
    return importedFileInfo.moduleInfo.path === assignedFileInfo.moduleInfo.path;
}
//# sourceMappingURL=has-encapsulation-violations.js.map