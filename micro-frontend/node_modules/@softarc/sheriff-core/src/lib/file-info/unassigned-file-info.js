"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _UnassignedFileInfo_rawImportMap, _UnassignedFileInfo_unresolvableImports, _UnassignedFileInfo_externalLibraries;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnassignedFileInfo = void 0;
const throw_if_null_1 = __importDefault(require("../util/throw-if-null"));
/**
 * Represents a TypeScript file with its dependencies but does
 * not yet have an assignment to a module.
 *
 * After module assignment is done, it becomes a type `FileInfo`.
 *
 * If an import cannot be resolved, it doesn't throw an error
 * but is added to unresolvableImports.
 *
 * It is up to the consumer, e.g. ESLinter, to decide if that
 * should cause an error or not.
 */
class UnassignedFileInfo {
    constructor(path, imports = []) {
        this.path = path;
        this.imports = imports;
        _UnassignedFileInfo_rawImportMap.set(this, new Map());
        _UnassignedFileInfo_unresolvableImports.set(this, []);
        _UnassignedFileInfo_externalLibraries.set(this, []);
    }
    addUnresolvableImport(importCommand) {
        __classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f").push(importCommand);
    }
    get unresolvableImports() {
        return [...__classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f")];
    }
    isUnresolvableImport(importCommand) {
        return __classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f").includes(importCommand);
    }
    hasUnresolvableImports() {
        return __classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f").length > 0;
    }
    addImport(importedFileInfo, rawImport) {
        this.imports.push(importedFileInfo);
        __classPrivateFieldGet(this, _UnassignedFileInfo_rawImportMap, "f").set(importedFileInfo.path, rawImport);
    }
    getRawImportForImportedFileInfo(path) {
        return (0, throw_if_null_1.default)(__classPrivateFieldGet(this, _UnassignedFileInfo_rawImportMap, "f").get(path), `raw import for ${path} is not available in ${this.path}`);
    }
    addExternalLibrary(libraryImport) {
        if (__classPrivateFieldGet(this, _UnassignedFileInfo_externalLibraries, "f").includes(libraryImport)) {
            return;
        }
        __classPrivateFieldGet(this, _UnassignedFileInfo_externalLibraries, "f").push(libraryImport);
    }
    getExternalLibraries() {
        return [...__classPrivateFieldGet(this, _UnassignedFileInfo_externalLibraries, "f")];
    }
}
exports.UnassignedFileInfo = UnassignedFileInfo;
_UnassignedFileInfo_rawImportMap = new WeakMap(), _UnassignedFileInfo_unresolvableImports = new WeakMap(), _UnassignedFileInfo_externalLibraries = new WeakMap();
//# sourceMappingURL=unassigned-file-info.js.map