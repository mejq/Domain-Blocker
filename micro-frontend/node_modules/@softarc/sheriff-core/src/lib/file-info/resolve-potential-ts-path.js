"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePotentialTsPath = resolvePotentialTsPath;
const fs_path_1 = require("./fs-path");
const getFs_1 = __importDefault(require("../fs/getFs"));
const fix_path_separators_1 = require("./fix-path-separators");
/**
 * Resolves a import statements which use a TypeScript alias.
 * If resolving does not work, it returns an undefined.
 *
 * It only works if the import state is using aliases from tsconfig.json.
 *
 * ```typescript
 * import { AppComponent } from '@app/app.component';
 * ```
 *
 * @param moduleName name as it is in the import statement, e.g. '../app.component'
 * @param tsPaths resolved paths from the tsconfig.json file
 * @param resolveFn function to resolve the path, built-in TypeScript resolver
 */
function resolvePotentialTsPath(moduleName, tsPaths, resolveFn) {
    let unpathedImport;
    for (const tsPath in tsPaths) {
        const { isWildcard, clearedTsPath } = clearTsPath(tsPath);
        // import from '@app/app.component' & paths: {'@app/*': ['src/app/*']}
        if (isWildcard && moduleName.startsWith(clearedTsPath)) {
            const pathMapping = tsPaths[tsPath];
            unpathedImport = moduleName.replace(clearedTsPath, pathMapping);
        }
        // import from '@app' & paths: { '@app': [''] }
        else if (tsPath === moduleName) {
            unpathedImport = tsPaths[tsPath];
        }
        // current path applies -> resolve it
        if (unpathedImport) {
            // path is file -> return as is
            if (isPathFile(unpathedImport)) {
                return (0, fix_path_separators_1.fixPathSeparators)((0, fs_path_1.toFsPath)(unpathedImport));
            }
            // path is directory or something else -> rely on TypeScript resolvers
            else {
                const resolvedImport = resolveFn(unpathedImport);
                // if path applies but import is for external library with same time,
                // we need to rely on the native TypeScript resolver, which is done
                // outside the path resolving.
                if (resolvedImport.resolvedModule) {
                    return (0, fs_path_1.toFsPath)((0, fix_path_separators_1.fixPathSeparators)(resolvedImport.resolvedModule.resolvedFileName));
                }
            }
        }
    }
    return undefined;
}
function clearTsPath(tsPath) {
    const [isWildcard, clearedPath] = tsPath.endsWith('/*')
        ? [true, tsPath.slice(0, -2)]
        : [false, tsPath];
    return { isWildcard, clearedTsPath: clearedPath };
}
/**
 * Checks if the path is a file.
 *
 * For example in tsconfig.json:
 * ```json
 *   "paths": {
 *     "@app": ["src/app/index"]
 *   }
 * ```
 *
 * 'src/app/index' comes already as absolute path with ts extension from
 * pre-processing of @generateTsData.
 *
 * @param path '/.../src/app/index.ts' according to the example above
 */
function isPathFile(path) {
    const fs = (0, getFs_1.default)();
    return fs.exists(path) && (0, fs_path_1.isFsPath)(path) && fs.isFile(path);
}
//# sourceMappingURL=resolve-potential-ts-path.js.map