"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseFilesystem = traverseFilesystem;
const unassigned_file_info_1 = require("./unassigned-file-info");
const getFs_1 = __importDefault(require("../fs/getFs"));
const ts = __importStar(require("typescript"));
const resolve_potential_ts_path_1 = require("./resolve-potential-ts-path");
const fix_path_separators_1 = require("./fix-path-separators");
// https://stackoverflow.com/questions/71815527/typescript-compiler-apihow-to-get-absolute-path-to-source-file-of-import-module
/**
 * This function generates the FileInfo tree.
 * It starts with the entry TypeScript file and traverse all its imports.
 *
 * It does not follow an import when it is an external library, i.e. comes from
 * node_modules. The same is true, if a file is already traversed.
 *
 * To improve the testability, we use abstraction whenever access to the
 * filesystem happens. In case the abstraction does not emulate the original's
 * behaviour, "strange bugs" might occur. Look out for them.
 *
 * fixPathSeparators is necessary to replace the static '/' path separator
 * with the one from the OS.
 *
 * @param fsPath Filename to traverse from
 * @param fileInfoDict Dictionary of traversed files to catch circularity
 * @param tsData
 * @param runOnce traverse only once. needed for ESLint mode
 * @param fileContent if passed, is used instead the content of @fsPath.
 * necessary for unsaved files inESLint
 */
function traverseFilesystem(fsPath, fileInfoDict, tsData, runOnce = false, fileContent) {
    const { paths, sys, rootDir, baseUrl, configObject } = tsData;
    const fileInfo = new unassigned_file_info_1.UnassignedFileInfo(fsPath, []);
    fileInfoDict.set(fsPath, fileInfo);
    const fs = (0, getFs_1.default)();
    fileContent = fileContent !== null && fileContent !== void 0 ? fileContent : fs.readFile(fsPath);
    const preProcessedFile = ts.preProcessFile(fileContent);
    const config = Object.assign(Object.assign({}, configObject.options), { baseUrl });
    const resolveFn = (moduleName) => ts.resolveModuleName(moduleName, fsPath, config, sys);
    for (const importedFile of preProcessedFile.importedFiles) {
        const { fileName } = importedFile;
        const resolvedImport = resolveFn(fileName);
        let importPath;
        // skip json imports
        if (fileName.endsWith('.json')) {
            continue;
        }
        // alias/path resolving has priority
        const resolvedTsPath = (0, resolve_potential_ts_path_1.resolvePotentialTsPath)(fileName, paths, resolveFn);
        if (resolvedTsPath) {
            importPath = resolvedTsPath;
        }
        // check if external library or normal file
        else if (resolvedImport.resolvedModule) {
            const { resolvedFileName } = resolvedImport.resolvedModule;
            if (!resolvedImport.resolvedModule.isExternalLibraryImport) {
                importPath = (0, fix_path_separators_1.fixPathSeparators)(resolvedFileName);
                if (!importPath.startsWith(rootDir)) {
                    throw new Error(`${importPath} is outside of root ${rootDir}`);
                }
            }
            else {
                fileInfo.addExternalLibrary(fileName);
            }
        }
        // might be an undetected dependency in node_modules
        // or an incomplete import (= developer is still typing),
        // if we read from an unsaved file via ESLint.
        else {
            fileInfo.addUnresolvableImport(fileName);
        }
        if (importPath) {
            const existing = fileInfoDict.get(importPath);
            if (existing) {
                fileInfo.addImport(existing, fileName);
            }
            else if (runOnce) {
                fileInfo.addImport(new unassigned_file_info_1.UnassignedFileInfo(importPath), fileName);
            }
            else {
                fileInfo.addImport(traverseFilesystem(importPath, fileInfoDict, tsData), fileName);
            }
        }
    }
    return fileInfo;
}
//# sourceMappingURL=traverse-filesystem.js.map