"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectData = getProjectData;
const fs_path_1 = require("../file-info/fs-path");
const init_1 = require("../main/init");
const calc_tags_for_module_1 = require("../tags/calc-tags-for-module");
const traverse_file_info_1 = require("../modules/traverse-file-info");
const getFs_1 = __importDefault(require("../fs/getFs"));
function calcOrGetTags(modulePath, projectInfo, tagsCache) {
    if (modulePath in tagsCache) {
        return tagsCache[modulePath];
    }
    const tags = (0, calc_tags_for_module_1.calcTagsForModule)(modulePath, projectInfo.rootDir, projectInfo.config.modules, projectInfo.config.autoTagging);
    tagsCache[modulePath] = tags;
    return tags;
}
function getProjectData(entryFile, cwdOrOptions, optionalOptions) {
    const fs = (0, getFs_1.default)();
    const absoluteEntryFile = cwdOrOptions === undefined
        ? entryFile
        : typeof cwdOrOptions === 'string'
            ? fs.join(cwdOrOptions, entryFile)
            : entryFile;
    const cwd = typeof cwdOrOptions === 'string' ? cwdOrOptions : undefined;
    const options = optionalOptions
        ? optionalOptions
        : typeof cwdOrOptions === 'object'
            ? cwdOrOptions
            : {};
    const projectInfo = (0, init_1.init)((0, fs_path_1.toFsPath)(absoluteEntryFile));
    const data = {};
    const tagsCache = {};
    for (const { fileInfo } of (0, traverse_file_info_1.traverseFileInfo)(projectInfo.fileInfo)) {
        const entry = {
            module: fileInfo.moduleInfo.path || '.',
            moduleType: fileInfo.moduleInfo.hasBarrel ? 'barrel' : 'barrel-less',
            tags: calcOrGetTags(fileInfo.moduleInfo.path, projectInfo, tagsCache),
            imports: fileInfo.imports.map((fileInfo) => fileInfo.path),
            unresolvedImports: fileInfo.unresolvableImports,
        };
        if (options.includeExternalLibraries) {
            entry.externalLibraries = [...fileInfo.getExternalLibraries()].sort((a, b) => a.localeCompare(b));
        }
        data[fileInfo.path] = entry;
    }
    return relativizeIfRequired(data, Object.assign(Object.assign({}, options), { cwd }));
}
function relativizeIfRequired(data, options) {
    const { cwd } = options;
    if (cwd === undefined) {
        return data;
    }
    const fs = (0, getFs_1.default)();
    const relative = (path) => fs.relativeTo(cwd, path) || '.';
    const relativizedData = {};
    for (const [modulePath, moduleData] of Object.entries(data)) {
        const entry = {
            module: relative((0, fs_path_1.toFsPath)(moduleData.module)),
            moduleType: moduleData.moduleType,
            tags: moduleData.tags,
            imports: moduleData.imports.map((importPath) => relative((0, fs_path_1.toFsPath)(importPath))),
            unresolvedImports: moduleData.unresolvedImports,
        };
        if (options.includeExternalLibraries) {
            entry.externalLibraries = moduleData.externalLibraries;
        }
        relativizedData[relative((0, fs_path_1.toFsPath)(modulePath))] = entry;
    }
    return relativizedData;
}
//# sourceMappingURL=get-project-data.js.map