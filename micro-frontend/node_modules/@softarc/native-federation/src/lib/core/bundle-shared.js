"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleShared = bundleShared;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs"));
const build_utils_1 = require("../utils/build-utils");
const package_info_1 = require("../utils/package-info");
const copy_src_map_if_exists_1 = require("../utils/copy-src-map-if-exists");
const logger_1 = require("../utils/logger");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const default_external_list_1 = require("./default-external-list");
const rewrite_chunk_imports_1 = require("../utils/rewrite-chunk-imports");
function bundleShared(sharedBundles_1, config_1, fedOptions_1, externals_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (sharedBundles, config, fedOptions, externals, platform = 'browser') {
        const folder = fedOptions.packageJson
            ? path.dirname(fedOptions.packageJson)
            : fedOptions.workspaceRoot;
        const cachePath = path.join(fedOptions.workspaceRoot, 'node_modules/.cache/native-federation');
        fs.mkdirSync(cachePath, { recursive: true });
        const inferedPackageInfos = Object.keys(sharedBundles)
            .filter((packageName) => !sharedBundles[packageName].packageInfo)
            .map((packageName) => (0, package_info_1.getPackageInfo)(packageName, folder))
            .filter((pi) => !!pi);
        const configuredPackageInfos = Object.keys(sharedBundles)
            .filter((packageName) => !!sharedBundles[packageName].packageInfo)
            .map((packageName) => (Object.assign({ packageName }, sharedBundles[packageName].packageInfo)));
        const packageInfos = [...inferedPackageInfos, ...configuredPackageInfos];
        const configState = 'BUNDLER_CHUNKS' + // TODO: Replace this with lib version
            fs.readFileSync(path.join(__dirname, '../../../package.json')) +
            JSON.stringify(config);
        const allEntryPoints = packageInfos.map((pi) => {
            const encName = pi.packageName.replace(/[^A-Za-z0-9]/g, '_');
            const outName = createOutName(pi, configState, fedOptions, encName);
            return { fileName: pi.entryPoint, outName };
        });
        const fullOutputPath = path.join(fedOptions.workspaceRoot, fedOptions.outputPath);
        const exptedResults = allEntryPoints.map((ep) => path.join(fullOutputPath, ep.outName));
        const entryPoints = allEntryPoints.filter((ep) => !fs.existsSync(path.join(cachePath, ep.outName)));
        if (entryPoints.length > 0) {
            logger_1.logger.info('Preparing shared npm packages for the platform ' + platform);
            logger_1.logger.notice('This only needs to be done once, as results are cached');
            logger_1.logger.notice("Skip packages you don't want to share in your federation config");
        }
        // If we build for the browser and don't remote unused deps from the shared config,
        // we need to exclude typical node libs to avoid compilation issues
        const useDefaultExternalList = platform === 'browser' && !config.features.ignoreUnusedDeps;
        const additionalExternals = useDefaultExternalList
            ? default_external_list_1.DEFAULT_EXTERNAL_LIST
            : [];
        let bundleResult = null;
        try {
            bundleResult = yield (0, build_utils_1.bundle)({
                entryPoints,
                tsConfigPath: fedOptions.tsConfig,
                external: [...additionalExternals, ...externals],
                outdir: cachePath,
                mappedPaths: config.sharedMappings,
                dev: fedOptions.dev,
                kind: 'shared-package',
                hash: false,
                platform,
                optimizedMappings: config.features.ignoreUnusedDeps,
            });
            const cachedFiles = bundleResult.map((br) => path.basename(br.fileName));
            rewriteImports(cachedFiles, cachePath);
            copyCacheToOutput(cachedFiles, cachePath, fullOutputPath);
        }
        catch (e) {
            logger_1.logger.error('Error bundling shared npm package ');
            if (e instanceof Error) {
                logger_1.logger.error(e.message);
            }
            logger_1.logger.error('For more information, run in verbose mode');
            logger_1.logger.notice('');
            logger_1.logger.notice('');
            logger_1.logger.notice('** Important Information: ***');
            logger_1.logger.notice('The error message above shows an issue with bundling a node_module.');
            logger_1.logger.notice('In most cases this is because you (indirectly) shared a Node.js package,');
            logger_1.logger.notice('while Native Federation builds for the browser.');
            logger_1.logger.notice('You can move such packages into devDependencies or skip them in your federation.config.js.');
            logger_1.logger.notice('');
            logger_1.logger.notice('More Details: https://bit.ly/nf-issue');
            logger_1.logger.notice('');
            logger_1.logger.notice('');
            logger_1.logger.verbose(e);
            throw e;
        }
        const resultCacheFile = createCacheFileName(configState, sharedBundles, fedOptions, cachePath, platform);
        if (fs.existsSync(resultCacheFile)) {
            const cachedResult = JSON.parse(fs.readFileSync(resultCacheFile, 'utf-8'));
            const cachedFiles = cachedResult.map((cr) => cr.outFileName);
            // Chunks are overwritten by the bundler, so we need to reprocess them
            rewriteImports(cachedFiles, cachePath);
            copyCacheToOutput(cachedFiles, cachePath, fullOutputPath);
            return cachedResult;
        }
        const outFileNames = [...exptedResults];
        const result = buildResult(packageInfos, sharedBundles, outFileNames, fedOptions);
        // TODO: Decide whether/when to add .map files
        const chunks = bundleResult.filter((br) => !br.fileName.endsWith('.map') &&
            !result.find((r) => r.outFileName === path.basename(br.fileName)));
        addChunksToResult(chunks, result, fedOptions.dev);
        fs.writeFileSync(resultCacheFile, JSON.stringify(result, undefined, 2), 'utf-8');
        return result;
    });
}
function rewriteImports(cachedFiles, cachePath) {
    const newSourceFiles = cachedFiles.filter((cf) => (0, rewrite_chunk_imports_1.isSourceFile)(cf));
    for (const sourceFile of newSourceFiles) {
        const sourceFilePath = path.join(cachePath, sourceFile);
        (0, rewrite_chunk_imports_1.rewriteChunkImports)(sourceFilePath);
    }
}
function copyCacheToOutput(cachedFiles, cachePath, fullOutputPath) {
    for (const fileName of cachedFiles) {
        const cachedFile = path.join(cachePath, fileName);
        const distFileName = path.join(fullOutputPath, fileName);
        copyFileIfExists(cachedFile, distFileName);
        (0, copy_src_map_if_exists_1.copySrcMapIfExists)(cachedFile, distFileName);
    }
}
function createOutName(pi, configState, fedOptions, encName) {
    const hashBase = pi.version + '_' + pi.entryPoint + '_' + configState;
    const hash = calcHash(hashBase);
    const outName = fedOptions.dev
        ? `${encName}.${hash}-dev.js`
        : `${encName}.${hash}.js`;
    return outName;
}
function createCacheFileName(configState, sharedBundles, fedOptions, cachePath, platform) {
    const resultCacheState = configState + JSON.stringify(sharedBundles);
    const resultHash = calcHash(resultCacheState);
    const dev = fedOptions.dev ? '-dev' : '';
    const resultCacheFile = path.join(cachePath, 'result-' + resultHash + '-' + platform + dev + '.json');
    return resultCacheFile;
}
function buildResult(packageInfos, sharedBundles, outFileNames, fedOptions) {
    return packageInfos.map((pi) => {
        const shared = sharedBundles[pi.packageName];
        return {
            packageName: pi.packageName,
            outFileName: path.basename(outFileNames.shift() || ''),
            requiredVersion: shared.requiredVersion,
            singleton: shared.singleton,
            strictVersion: shared.strictVersion,
            version: pi.version,
            // TODO: Decide whether/when we need debug infos
            // dev: !fedOptions.dev
            //   ? undefined
            //   : {
            //       entryPoint: normalize(pi.entryPoint),
            //     },
        };
    });
}
function addChunksToResult(chunks, result, dev) {
    for (const item of chunks) {
        const fileName = path.basename(item.fileName);
        result.push({
            singleton: false,
            strictVersion: false,
            // Here, the version does not matter because
            // a) a chunk split off by the bundler does
            // not have a version and b) it gets a hash
            // code as part of the file name to be unique
            // when requested via a _versioned_ package.
            //
            // For the same reason, we don't need to
            // take care of singleton and strictVersion.
            requiredVersion: '0.0.0',
            version: '0.0.0',
            packageName: (0, rewrite_chunk_imports_1.deriveInternalName)(fileName),
            outFileName: fileName,
            // dev: dev
            //   ? undefined
            //   : {
            //       entryPoint: normalize(fileName),
            //     },
        });
    }
}
function calcHash(hashBase) {
    const hash = crypto_1.default
        .createHash('sha256')
        .update(hashBase)
        .digest('base64')
        .replace(/\//g, '_')
        .replace(/\+/g, '-')
        .replace(/=/g, '')
        .substring(0, 10);
    return hash;
}
function copyFileIfExists(cachedFile, fullOutputPath) {
    fs.mkdirSync(path.dirname(fullOutputPath), { recursive: true });
    if (fs.existsSync(cachedFile)) {
        fs.copyFileSync(cachedFile, fullOutputPath);
    }
}
//# sourceMappingURL=bundle-shared.js.map