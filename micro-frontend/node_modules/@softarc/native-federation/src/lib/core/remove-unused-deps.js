"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUnusedDeps = removeUnusedDeps;
const tslib_1 = require("tslib");
const sheriff_core_1 = require("@softarc/sheriff-core");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const process_1 = require("process");
const package_info_1 = require("../utils/package-info");
const get_external_imports_1 = require("../utils/get-external-imports");
function removeUnusedDeps(config, main, workspaceRoot) {
    const fileInfos = (0, sheriff_core_1.getProjectData)(main, (0, process_1.cwd)(), {
        includeExternalLibraries: true,
    });
    const usedDeps = findUsedDeps(fileInfos, workspaceRoot, config);
    const usedPackageNames = usedDeps.usedPackageNames;
    const usedMappings = usedDeps.usedMappings;
    const usedPackageNamesWithTransient = addTransientDeps(usedPackageNames, workspaceRoot);
    const filteredShared = filterShared(config, usedPackageNamesWithTransient);
    return Object.assign(Object.assign({}, config), { shared: filteredShared, sharedMappings: [...usedMappings] });
}
function filterShared(config, usedPackageNamesWithTransient) {
    const filteredSharedNames = Object.keys(config.shared).filter((shared) => usedPackageNamesWithTransient.has(shared));
    const filteredShared = filteredSharedNames.reduce((acc, curr) => (Object.assign(Object.assign({}, acc), { [curr]: config.shared[curr] })), {});
    return filteredShared;
}
function findUsedDeps(fileInfos, workspaceRoot, config) {
    const usedPackageNames = new Set();
    const usedMappings = new Set();
    for (const fileName of Object.keys(fileInfos)) {
        const fileInfo = fileInfos[fileName];
        if (!fileInfo) {
            continue;
        }
        const libs = [
            ...(fileInfo.externalLibraries || []),
            ...(fileInfo.unresolvedImports || []),
        ];
        for (const pckg of libs) {
            usedPackageNames.add(pckg);
        }
        const fullFileName = path_1.default.join(workspaceRoot, fileName);
        const mappings = config.sharedMappings.filter((sm) => sm.path === fullFileName);
        for (const mapping of mappings) {
            usedMappings.add(mapping);
        }
    }
    return { usedPackageNames, usedMappings };
}
function addTransientDeps(packages, workspaceRoot) {
    const packagesAndPeers = new Set([...packages]);
    const discovered = new Set(packagesAndPeers);
    const stack = [...packagesAndPeers];
    while (stack.length > 0) {
        const dep = stack.pop();
        if (!dep) {
            continue;
        }
        const pInfo = (0, package_info_1.getPackageInfo)(dep, workspaceRoot);
        if (!pInfo) {
            continue;
        }
        const peerDeps = getExternalImports(pInfo, workspaceRoot);
        for (const peerDep of peerDeps) {
            if (!discovered.has(peerDep)) {
                discovered.add(peerDep);
                stack.push(peerDep);
                packagesAndPeers.add(peerDep);
            }
        }
    }
    return packagesAndPeers;
}
function getExternalImports(pInfo, workspaceRoot) {
    const encodedPackageName = pInfo.packageName.replace(/[^A-Za-z0-9]/g, '_');
    const cacheFileName = `${encodedPackageName}-${pInfo.version}.deps.json`;
    const cachePath = path_1.default.join(workspaceRoot, 'node_modules/.cache/native-federation');
    const cacheFilePath = path_1.default.join(cachePath, cacheFileName);
    const cacheHit = fs_1.default.existsSync(cacheFilePath);
    let peerDeps;
    if (cacheHit) {
        peerDeps = JSON.parse(fs_1.default.readFileSync(cacheFilePath, 'utf-8'));
    }
    else {
        peerDeps = (0, get_external_imports_1.getExternalImports)(pInfo.entryPoint);
        fs_1.default.mkdirSync(cachePath, { recursive: true });
        fs_1.default.writeFileSync(cacheFilePath, JSON.stringify(peerDeps, undefined, 2), 'utf-8');
    }
    return peerDeps;
}
//# sourceMappingURL=remove-unused-deps.js.map