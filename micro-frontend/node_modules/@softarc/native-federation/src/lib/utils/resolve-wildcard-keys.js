"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveWildcardKeys = resolveWildcardKeys;
const tslib_1 = require("tslib");
const fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function compilePattern(pattern) {
    const tokens = pattern.split(/(\*\*|\*)/);
    const regexParts = [];
    for (const token of tokens) {
        if (token === '*') {
            regexParts.push('([^/]+)');
        }
        else if (token === '**') {
            regexParts.push('(.*)');
        }
        else {
            regexParts.push(escapeRegex(token));
        }
    }
    return new RegExp(`^${regexParts.join('')}$`);
}
function applyWildcards(template, wildcardValues) {
    const tokens = template.split(/(\*\*|\*)/);
    let result = '';
    let i = 0;
    for (const token of tokens) {
        if (token === '*' || token === '**') {
            result += wildcardValues[i++];
        }
        else {
            result += token;
        }
    }
    return result;
}
function resolveWildcardKeys(keyPattern, valuePattern, cwd) {
    const normalizedPattern = valuePattern.replace(/^\.?\/+/, '');
    const regex = compilePattern(normalizedPattern);
    const files = fast_glob_1.default.sync(valuePattern, {
        cwd,
        onlyFiles: true,
    });
    const keys = [];
    for (const file of files) {
        const relPath = file.replace(/\\/g, '/').replace(/^\.\//, '');
        const match = relPath.match(regex);
        if (!match) {
            continue;
        }
        const wildcards = match.slice(1);
        const key = applyWildcards(keyPattern, wildcards);
        // Change this:
        keys.push({ key, value: relPath });
    }
    return keys;
}
//# sourceMappingURL=resolve-wildcard-keys.js.map