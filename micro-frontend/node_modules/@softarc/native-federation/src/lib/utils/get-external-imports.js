"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExternalImports = getExternalImports;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs"));
const ts = tslib_1.__importStar(require("typescript"));
function getExternalImports(entryFilePath) {
    const visited = new Set();
    const externals = new Set();
    function isExternal(specifier) {
        return !specifier.startsWith('.') && !path.isAbsolute(specifier);
    }
    function normalizeExternal(specifier) {
        return specifier;
    }
    function resolveAsFileOrDirectory(p) {
        const abs = path.resolve(p);
        if (fs.existsSync(abs) && fs.statSync(abs).isFile())
            return abs;
        const extensions = ['.ts', '.js', '.mjs', '.cjs'];
        for (const ext of extensions) {
            if (fs.existsSync(abs + ext) && fs.statSync(abs + ext).isFile()) {
                return abs + ext;
            }
        }
        if (fs.existsSync(abs) && fs.statSync(abs).isDirectory()) {
            for (const file of extensions.map((e) => 'index' + e)) {
                const indexPath = path.join(abs, file);
                if (fs.existsSync(indexPath) && fs.statSync(indexPath).isFile()) {
                    return indexPath;
                }
            }
        }
        return null;
    }
    function visit(filePath) {
        const absPath = path.resolve(filePath);
        if (visited.has(absPath))
            return;
        visited.add(absPath);
        const resolved = resolveAsFileOrDirectory(absPath);
        if (!resolved)
            return;
        const source = fs.readFileSync(resolved, 'utf8');
        const sourceFile = ts.createSourceFile(resolved, source, ts.ScriptTarget.Latest, true);
        function walk(node) {
            if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
                const moduleSpecifier = node.moduleSpecifier;
                if (moduleSpecifier && ts.isStringLiteral(moduleSpecifier)) {
                    const spec = moduleSpecifier.text;
                    if (isExternal(spec)) {
                        externals.add(normalizeExternal(spec));
                    }
                    else {
                        const resolvedPath = resolveAsFileOrDirectory(path.resolve(path.dirname(resolved !== null && resolved !== void 0 ? resolved : ''), spec));
                        if (resolvedPath)
                            visit(resolvedPath);
                    }
                }
            }
            if (ts.isCallExpression(node) &&
                ts.isIdentifier(node.expression) &&
                node.expression.kind === ts.SyntaxKind.Identifier &&
                node.expression.escapedText === 'require' &&
                node.arguments.length === 1 &&
                ts.isStringLiteral(node.arguments[0])) {
                const spec = node.arguments[0].text;
                if (isExternal(spec)) {
                    externals.add(normalizeExternal(spec));
                }
                else {
                    const resolvedPath = resolveAsFileOrDirectory(path.resolve(path.dirname(resolved !== null && resolved !== void 0 ? resolved : ''), spec));
                    if (resolvedPath)
                        visit(resolvedPath);
                }
            }
            ts.forEachChild(node, walk);
        }
        ts.forEachChild(sourceFile, walk);
    }
    visit(entryFilePath);
    return Array.from(externals);
}
//# sourceMappingURL=get-external-imports.js.map