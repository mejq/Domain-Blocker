"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INTERNAL_SCOPE = void 0;
exports.rewriteChunkImports = rewriteChunkImports;
exports.isSourceFile = isSourceFile;
exports.deriveInternalName = deriveInternalName;
const tslib_1 = require("tslib");
const ts = tslib_1.__importStar(require("typescript"));
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
exports.INTERNAL_SCOPE = '@nf-internal';
function rewriteChunkImports(filePath) {
    const sourceCode = fs.readFileSync(filePath, 'utf-8');
    const sourceFile = ts.createSourceFile(path.basename(filePath), sourceCode, ts.ScriptTarget.ESNext, true, ts.ScriptKind.JS);
    const printer = ts.createPrinter();
    function visit(node) {
        // import ... from '...'
        if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
            const moduleSpecifier = node.moduleSpecifier;
            if (moduleSpecifier && ts.isStringLiteral(moduleSpecifier)) {
                const text = moduleSpecifier.text;
                if (text.startsWith('./')) {
                    const newModuleSpecifier = ts.factory.createStringLiteral(deriveInternalName(text));
                    if (ts.isImportDeclaration(node)) {
                        return ts.factory.updateImportDeclaration(node, node.modifiers, node.importClause, newModuleSpecifier, node.assertClause);
                    }
                    else {
                        return ts.factory.updateExportDeclaration(node, node.modifiers, node.isTypeOnly, node.exportClause, newModuleSpecifier, node.assertClause);
                    }
                }
            }
        }
        // import('./...')
        if (ts.isCallExpression(node) &&
            node.expression.kind === ts.SyntaxKind.ImportKeyword) {
            const [arg] = node.arguments;
            if (arg && ts.isStringLiteral(arg)) {
                const text = arg.text;
                if (text.startsWith('./')) {
                    const newArg = ts.factory.createStringLiteral(deriveInternalName(text));
                    return ts.factory.updateCallExpression(node, node.expression, node.typeArguments, [newArg]);
                }
            }
        }
        return ts.visitEachChild(node, visit, undefined);
    }
    const transformed = ts.transform(sourceFile, [
        (context) => (node) => ts.visitNode(node, visit),
    ]);
    const updatedSourceFile = transformed.transformed[0];
    const result = printer.printFile(updatedSourceFile);
    fs.writeFileSync(filePath, result, 'utf-8');
}
function isSourceFile(fileName) {
    return !!fileName.match(/.(m|c)?js$/);
}
function deriveInternalName(fileName) {
    if (fileName.startsWith('./')) {
        fileName = fileName.slice(2);
    }
    const packageName = fileName.replace(/.(m|c)?js$/, '');
    return exports.INTERNAL_SCOPE + '/' + packageName;
}
//# sourceMappingURL=rewrite-chunk-imports.js.map