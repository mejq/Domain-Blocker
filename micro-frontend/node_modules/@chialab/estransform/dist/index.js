var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/sucrase/dist/parser/tokenizer/types.js
var require_types = __commonJS({
  "../../node_modules/sucrase/dist/parser/tokenizer/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TokenType2;
    (function(TokenType3) {
      const PRECEDENCE_MASK = 15;
      TokenType3[TokenType3["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
      const IS_KEYWORD = 1 << 4;
      TokenType3[TokenType3["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
      const IS_ASSIGN = 1 << 5;
      TokenType3[TokenType3["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
      const IS_RIGHT_ASSOCIATIVE = 1 << 6;
      TokenType3[TokenType3["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
      const IS_PREFIX = 1 << 7;
      TokenType3[TokenType3["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
      const IS_POSTFIX = 1 << 8;
      TokenType3[TokenType3["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
      const IS_EXPRESSION_START = 1 << 9;
      TokenType3[TokenType3["IS_EXPRESSION_START"] = IS_EXPRESSION_START] = "IS_EXPRESSION_START";
      const num = 512;
      TokenType3[TokenType3["num"] = num] = "num";
      const bigint = 1536;
      TokenType3[TokenType3["bigint"] = bigint] = "bigint";
      const decimal = 2560;
      TokenType3[TokenType3["decimal"] = decimal] = "decimal";
      const regexp = 3584;
      TokenType3[TokenType3["regexp"] = regexp] = "regexp";
      const string = 4608;
      TokenType3[TokenType3["string"] = string] = "string";
      const name = 5632;
      TokenType3[TokenType3["name"] = name] = "name";
      const eof = 6144;
      TokenType3[TokenType3["eof"] = eof] = "eof";
      const bracketL = 7680;
      TokenType3[TokenType3["bracketL"] = bracketL] = "bracketL";
      const bracketR = 8192;
      TokenType3[TokenType3["bracketR"] = bracketR] = "bracketR";
      const braceL = 9728;
      TokenType3[TokenType3["braceL"] = braceL] = "braceL";
      const braceBarL = 10752;
      TokenType3[TokenType3["braceBarL"] = braceBarL] = "braceBarL";
      const braceR = 11264;
      TokenType3[TokenType3["braceR"] = braceR] = "braceR";
      const braceBarR = 12288;
      TokenType3[TokenType3["braceBarR"] = braceBarR] = "braceBarR";
      const parenL = 13824;
      TokenType3[TokenType3["parenL"] = parenL] = "parenL";
      const parenR = 14336;
      TokenType3[TokenType3["parenR"] = parenR] = "parenR";
      const comma2 = 15360;
      TokenType3[TokenType3["comma"] = comma2] = "comma";
      const semi = 16384;
      TokenType3[TokenType3["semi"] = semi] = "semi";
      const colon = 17408;
      TokenType3[TokenType3["colon"] = colon] = "colon";
      const doubleColon = 18432;
      TokenType3[TokenType3["doubleColon"] = doubleColon] = "doubleColon";
      const dot = 19456;
      TokenType3[TokenType3["dot"] = dot] = "dot";
      const question = 20480;
      TokenType3[TokenType3["question"] = question] = "question";
      const questionDot = 21504;
      TokenType3[TokenType3["questionDot"] = questionDot] = "questionDot";
      const arrow = 22528;
      TokenType3[TokenType3["arrow"] = arrow] = "arrow";
      const template = 23552;
      TokenType3[TokenType3["template"] = template] = "template";
      const ellipsis = 24576;
      TokenType3[TokenType3["ellipsis"] = ellipsis] = "ellipsis";
      const backQuote = 25600;
      TokenType3[TokenType3["backQuote"] = backQuote] = "backQuote";
      const dollarBraceL = 27136;
      TokenType3[TokenType3["dollarBraceL"] = dollarBraceL] = "dollarBraceL";
      const at = 27648;
      TokenType3[TokenType3["at"] = at] = "at";
      const hash = 29184;
      TokenType3[TokenType3["hash"] = hash] = "hash";
      const eq = 29728;
      TokenType3[TokenType3["eq"] = eq] = "eq";
      const assign = 30752;
      TokenType3[TokenType3["assign"] = assign] = "assign";
      const preIncDec = 32640;
      TokenType3[TokenType3["preIncDec"] = preIncDec] = "preIncDec";
      const postIncDec = 33664;
      TokenType3[TokenType3["postIncDec"] = postIncDec] = "postIncDec";
      const bang = 34432;
      TokenType3[TokenType3["bang"] = bang] = "bang";
      const tilde = 35456;
      TokenType3[TokenType3["tilde"] = tilde] = "tilde";
      const pipeline = 35841;
      TokenType3[TokenType3["pipeline"] = pipeline] = "pipeline";
      const nullishCoalescing = 36866;
      TokenType3[TokenType3["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing";
      const logicalOR = 37890;
      TokenType3[TokenType3["logicalOR"] = logicalOR] = "logicalOR";
      const logicalAND = 38915;
      TokenType3[TokenType3["logicalAND"] = logicalAND] = "logicalAND";
      const bitwiseOR = 39940;
      TokenType3[TokenType3["bitwiseOR"] = bitwiseOR] = "bitwiseOR";
      const bitwiseXOR = 40965;
      TokenType3[TokenType3["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR";
      const bitwiseAND = 41990;
      TokenType3[TokenType3["bitwiseAND"] = bitwiseAND] = "bitwiseAND";
      const equality = 43015;
      TokenType3[TokenType3["equality"] = equality] = "equality";
      const lessThan = 44040;
      TokenType3[TokenType3["lessThan"] = lessThan] = "lessThan";
      const greaterThan = 45064;
      TokenType3[TokenType3["greaterThan"] = greaterThan] = "greaterThan";
      const relationalOrEqual = 46088;
      TokenType3[TokenType3["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual";
      const bitShiftL = 47113;
      TokenType3[TokenType3["bitShiftL"] = bitShiftL] = "bitShiftL";
      const bitShiftR = 48137;
      TokenType3[TokenType3["bitShiftR"] = bitShiftR] = "bitShiftR";
      const plus = 49802;
      TokenType3[TokenType3["plus"] = plus] = "plus";
      const minus = 50826;
      TokenType3[TokenType3["minus"] = minus] = "minus";
      const modulo = 51723;
      TokenType3[TokenType3["modulo"] = modulo] = "modulo";
      const star = 52235;
      TokenType3[TokenType3["star"] = star] = "star";
      const slash = 53259;
      TokenType3[TokenType3["slash"] = slash] = "slash";
      const exponent = 54348;
      TokenType3[TokenType3["exponent"] = exponent] = "exponent";
      const jsxName = 55296;
      TokenType3[TokenType3["jsxName"] = jsxName] = "jsxName";
      const jsxText = 56320;
      TokenType3[TokenType3["jsxText"] = jsxText] = "jsxText";
      const jsxEmptyText = 57344;
      TokenType3[TokenType3["jsxEmptyText"] = jsxEmptyText] = "jsxEmptyText";
      const jsxTagStart = 58880;
      TokenType3[TokenType3["jsxTagStart"] = jsxTagStart] = "jsxTagStart";
      const jsxTagEnd = 59392;
      TokenType3[TokenType3["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd";
      const typeParameterStart = 60928;
      TokenType3[TokenType3["typeParameterStart"] = typeParameterStart] = "typeParameterStart";
      const nonNullAssertion = 61440;
      TokenType3[TokenType3["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion";
      const _break = 62480;
      TokenType3[TokenType3["_break"] = _break] = "_break";
      const _case = 63504;
      TokenType3[TokenType3["_case"] = _case] = "_case";
      const _catch = 64528;
      TokenType3[TokenType3["_catch"] = _catch] = "_catch";
      const _continue = 65552;
      TokenType3[TokenType3["_continue"] = _continue] = "_continue";
      const _debugger = 66576;
      TokenType3[TokenType3["_debugger"] = _debugger] = "_debugger";
      const _default = 67600;
      TokenType3[TokenType3["_default"] = _default] = "_default";
      const _do = 68624;
      TokenType3[TokenType3["_do"] = _do] = "_do";
      const _else = 69648;
      TokenType3[TokenType3["_else"] = _else] = "_else";
      const _finally = 70672;
      TokenType3[TokenType3["_finally"] = _finally] = "_finally";
      const _for = 71696;
      TokenType3[TokenType3["_for"] = _for] = "_for";
      const _function = 73232;
      TokenType3[TokenType3["_function"] = _function] = "_function";
      const _if = 73744;
      TokenType3[TokenType3["_if"] = _if] = "_if";
      const _return = 74768;
      TokenType3[TokenType3["_return"] = _return] = "_return";
      const _switch = 75792;
      TokenType3[TokenType3["_switch"] = _switch] = "_switch";
      const _throw = 77456;
      TokenType3[TokenType3["_throw"] = _throw] = "_throw";
      const _try = 77840;
      TokenType3[TokenType3["_try"] = _try] = "_try";
      const _var = 78864;
      TokenType3[TokenType3["_var"] = _var] = "_var";
      const _let = 79888;
      TokenType3[TokenType3["_let"] = _let] = "_let";
      const _const = 80912;
      TokenType3[TokenType3["_const"] = _const] = "_const";
      const _while = 81936;
      TokenType3[TokenType3["_while"] = _while] = "_while";
      const _with = 82960;
      TokenType3[TokenType3["_with"] = _with] = "_with";
      const _new = 84496;
      TokenType3[TokenType3["_new"] = _new] = "_new";
      const _this = 85520;
      TokenType3[TokenType3["_this"] = _this] = "_this";
      const _super = 86544;
      TokenType3[TokenType3["_super"] = _super] = "_super";
      const _class = 87568;
      TokenType3[TokenType3["_class"] = _class] = "_class";
      const _extends = 88080;
      TokenType3[TokenType3["_extends"] = _extends] = "_extends";
      const _export = 89104;
      TokenType3[TokenType3["_export"] = _export] = "_export";
      const _import = 90640;
      TokenType3[TokenType3["_import"] = _import] = "_import";
      const _yield = 91664;
      TokenType3[TokenType3["_yield"] = _yield] = "_yield";
      const _null = 92688;
      TokenType3[TokenType3["_null"] = _null] = "_null";
      const _true = 93712;
      TokenType3[TokenType3["_true"] = _true] = "_true";
      const _false = 94736;
      TokenType3[TokenType3["_false"] = _false] = "_false";
      const _in = 95256;
      TokenType3[TokenType3["_in"] = _in] = "_in";
      const _instanceof = 96280;
      TokenType3[TokenType3["_instanceof"] = _instanceof] = "_instanceof";
      const _typeof = 97936;
      TokenType3[TokenType3["_typeof"] = _typeof] = "_typeof";
      const _void = 98960;
      TokenType3[TokenType3["_void"] = _void] = "_void";
      const _delete = 99984;
      TokenType3[TokenType3["_delete"] = _delete] = "_delete";
      const _async = 100880;
      TokenType3[TokenType3["_async"] = _async] = "_async";
      const _get = 101904;
      TokenType3[TokenType3["_get"] = _get] = "_get";
      const _set = 102928;
      TokenType3[TokenType3["_set"] = _set] = "_set";
      const _declare = 103952;
      TokenType3[TokenType3["_declare"] = _declare] = "_declare";
      const _readonly = 104976;
      TokenType3[TokenType3["_readonly"] = _readonly] = "_readonly";
      const _abstract = 106e3;
      TokenType3[TokenType3["_abstract"] = _abstract] = "_abstract";
      const _static = 107024;
      TokenType3[TokenType3["_static"] = _static] = "_static";
      const _public = 107536;
      TokenType3[TokenType3["_public"] = _public] = "_public";
      const _private = 108560;
      TokenType3[TokenType3["_private"] = _private] = "_private";
      const _protected = 109584;
      TokenType3[TokenType3["_protected"] = _protected] = "_protected";
      const _override = 110608;
      TokenType3[TokenType3["_override"] = _override] = "_override";
      const _as = 112144;
      TokenType3[TokenType3["_as"] = _as] = "_as";
      const _enum = 113168;
      TokenType3[TokenType3["_enum"] = _enum] = "_enum";
      const _type = 114192;
      TokenType3[TokenType3["_type"] = _type] = "_type";
      const _implements = 115216;
      TokenType3[TokenType3["_implements"] = _implements] = "_implements";
    })(TokenType2 || (exports.TokenType = TokenType2 = {}));
    function formatTokenType(tokenType) {
      switch (tokenType) {
        case TokenType2.num:
          return "num";
        case TokenType2.bigint:
          return "bigint";
        case TokenType2.decimal:
          return "decimal";
        case TokenType2.regexp:
          return "regexp";
        case TokenType2.string:
          return "string";
        case TokenType2.name:
          return "name";
        case TokenType2.eof:
          return "eof";
        case TokenType2.bracketL:
          return "[";
        case TokenType2.bracketR:
          return "]";
        case TokenType2.braceL:
          return "{";
        case TokenType2.braceBarL:
          return "{|";
        case TokenType2.braceR:
          return "}";
        case TokenType2.braceBarR:
          return "|}";
        case TokenType2.parenL:
          return "(";
        case TokenType2.parenR:
          return ")";
        case TokenType2.comma:
          return ",";
        case TokenType2.semi:
          return ";";
        case TokenType2.colon:
          return ":";
        case TokenType2.doubleColon:
          return "::";
        case TokenType2.dot:
          return ".";
        case TokenType2.question:
          return "?";
        case TokenType2.questionDot:
          return "?.";
        case TokenType2.arrow:
          return "=>";
        case TokenType2.template:
          return "template";
        case TokenType2.ellipsis:
          return "...";
        case TokenType2.backQuote:
          return "`";
        case TokenType2.dollarBraceL:
          return "${";
        case TokenType2.at:
          return "@";
        case TokenType2.hash:
          return "#";
        case TokenType2.eq:
          return "=";
        case TokenType2.assign:
          return "_=";
        case TokenType2.preIncDec:
          return "++/--";
        case TokenType2.postIncDec:
          return "++/--";
        case TokenType2.bang:
          return "!";
        case TokenType2.tilde:
          return "~";
        case TokenType2.pipeline:
          return "|>";
        case TokenType2.nullishCoalescing:
          return "??";
        case TokenType2.logicalOR:
          return "||";
        case TokenType2.logicalAND:
          return "&&";
        case TokenType2.bitwiseOR:
          return "|";
        case TokenType2.bitwiseXOR:
          return "^";
        case TokenType2.bitwiseAND:
          return "&";
        case TokenType2.equality:
          return "==/!=";
        case TokenType2.lessThan:
          return "<";
        case TokenType2.greaterThan:
          return ">";
        case TokenType2.relationalOrEqual:
          return "<=/>=";
        case TokenType2.bitShiftL:
          return "<<";
        case TokenType2.bitShiftR:
          return ">>/>>>";
        case TokenType2.plus:
          return "+";
        case TokenType2.minus:
          return "-";
        case TokenType2.modulo:
          return "%";
        case TokenType2.star:
          return "*";
        case TokenType2.slash:
          return "/";
        case TokenType2.exponent:
          return "**";
        case TokenType2.jsxName:
          return "jsxName";
        case TokenType2.jsxText:
          return "jsxText";
        case TokenType2.jsxEmptyText:
          return "jsxEmptyText";
        case TokenType2.jsxTagStart:
          return "jsxTagStart";
        case TokenType2.jsxTagEnd:
          return "jsxTagEnd";
        case TokenType2.typeParameterStart:
          return "typeParameterStart";
        case TokenType2.nonNullAssertion:
          return "nonNullAssertion";
        case TokenType2._break:
          return "break";
        case TokenType2._case:
          return "case";
        case TokenType2._catch:
          return "catch";
        case TokenType2._continue:
          return "continue";
        case TokenType2._debugger:
          return "debugger";
        case TokenType2._default:
          return "default";
        case TokenType2._do:
          return "do";
        case TokenType2._else:
          return "else";
        case TokenType2._finally:
          return "finally";
        case TokenType2._for:
          return "for";
        case TokenType2._function:
          return "function";
        case TokenType2._if:
          return "if";
        case TokenType2._return:
          return "return";
        case TokenType2._switch:
          return "switch";
        case TokenType2._throw:
          return "throw";
        case TokenType2._try:
          return "try";
        case TokenType2._var:
          return "var";
        case TokenType2._let:
          return "let";
        case TokenType2._const:
          return "const";
        case TokenType2._while:
          return "while";
        case TokenType2._with:
          return "with";
        case TokenType2._new:
          return "new";
        case TokenType2._this:
          return "this";
        case TokenType2._super:
          return "super";
        case TokenType2._class:
          return "class";
        case TokenType2._extends:
          return "extends";
        case TokenType2._export:
          return "export";
        case TokenType2._import:
          return "import";
        case TokenType2._yield:
          return "yield";
        case TokenType2._null:
          return "null";
        case TokenType2._true:
          return "true";
        case TokenType2._false:
          return "false";
        case TokenType2._in:
          return "in";
        case TokenType2._instanceof:
          return "instanceof";
        case TokenType2._typeof:
          return "typeof";
        case TokenType2._void:
          return "void";
        case TokenType2._delete:
          return "delete";
        case TokenType2._async:
          return "async";
        case TokenType2._get:
          return "get";
        case TokenType2._set:
          return "set";
        case TokenType2._declare:
          return "declare";
        case TokenType2._readonly:
          return "readonly";
        case TokenType2._abstract:
          return "abstract";
        case TokenType2._static:
          return "static";
        case TokenType2._public:
          return "public";
        case TokenType2._private:
          return "private";
        case TokenType2._protected:
          return "protected";
        case TokenType2._override:
          return "override";
        case TokenType2._as:
          return "as";
        case TokenType2._enum:
          return "enum";
        case TokenType2._type:
          return "type";
        case TokenType2._implements:
          return "implements";
        default:
          return "";
      }
    }
    exports.formatTokenType = formatTokenType;
  }
});

// ../../node_modules/sucrase/dist/HelperManager.js
var require_HelperManager = __commonJS({
  "../../node_modules/sucrase/dist/HelperManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HELPERS = {
      require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
      interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
      interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
      createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
      // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
      // check in the exports object and does a plain assignment, whereas Babel uses
      // defineProperty and builds an object of explicitly-exported names so that star exports can
      // always take lower precedence. For now, we do the easier TypeScript thing.
      createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
      nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
      asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
      optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
      asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
      optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
      asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
    };
    var HelperManager2 = class _HelperManager {
      __init() {
        this.helperNames = {};
      }
      __init2() {
        this.createRequireName = null;
      }
      constructor(nameManager) {
        ;
        this.nameManager = nameManager;
        _HelperManager.prototype.__init.call(this);
        _HelperManager.prototype.__init2.call(this);
      }
      getHelperName(baseName) {
        let helperName = this.helperNames[baseName];
        if (helperName) {
          return helperName;
        }
        helperName = this.nameManager.claimFreeName(`_${baseName}`);
        this.helperNames[baseName] = helperName;
        return helperName;
      }
      emitHelpers() {
        let resultCode = "";
        if (this.helperNames.optionalChainDelete) {
          this.getHelperName("optionalChain");
        }
        if (this.helperNames.asyncOptionalChainDelete) {
          this.getHelperName("asyncOptionalChain");
        }
        for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {
          const helperName = this.helperNames[baseName];
          let helperCode = helperCodeTemplate;
          if (baseName === "optionalChainDelete") {
            helperCode = helperCode.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain);
          } else if (baseName === "asyncOptionalChainDelete") {
            helperCode = helperCode.replace(
              "ASYNC_OPTIONAL_CHAIN_NAME",
              this.helperNames.asyncOptionalChain
            );
          } else if (baseName === "require") {
            if (this.createRequireName === null) {
              this.createRequireName = this.nameManager.claimFreeName("_createRequire");
            }
            helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);
          }
          if (helperName) {
            resultCode += " ";
            resultCode += helperCode.replace(baseName, helperName).replace(/\s+/g, " ").trim();
          }
        }
        return resultCode;
      }
    };
    exports.HelperManager = HelperManager2;
  }
});

// ../../node_modules/sucrase/dist/util/getIdentifierNames.js
var require_getIdentifierNames = __commonJS({
  "../../node_modules/sucrase/dist/util/getIdentifierNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _types = require_types();
    function getIdentifierNames(code, tokens) {
      const names = [];
      for (const token of tokens) {
        if (token.type === _types.TokenType.name) {
          names.push(code.slice(token.start, token.end));
        }
      }
      return names;
    }
    exports.default = getIdentifierNames;
  }
});

// ../../node_modules/sucrase/dist/NameManager.js
var require_NameManager = __commonJS({
  "../../node_modules/sucrase/dist/NameManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _getIdentifierNames = require_getIdentifierNames();
    var _getIdentifierNames2 = _interopRequireDefault(_getIdentifierNames);
    var NameManager2 = class _NameManager {
      __init() {
        this.usedNames = /* @__PURE__ */ new Set();
      }
      constructor(code, tokens) {
        ;
        _NameManager.prototype.__init.call(this);
        this.usedNames = new Set(_getIdentifierNames2.default.call(void 0, code, tokens));
      }
      claimFreeName(name) {
        const newName = this.findFreeName(name);
        this.usedNames.add(newName);
        return newName;
      }
      findFreeName(name) {
        if (!this.usedNames.has(name)) {
          return name;
        }
        let suffixNum = 2;
        while (this.usedNames.has(name + String(suffixNum))) {
          suffixNum++;
        }
        return name + String(suffixNum);
      }
    };
    exports.default = NameManager2;
  }
});

// ../../node_modules/sucrase/dist/parser/tokenizer/keywords.js
var require_keywords = __commonJS({
  "../../node_modules/sucrase/dist/parser/tokenizer/keywords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ContextualKeyword;
    (function(ContextualKeyword2) {
      const NONE = 0;
      ContextualKeyword2[ContextualKeyword2["NONE"] = NONE] = "NONE";
      const _abstract = NONE + 1;
      ContextualKeyword2[ContextualKeyword2["_abstract"] = _abstract] = "_abstract";
      const _accessor = _abstract + 1;
      ContextualKeyword2[ContextualKeyword2["_accessor"] = _accessor] = "_accessor";
      const _as = _accessor + 1;
      ContextualKeyword2[ContextualKeyword2["_as"] = _as] = "_as";
      const _assert = _as + 1;
      ContextualKeyword2[ContextualKeyword2["_assert"] = _assert] = "_assert";
      const _asserts = _assert + 1;
      ContextualKeyword2[ContextualKeyword2["_asserts"] = _asserts] = "_asserts";
      const _async = _asserts + 1;
      ContextualKeyword2[ContextualKeyword2["_async"] = _async] = "_async";
      const _await = _async + 1;
      ContextualKeyword2[ContextualKeyword2["_await"] = _await] = "_await";
      const _checks = _await + 1;
      ContextualKeyword2[ContextualKeyword2["_checks"] = _checks] = "_checks";
      const _constructor = _checks + 1;
      ContextualKeyword2[ContextualKeyword2["_constructor"] = _constructor] = "_constructor";
      const _declare = _constructor + 1;
      ContextualKeyword2[ContextualKeyword2["_declare"] = _declare] = "_declare";
      const _enum = _declare + 1;
      ContextualKeyword2[ContextualKeyword2["_enum"] = _enum] = "_enum";
      const _exports = _enum + 1;
      ContextualKeyword2[ContextualKeyword2["_exports"] = _exports] = "_exports";
      const _from = _exports + 1;
      ContextualKeyword2[ContextualKeyword2["_from"] = _from] = "_from";
      const _get = _from + 1;
      ContextualKeyword2[ContextualKeyword2["_get"] = _get] = "_get";
      const _global = _get + 1;
      ContextualKeyword2[ContextualKeyword2["_global"] = _global] = "_global";
      const _implements = _global + 1;
      ContextualKeyword2[ContextualKeyword2["_implements"] = _implements] = "_implements";
      const _infer = _implements + 1;
      ContextualKeyword2[ContextualKeyword2["_infer"] = _infer] = "_infer";
      const _interface = _infer + 1;
      ContextualKeyword2[ContextualKeyword2["_interface"] = _interface] = "_interface";
      const _is = _interface + 1;
      ContextualKeyword2[ContextualKeyword2["_is"] = _is] = "_is";
      const _keyof = _is + 1;
      ContextualKeyword2[ContextualKeyword2["_keyof"] = _keyof] = "_keyof";
      const _mixins = _keyof + 1;
      ContextualKeyword2[ContextualKeyword2["_mixins"] = _mixins] = "_mixins";
      const _module = _mixins + 1;
      ContextualKeyword2[ContextualKeyword2["_module"] = _module] = "_module";
      const _namespace = _module + 1;
      ContextualKeyword2[ContextualKeyword2["_namespace"] = _namespace] = "_namespace";
      const _of = _namespace + 1;
      ContextualKeyword2[ContextualKeyword2["_of"] = _of] = "_of";
      const _opaque = _of + 1;
      ContextualKeyword2[ContextualKeyword2["_opaque"] = _opaque] = "_opaque";
      const _out = _opaque + 1;
      ContextualKeyword2[ContextualKeyword2["_out"] = _out] = "_out";
      const _override = _out + 1;
      ContextualKeyword2[ContextualKeyword2["_override"] = _override] = "_override";
      const _private = _override + 1;
      ContextualKeyword2[ContextualKeyword2["_private"] = _private] = "_private";
      const _protected = _private + 1;
      ContextualKeyword2[ContextualKeyword2["_protected"] = _protected] = "_protected";
      const _proto = _protected + 1;
      ContextualKeyword2[ContextualKeyword2["_proto"] = _proto] = "_proto";
      const _public = _proto + 1;
      ContextualKeyword2[ContextualKeyword2["_public"] = _public] = "_public";
      const _readonly = _public + 1;
      ContextualKeyword2[ContextualKeyword2["_readonly"] = _readonly] = "_readonly";
      const _require = _readonly + 1;
      ContextualKeyword2[ContextualKeyword2["_require"] = _require] = "_require";
      const _satisfies = _require + 1;
      ContextualKeyword2[ContextualKeyword2["_satisfies"] = _satisfies] = "_satisfies";
      const _set = _satisfies + 1;
      ContextualKeyword2[ContextualKeyword2["_set"] = _set] = "_set";
      const _static = _set + 1;
      ContextualKeyword2[ContextualKeyword2["_static"] = _static] = "_static";
      const _symbol = _static + 1;
      ContextualKeyword2[ContextualKeyword2["_symbol"] = _symbol] = "_symbol";
      const _type = _symbol + 1;
      ContextualKeyword2[ContextualKeyword2["_type"] = _type] = "_type";
      const _unique = _type + 1;
      ContextualKeyword2[ContextualKeyword2["_unique"] = _unique] = "_unique";
      const _using = _unique + 1;
      ContextualKeyword2[ContextualKeyword2["_using"] = _using] = "_using";
    })(ContextualKeyword || (exports.ContextualKeyword = ContextualKeyword = {}));
  }
});

// ../../node_modules/sucrase/dist/parser/tokenizer/state.js
var require_state = __commonJS({
  "../../node_modules/sucrase/dist/parser/tokenizer/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _keywords = require_keywords();
    var _types = require_types();
    var Scope = class {
      constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
        this.startTokenIndex = startTokenIndex;
        this.endTokenIndex = endTokenIndex;
        this.isFunctionScope = isFunctionScope;
      }
    };
    exports.Scope = Scope;
    var StateSnapshot = class {
      constructor(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error) {
        ;
        this.potentialArrowAt = potentialArrowAt;
        this.noAnonFunctionType = noAnonFunctionType;
        this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;
        this.tokensLength = tokensLength;
        this.scopesLength = scopesLength;
        this.pos = pos;
        this.type = type;
        this.contextualKeyword = contextualKeyword;
        this.start = start;
        this.end = end;
        this.isType = isType;
        this.scopeDepth = scopeDepth;
        this.error = error;
      }
    };
    exports.StateSnapshot = StateSnapshot;
    var State = class _State {
      constructor() {
        _State.prototype.__init.call(this);
        _State.prototype.__init2.call(this);
        _State.prototype.__init3.call(this);
        _State.prototype.__init4.call(this);
        _State.prototype.__init5.call(this);
        _State.prototype.__init6.call(this);
        _State.prototype.__init7.call(this);
        _State.prototype.__init8.call(this);
        _State.prototype.__init9.call(this);
        _State.prototype.__init10.call(this);
        _State.prototype.__init11.call(this);
        _State.prototype.__init12.call(this);
        _State.prototype.__init13.call(this);
      }
      // Used to signify the start of a potential arrow function
      __init() {
        this.potentialArrowAt = -1;
      }
      // Used by Flow to handle an edge case involving function type parsing.
      __init2() {
        this.noAnonFunctionType = false;
      }
      // Used by TypeScript to handle ambiguities when parsing conditional types.
      __init3() {
        this.inDisallowConditionalTypesContext = false;
      }
      // Token store.
      __init4() {
        this.tokens = [];
      }
      // Array of all observed scopes, ordered by their ending position.
      __init5() {
        this.scopes = [];
      }
      // The current position of the tokenizer in the input.
      __init6() {
        this.pos = 0;
      }
      // Information about the current token.
      __init7() {
        this.type = _types.TokenType.eof;
      }
      __init8() {
        this.contextualKeyword = _keywords.ContextualKeyword.NONE;
      }
      __init9() {
        this.start = 0;
      }
      __init10() {
        this.end = 0;
      }
      __init11() {
        this.isType = false;
      }
      __init12() {
        this.scopeDepth = 0;
      }
      /**
       * If the parser is in an error state, then the token is always tt.eof and all functions can
       * keep executing but should be written so they don't get into an infinite loop in this situation.
       *
       * This approach, combined with the ability to snapshot and restore state, allows us to implement
       * backtracking without exceptions and without needing to explicitly propagate error states
       * everywhere.
       */
      __init13() {
        this.error = null;
      }
      snapshot() {
        return new StateSnapshot(
          this.potentialArrowAt,
          this.noAnonFunctionType,
          this.inDisallowConditionalTypesContext,
          this.tokens.length,
          this.scopes.length,
          this.pos,
          this.type,
          this.contextualKeyword,
          this.start,
          this.end,
          this.isType,
          this.scopeDepth,
          this.error
        );
      }
      restoreFromSnapshot(snapshot) {
        this.potentialArrowAt = snapshot.potentialArrowAt;
        this.noAnonFunctionType = snapshot.noAnonFunctionType;
        this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;
        this.tokens.length = snapshot.tokensLength;
        this.scopes.length = snapshot.scopesLength;
        this.pos = snapshot.pos;
        this.type = snapshot.type;
        this.contextualKeyword = snapshot.contextualKeyword;
        this.start = snapshot.start;
        this.end = snapshot.end;
        this.isType = snapshot.isType;
        this.scopeDepth = snapshot.scopeDepth;
        this.error = snapshot.error;
      }
    };
    exports.default = State;
  }
});

// ../../node_modules/sucrase/dist/parser/util/charcodes.js
var require_charcodes = __commonJS({
  "../../node_modules/sucrase/dist/parser/util/charcodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var charCodes;
    (function(charCodes2) {
      const backSpace = 8;
      charCodes2[charCodes2["backSpace"] = backSpace] = "backSpace";
      const lineFeed = 10;
      charCodes2[charCodes2["lineFeed"] = lineFeed] = "lineFeed";
      const tab = 9;
      charCodes2[charCodes2["tab"] = tab] = "tab";
      const carriageReturn = 13;
      charCodes2[charCodes2["carriageReturn"] = carriageReturn] = "carriageReturn";
      const shiftOut = 14;
      charCodes2[charCodes2["shiftOut"] = shiftOut] = "shiftOut";
      const space = 32;
      charCodes2[charCodes2["space"] = space] = "space";
      const exclamationMark = 33;
      charCodes2[charCodes2["exclamationMark"] = exclamationMark] = "exclamationMark";
      const quotationMark = 34;
      charCodes2[charCodes2["quotationMark"] = quotationMark] = "quotationMark";
      const numberSign = 35;
      charCodes2[charCodes2["numberSign"] = numberSign] = "numberSign";
      const dollarSign = 36;
      charCodes2[charCodes2["dollarSign"] = dollarSign] = "dollarSign";
      const percentSign = 37;
      charCodes2[charCodes2["percentSign"] = percentSign] = "percentSign";
      const ampersand = 38;
      charCodes2[charCodes2["ampersand"] = ampersand] = "ampersand";
      const apostrophe = 39;
      charCodes2[charCodes2["apostrophe"] = apostrophe] = "apostrophe";
      const leftParenthesis = 40;
      charCodes2[charCodes2["leftParenthesis"] = leftParenthesis] = "leftParenthesis";
      const rightParenthesis = 41;
      charCodes2[charCodes2["rightParenthesis"] = rightParenthesis] = "rightParenthesis";
      const asterisk = 42;
      charCodes2[charCodes2["asterisk"] = asterisk] = "asterisk";
      const plusSign = 43;
      charCodes2[charCodes2["plusSign"] = plusSign] = "plusSign";
      const comma2 = 44;
      charCodes2[charCodes2["comma"] = comma2] = "comma";
      const dash = 45;
      charCodes2[charCodes2["dash"] = dash] = "dash";
      const dot = 46;
      charCodes2[charCodes2["dot"] = dot] = "dot";
      const slash = 47;
      charCodes2[charCodes2["slash"] = slash] = "slash";
      const digit0 = 48;
      charCodes2[charCodes2["digit0"] = digit0] = "digit0";
      const digit1 = 49;
      charCodes2[charCodes2["digit1"] = digit1] = "digit1";
      const digit2 = 50;
      charCodes2[charCodes2["digit2"] = digit2] = "digit2";
      const digit3 = 51;
      charCodes2[charCodes2["digit3"] = digit3] = "digit3";
      const digit4 = 52;
      charCodes2[charCodes2["digit4"] = digit4] = "digit4";
      const digit5 = 53;
      charCodes2[charCodes2["digit5"] = digit5] = "digit5";
      const digit6 = 54;
      charCodes2[charCodes2["digit6"] = digit6] = "digit6";
      const digit7 = 55;
      charCodes2[charCodes2["digit7"] = digit7] = "digit7";
      const digit8 = 56;
      charCodes2[charCodes2["digit8"] = digit8] = "digit8";
      const digit9 = 57;
      charCodes2[charCodes2["digit9"] = digit9] = "digit9";
      const colon = 58;
      charCodes2[charCodes2["colon"] = colon] = "colon";
      const semicolon2 = 59;
      charCodes2[charCodes2["semicolon"] = semicolon2] = "semicolon";
      const lessThan = 60;
      charCodes2[charCodes2["lessThan"] = lessThan] = "lessThan";
      const equalsTo = 61;
      charCodes2[charCodes2["equalsTo"] = equalsTo] = "equalsTo";
      const greaterThan = 62;
      charCodes2[charCodes2["greaterThan"] = greaterThan] = "greaterThan";
      const questionMark = 63;
      charCodes2[charCodes2["questionMark"] = questionMark] = "questionMark";
      const atSign = 64;
      charCodes2[charCodes2["atSign"] = atSign] = "atSign";
      const uppercaseA = 65;
      charCodes2[charCodes2["uppercaseA"] = uppercaseA] = "uppercaseA";
      const uppercaseB = 66;
      charCodes2[charCodes2["uppercaseB"] = uppercaseB] = "uppercaseB";
      const uppercaseC = 67;
      charCodes2[charCodes2["uppercaseC"] = uppercaseC] = "uppercaseC";
      const uppercaseD = 68;
      charCodes2[charCodes2["uppercaseD"] = uppercaseD] = "uppercaseD";
      const uppercaseE = 69;
      charCodes2[charCodes2["uppercaseE"] = uppercaseE] = "uppercaseE";
      const uppercaseF = 70;
      charCodes2[charCodes2["uppercaseF"] = uppercaseF] = "uppercaseF";
      const uppercaseG = 71;
      charCodes2[charCodes2["uppercaseG"] = uppercaseG] = "uppercaseG";
      const uppercaseH = 72;
      charCodes2[charCodes2["uppercaseH"] = uppercaseH] = "uppercaseH";
      const uppercaseI = 73;
      charCodes2[charCodes2["uppercaseI"] = uppercaseI] = "uppercaseI";
      const uppercaseJ = 74;
      charCodes2[charCodes2["uppercaseJ"] = uppercaseJ] = "uppercaseJ";
      const uppercaseK = 75;
      charCodes2[charCodes2["uppercaseK"] = uppercaseK] = "uppercaseK";
      const uppercaseL = 76;
      charCodes2[charCodes2["uppercaseL"] = uppercaseL] = "uppercaseL";
      const uppercaseM = 77;
      charCodes2[charCodes2["uppercaseM"] = uppercaseM] = "uppercaseM";
      const uppercaseN = 78;
      charCodes2[charCodes2["uppercaseN"] = uppercaseN] = "uppercaseN";
      const uppercaseO = 79;
      charCodes2[charCodes2["uppercaseO"] = uppercaseO] = "uppercaseO";
      const uppercaseP = 80;
      charCodes2[charCodes2["uppercaseP"] = uppercaseP] = "uppercaseP";
      const uppercaseQ = 81;
      charCodes2[charCodes2["uppercaseQ"] = uppercaseQ] = "uppercaseQ";
      const uppercaseR = 82;
      charCodes2[charCodes2["uppercaseR"] = uppercaseR] = "uppercaseR";
      const uppercaseS = 83;
      charCodes2[charCodes2["uppercaseS"] = uppercaseS] = "uppercaseS";
      const uppercaseT = 84;
      charCodes2[charCodes2["uppercaseT"] = uppercaseT] = "uppercaseT";
      const uppercaseU = 85;
      charCodes2[charCodes2["uppercaseU"] = uppercaseU] = "uppercaseU";
      const uppercaseV = 86;
      charCodes2[charCodes2["uppercaseV"] = uppercaseV] = "uppercaseV";
      const uppercaseW = 87;
      charCodes2[charCodes2["uppercaseW"] = uppercaseW] = "uppercaseW";
      const uppercaseX = 88;
      charCodes2[charCodes2["uppercaseX"] = uppercaseX] = "uppercaseX";
      const uppercaseY = 89;
      charCodes2[charCodes2["uppercaseY"] = uppercaseY] = "uppercaseY";
      const uppercaseZ = 90;
      charCodes2[charCodes2["uppercaseZ"] = uppercaseZ] = "uppercaseZ";
      const leftSquareBracket = 91;
      charCodes2[charCodes2["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket";
      const backslash = 92;
      charCodes2[charCodes2["backslash"] = backslash] = "backslash";
      const rightSquareBracket = 93;
      charCodes2[charCodes2["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket";
      const caret = 94;
      charCodes2[charCodes2["caret"] = caret] = "caret";
      const underscore = 95;
      charCodes2[charCodes2["underscore"] = underscore] = "underscore";
      const graveAccent = 96;
      charCodes2[charCodes2["graveAccent"] = graveAccent] = "graveAccent";
      const lowercaseA = 97;
      charCodes2[charCodes2["lowercaseA"] = lowercaseA] = "lowercaseA";
      const lowercaseB = 98;
      charCodes2[charCodes2["lowercaseB"] = lowercaseB] = "lowercaseB";
      const lowercaseC = 99;
      charCodes2[charCodes2["lowercaseC"] = lowercaseC] = "lowercaseC";
      const lowercaseD = 100;
      charCodes2[charCodes2["lowercaseD"] = lowercaseD] = "lowercaseD";
      const lowercaseE = 101;
      charCodes2[charCodes2["lowercaseE"] = lowercaseE] = "lowercaseE";
      const lowercaseF = 102;
      charCodes2[charCodes2["lowercaseF"] = lowercaseF] = "lowercaseF";
      const lowercaseG = 103;
      charCodes2[charCodes2["lowercaseG"] = lowercaseG] = "lowercaseG";
      const lowercaseH = 104;
      charCodes2[charCodes2["lowercaseH"] = lowercaseH] = "lowercaseH";
      const lowercaseI = 105;
      charCodes2[charCodes2["lowercaseI"] = lowercaseI] = "lowercaseI";
      const lowercaseJ = 106;
      charCodes2[charCodes2["lowercaseJ"] = lowercaseJ] = "lowercaseJ";
      const lowercaseK = 107;
      charCodes2[charCodes2["lowercaseK"] = lowercaseK] = "lowercaseK";
      const lowercaseL = 108;
      charCodes2[charCodes2["lowercaseL"] = lowercaseL] = "lowercaseL";
      const lowercaseM = 109;
      charCodes2[charCodes2["lowercaseM"] = lowercaseM] = "lowercaseM";
      const lowercaseN = 110;
      charCodes2[charCodes2["lowercaseN"] = lowercaseN] = "lowercaseN";
      const lowercaseO = 111;
      charCodes2[charCodes2["lowercaseO"] = lowercaseO] = "lowercaseO";
      const lowercaseP = 112;
      charCodes2[charCodes2["lowercaseP"] = lowercaseP] = "lowercaseP";
      const lowercaseQ = 113;
      charCodes2[charCodes2["lowercaseQ"] = lowercaseQ] = "lowercaseQ";
      const lowercaseR = 114;
      charCodes2[charCodes2["lowercaseR"] = lowercaseR] = "lowercaseR";
      const lowercaseS = 115;
      charCodes2[charCodes2["lowercaseS"] = lowercaseS] = "lowercaseS";
      const lowercaseT = 116;
      charCodes2[charCodes2["lowercaseT"] = lowercaseT] = "lowercaseT";
      const lowercaseU = 117;
      charCodes2[charCodes2["lowercaseU"] = lowercaseU] = "lowercaseU";
      const lowercaseV = 118;
      charCodes2[charCodes2["lowercaseV"] = lowercaseV] = "lowercaseV";
      const lowercaseW = 119;
      charCodes2[charCodes2["lowercaseW"] = lowercaseW] = "lowercaseW";
      const lowercaseX = 120;
      charCodes2[charCodes2["lowercaseX"] = lowercaseX] = "lowercaseX";
      const lowercaseY = 121;
      charCodes2[charCodes2["lowercaseY"] = lowercaseY] = "lowercaseY";
      const lowercaseZ = 122;
      charCodes2[charCodes2["lowercaseZ"] = lowercaseZ] = "lowercaseZ";
      const leftCurlyBrace = 123;
      charCodes2[charCodes2["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace";
      const verticalBar = 124;
      charCodes2[charCodes2["verticalBar"] = verticalBar] = "verticalBar";
      const rightCurlyBrace = 125;
      charCodes2[charCodes2["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace";
      const tilde = 126;
      charCodes2[charCodes2["tilde"] = tilde] = "tilde";
      const nonBreakingSpace = 160;
      charCodes2[charCodes2["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
      const oghamSpaceMark = 5760;
      charCodes2[charCodes2["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark";
      const lineSeparator = 8232;
      charCodes2[charCodes2["lineSeparator"] = lineSeparator] = "lineSeparator";
      const paragraphSeparator = 8233;
      charCodes2[charCodes2["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
    })(charCodes || (exports.charCodes = charCodes = {}));
    function isDigit(code) {
      return code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF;
    }
    exports.isDigit = isDigit;
  }
});

// ../../node_modules/sucrase/dist/parser/traverser/base.js
var require_base = __commonJS({
  "../../node_modules/sucrase/dist/parser/traverser/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _state = require_state();
    var _state2 = _interopRequireDefault(_state);
    var _charcodes = require_charcodes();
    exports.isJSXEnabled;
    exports.isTypeScriptEnabled;
    exports.isFlowEnabled;
    exports.state;
    exports.input;
    exports.nextContextId;
    function getNextContextId() {
      return exports.nextContextId++;
    }
    exports.getNextContextId = getNextContextId;
    function augmentError(error) {
      if ("pos" in error) {
        const loc = locationForIndex(error.pos);
        error.message += ` (${loc.line}:${loc.column})`;
        error.loc = loc;
      }
      return error;
    }
    exports.augmentError = augmentError;
    var Loc = class {
      constructor(line, column) {
        this.line = line;
        this.column = column;
      }
    };
    exports.Loc = Loc;
    function locationForIndex(pos) {
      let line = 1;
      let column = 1;
      for (let i = 0; i < pos; i++) {
        if (exports.input.charCodeAt(i) === _charcodes.charCodes.lineFeed) {
          line++;
          column = 1;
        } else {
          column++;
        }
      }
      return new Loc(line, column);
    }
    exports.locationForIndex = locationForIndex;
    function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEnabledArg) {
      exports.input = inputCode;
      exports.state = new (0, _state2.default)();
      exports.nextContextId = 1;
      exports.isJSXEnabled = isJSXEnabledArg;
      exports.isTypeScriptEnabled = isTypeScriptEnabledArg;
      exports.isFlowEnabled = isFlowEnabledArg;
    }
    exports.initParser = initParser;
  }
});

// ../../node_modules/sucrase/dist/parser/traverser/util.js
var require_util = __commonJS({
  "../../node_modules/sucrase/dist/parser/traverser/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_tokenizer();
    var _types = require_types();
    var _charcodes = require_charcodes();
    var _base = require_base();
    function isContextual(contextualKeyword) {
      return _base.state.contextualKeyword === contextualKeyword;
    }
    exports.isContextual = isContextual;
    function isLookaheadContextual(contextualKeyword) {
      const l = _index.lookaheadTypeAndKeyword.call(void 0);
      return l.type === _types.TokenType.name && l.contextualKeyword === contextualKeyword;
    }
    exports.isLookaheadContextual = isLookaheadContextual;
    function eatContextual(contextualKeyword) {
      return _base.state.contextualKeyword === contextualKeyword && _index.eat.call(void 0, _types.TokenType.name);
    }
    exports.eatContextual = eatContextual;
    function expectContextual(contextualKeyword) {
      if (!eatContextual(contextualKeyword)) {
        unexpected();
      }
    }
    exports.expectContextual = expectContextual;
    function canInsertSemicolon() {
      return _index.match.call(void 0, _types.TokenType.eof) || _index.match.call(void 0, _types.TokenType.braceR) || hasPrecedingLineBreak();
    }
    exports.canInsertSemicolon = canInsertSemicolon;
    function hasPrecedingLineBreak() {
      const prevToken = _base.state.tokens[_base.state.tokens.length - 1];
      const lastTokEnd = prevToken ? prevToken.end : 0;
      for (let i = lastTokEnd; i < _base.state.start; i++) {
        const code = _base.input.charCodeAt(i);
        if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 8232 || code === 8233) {
          return true;
        }
      }
      return false;
    }
    exports.hasPrecedingLineBreak = hasPrecedingLineBreak;
    function hasFollowingLineBreak() {
      const nextStart = _index.nextTokenStart.call(void 0);
      for (let i = _base.state.end; i < nextStart; i++) {
        const code = _base.input.charCodeAt(i);
        if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 8232 || code === 8233) {
          return true;
        }
      }
      return false;
    }
    exports.hasFollowingLineBreak = hasFollowingLineBreak;
    function isLineTerminator() {
      return _index.eat.call(void 0, _types.TokenType.semi) || canInsertSemicolon();
    }
    exports.isLineTerminator = isLineTerminator;
    function semicolon2() {
      if (!isLineTerminator()) {
        unexpected('Unexpected token, expected ";"');
      }
    }
    exports.semicolon = semicolon2;
    function expect(type) {
      const matched = _index.eat.call(void 0, type);
      if (!matched) {
        unexpected(`Unexpected token, expected "${_types.formatTokenType.call(void 0, type)}"`);
      }
    }
    exports.expect = expect;
    function unexpected(message = "Unexpected token", pos = _base.state.start) {
      if (_base.state.error) {
        return;
      }
      const err = new SyntaxError(message);
      err.pos = pos;
      _base.state.error = err;
      _base.state.pos = _base.input.length;
      _index.finishToken.call(void 0, _types.TokenType.eof);
    }
    exports.unexpected = unexpected;
  }
});

// ../../node_modules/sucrase/dist/parser/util/whitespace.js
var require_whitespace = __commonJS({
  "../../node_modules/sucrase/dist/parser/util/whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _charcodes = require_charcodes();
    var WHITESPACE_CHARS = [
      9,
      11,
      12,
      _charcodes.charCodes.space,
      _charcodes.charCodes.nonBreakingSpace,
      _charcodes.charCodes.oghamSpaceMark,
      8192,
      // EN QUAD
      8193,
      // EM QUAD
      8194,
      // EN SPACE
      8195,
      // EM SPACE
      8196,
      // THREE-PER-EM SPACE
      8197,
      // FOUR-PER-EM SPACE
      8198,
      // SIX-PER-EM SPACE
      8199,
      // FIGURE SPACE
      8200,
      // PUNCTUATION SPACE
      8201,
      // THIN SPACE
      8202,
      // HAIR SPACE
      8239,
      // NARROW NO-BREAK SPACE
      8287,
      // MEDIUM MATHEMATICAL SPACE
      12288,
      // IDEOGRAPHIC SPACE
      65279
      // ZERO WIDTH NO-BREAK SPACE
    ];
    exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    exports.skipWhiteSpace = skipWhiteSpace;
    var IS_WHITESPACE = new Uint8Array(65536);
    exports.IS_WHITESPACE = IS_WHITESPACE;
    for (const char of exports.WHITESPACE_CHARS) {
      exports.IS_WHITESPACE[char] = 1;
    }
  }
});

// ../../node_modules/sucrase/dist/parser/util/identifier.js
var require_identifier = __commonJS({
  "../../node_modules/sucrase/dist/parser/util/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _charcodes = require_charcodes();
    var _whitespace = require_whitespace();
    function computeIsIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code < 91)
        return true;
      if (code < 97)
        return code === 95;
      if (code < 123)
        return true;
      if (code < 128)
        return false;
      throw new Error("Should not be called with non-ASCII char code.");
    }
    var IS_IDENTIFIER_CHAR = new Uint8Array(65536);
    exports.IS_IDENTIFIER_CHAR = IS_IDENTIFIER_CHAR;
    for (let i = 0; i < 128; i++) {
      exports.IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;
    }
    for (let i = 128; i < 65536; i++) {
      exports.IS_IDENTIFIER_CHAR[i] = 1;
    }
    for (const whitespaceChar of _whitespace.WHITESPACE_CHARS) {
      exports.IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
    }
    exports.IS_IDENTIFIER_CHAR[8232] = 0;
    exports.IS_IDENTIFIER_CHAR[8233] = 0;
    var IS_IDENTIFIER_START = exports.IS_IDENTIFIER_CHAR.slice();
    exports.IS_IDENTIFIER_START = IS_IDENTIFIER_START;
    for (let numChar = _charcodes.charCodes.digit0; numChar <= _charcodes.charCodes.digit9; numChar++) {
      exports.IS_IDENTIFIER_START[numChar] = 0;
    }
  }
});

// ../../node_modules/sucrase/dist/parser/tokenizer/readWordTree.js
var require_readWordTree = __commonJS({
  "../../node_modules/sucrase/dist/parser/tokenizer/readWordTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _keywords = require_keywords();
    var _types = require_types();
    var READ_WORD_TREE = new Int32Array([
      // ""
      -1,
      27,
      783,
      918,
      1755,
      2376,
      2862,
      3483,
      -1,
      3699,
      -1,
      4617,
      4752,
      4833,
      5130,
      5508,
      5940,
      -1,
      6480,
      6939,
      7749,
      8181,
      8451,
      8613,
      -1,
      8829,
      -1,
      // "a"
      -1,
      -1,
      54,
      243,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      432,
      -1,
      -1,
      -1,
      675,
      -1,
      -1,
      -1,
      // "ab"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      81,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "abs"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      108,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "abst"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      135,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "abstr"
      -1,
      162,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "abstra"
      -1,
      -1,
      -1,
      189,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "abstrac"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      216,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "abstract"
      _keywords.ContextualKeyword._abstract << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ac"
      -1,
      -1,
      -1,
      270,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "acc"
      -1,
      -1,
      -1,
      -1,
      -1,
      297,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "acce"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      324,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "acces"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      351,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "access"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      378,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "accesso"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      405,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "accessor"
      _keywords.ContextualKeyword._accessor << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "as"
      _keywords.ContextualKeyword._as << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      459,
      -1,
      -1,
      -1,
      -1,
      -1,
      594,
      -1,
      // "ass"
      -1,
      -1,
      -1,
      -1,
      -1,
      486,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "asse"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      513,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "asser"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      540,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "assert"
      _keywords.ContextualKeyword._assert << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      567,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "asserts"
      _keywords.ContextualKeyword._asserts << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "asy"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      621,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "asyn"
      -1,
      -1,
      -1,
      648,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "async"
      _keywords.ContextualKeyword._async << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "aw"
      -1,
      702,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "awa"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      729,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "awai"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      756,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "await"
      _keywords.ContextualKeyword._await << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "b"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      810,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "br"
      -1,
      -1,
      -1,
      -1,
      -1,
      837,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "bre"
      -1,
      864,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "brea"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      891,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "break"
      (_types.TokenType._break << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "c"
      -1,
      945,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1107,
      -1,
      -1,
      -1,
      1242,
      -1,
      -1,
      1350,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ca"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      972,
      1026,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "cas"
      -1,
      -1,
      -1,
      -1,
      -1,
      999,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "case"
      (_types.TokenType._case << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "cat"
      -1,
      -1,
      -1,
      1053,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "catc"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1080,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "catch"
      (_types.TokenType._catch << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ch"
      -1,
      -1,
      -1,
      -1,
      -1,
      1134,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "che"
      -1,
      -1,
      -1,
      1161,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "chec"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1188,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "check"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1215,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "checks"
      _keywords.ContextualKeyword._checks << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "cl"
      -1,
      1269,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "cla"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1296,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "clas"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1323,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "class"
      (_types.TokenType._class << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "co"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1377,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "con"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1404,
      1620,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "cons"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1431,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "const"
      (_types.TokenType._const << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1458,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "constr"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1485,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "constru"
      -1,
      -1,
      -1,
      1512,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "construc"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1539,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "construct"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1566,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "constructo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1593,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "constructor"
      _keywords.ContextualKeyword._constructor << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "cont"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1647,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "conti"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1674,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "contin"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1701,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "continu"
      -1,
      -1,
      -1,
      -1,
      -1,
      1728,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "continue"
      (_types.TokenType._continue << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "d"
      -1,
      -1,
      -1,
      -1,
      -1,
      1782,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2349,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "de"
      -1,
      -1,
      1809,
      1971,
      -1,
      -1,
      2106,
      -1,
      -1,
      -1,
      -1,
      -1,
      2241,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "deb"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1836,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "debu"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1863,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "debug"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1890,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "debugg"
      -1,
      -1,
      -1,
      -1,
      -1,
      1917,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "debugge"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1944,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "debugger"
      (_types.TokenType._debugger << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "dec"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      1998,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "decl"
      -1,
      2025,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "decla"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2052,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "declar"
      -1,
      -1,
      -1,
      -1,
      -1,
      2079,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "declare"
      _keywords.ContextualKeyword._declare << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "def"
      -1,
      2133,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "defa"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2160,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "defau"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2187,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "defaul"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2214,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "default"
      (_types.TokenType._default << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "del"
      -1,
      -1,
      -1,
      -1,
      -1,
      2268,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "dele"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2295,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "delet"
      -1,
      -1,
      -1,
      -1,
      -1,
      2322,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "delete"
      (_types.TokenType._delete << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "do"
      (_types.TokenType._do << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "e"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2403,
      -1,
      2484,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2565,
      -1,
      -1,
      // "el"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2430,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "els"
      -1,
      -1,
      -1,
      -1,
      -1,
      2457,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "else"
      (_types.TokenType._else << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "en"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2511,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "enu"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2538,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "enum"
      _keywords.ContextualKeyword._enum << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ex"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2592,
      -1,
      -1,
      -1,
      2727,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "exp"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2619,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "expo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2646,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "expor"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2673,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "export"
      (_types.TokenType._export << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2700,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "exports"
      _keywords.ContextualKeyword._exports << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ext"
      -1,
      -1,
      -1,
      -1,
      -1,
      2754,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "exte"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2781,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "exten"
      -1,
      -1,
      -1,
      -1,
      2808,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "extend"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2835,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "extends"
      (_types.TokenType._extends << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "f"
      -1,
      2889,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2997,
      -1,
      -1,
      -1,
      -1,
      -1,
      3159,
      -1,
      -1,
      3213,
      -1,
      -1,
      3294,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fa"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2916,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fal"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2943,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fals"
      -1,
      -1,
      -1,
      -1,
      -1,
      2970,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "false"
      (_types.TokenType._false << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3024,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fin"
      -1,
      3051,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fina"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3078,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "final"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3105,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "finall"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3132,
      -1,
      // "finally"
      (_types.TokenType._finally << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3186,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "for"
      (_types.TokenType._for << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fr"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3240,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fro"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3267,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "from"
      _keywords.ContextualKeyword._from << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fu"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3321,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "fun"
      -1,
      -1,
      -1,
      3348,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "func"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3375,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "funct"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3402,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "functi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3429,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "functio"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3456,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "function"
      (_types.TokenType._function << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "g"
      -1,
      -1,
      -1,
      -1,
      -1,
      3510,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3564,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ge"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3537,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "get"
      _keywords.ContextualKeyword._get << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "gl"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3591,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "glo"
      -1,
      -1,
      3618,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "glob"
      -1,
      3645,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "globa"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3672,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "global"
      _keywords.ContextualKeyword._global << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "i"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3726,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3753,
      4077,
      -1,
      -1,
      -1,
      -1,
      4590,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "if"
      (_types.TokenType._if << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "im"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3780,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "imp"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3807,
      -1,
      -1,
      3996,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "impl"
      -1,
      -1,
      -1,
      -1,
      -1,
      3834,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "imple"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3861,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "implem"
      -1,
      -1,
      -1,
      -1,
      -1,
      3888,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "impleme"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3915,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "implemen"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3942,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "implement"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      3969,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "implements"
      _keywords.ContextualKeyword._implements << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "impo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4023,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "impor"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4050,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "import"
      (_types.TokenType._import << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "in"
      (_types.TokenType._in << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4104,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4185,
      4401,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "inf"
      -1,
      -1,
      -1,
      -1,
      -1,
      4131,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "infe"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4158,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "infer"
      _keywords.ContextualKeyword._infer << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ins"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4212,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "inst"
      -1,
      4239,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "insta"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4266,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "instan"
      -1,
      -1,
      -1,
      4293,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "instanc"
      -1,
      -1,
      -1,
      -1,
      -1,
      4320,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "instance"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4347,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "instanceo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4374,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "instanceof"
      (_types.TokenType._instanceof << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "int"
      -1,
      -1,
      -1,
      -1,
      -1,
      4428,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "inte"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4455,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "inter"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4482,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "interf"
      -1,
      4509,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "interfa"
      -1,
      -1,
      -1,
      4536,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "interfac"
      -1,
      -1,
      -1,
      -1,
      -1,
      4563,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "interface"
      _keywords.ContextualKeyword._interface << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "is"
      _keywords.ContextualKeyword._is << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "k"
      -1,
      -1,
      -1,
      -1,
      -1,
      4644,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ke"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4671,
      -1,
      // "key"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4698,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "keyo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4725,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "keyof"
      _keywords.ContextualKeyword._keyof << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "l"
      -1,
      -1,
      -1,
      -1,
      -1,
      4779,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "le"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4806,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "let"
      (_types.TokenType._let << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "m"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4860,
      -1,
      -1,
      -1,
      -1,
      -1,
      4995,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "mi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4887,
      -1,
      -1,
      // "mix"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4914,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "mixi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4941,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "mixin"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      4968,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "mixins"
      _keywords.ContextualKeyword._mixins << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "mo"
      -1,
      -1,
      -1,
      -1,
      5022,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "mod"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5049,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "modu"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5076,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "modul"
      -1,
      -1,
      -1,
      -1,
      -1,
      5103,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "module"
      _keywords.ContextualKeyword._module << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "n"
      -1,
      5157,
      -1,
      -1,
      -1,
      5373,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5427,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "na"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5184,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "nam"
      -1,
      -1,
      -1,
      -1,
      -1,
      5211,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "name"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5238,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "names"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5265,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "namesp"
      -1,
      5292,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "namespa"
      -1,
      -1,
      -1,
      5319,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "namespac"
      -1,
      -1,
      -1,
      -1,
      -1,
      5346,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "namespace"
      _keywords.ContextualKeyword._namespace << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ne"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5400,
      -1,
      -1,
      -1,
      // "new"
      (_types.TokenType._new << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "nu"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5454,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "nul"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5481,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "null"
      (_types.TokenType._null << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "o"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5535,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5562,
      -1,
      -1,
      -1,
      -1,
      5697,
      5751,
      -1,
      -1,
      -1,
      -1,
      // "of"
      _keywords.ContextualKeyword._of << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "op"
      -1,
      5589,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "opa"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5616,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "opaq"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5643,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "opaqu"
      -1,
      -1,
      -1,
      -1,
      -1,
      5670,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "opaque"
      _keywords.ContextualKeyword._opaque << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ou"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5724,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "out"
      _keywords.ContextualKeyword._out << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ov"
      -1,
      -1,
      -1,
      -1,
      -1,
      5778,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ove"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5805,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "over"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5832,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "overr"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5859,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "overri"
      -1,
      -1,
      -1,
      -1,
      5886,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "overrid"
      -1,
      -1,
      -1,
      -1,
      -1,
      5913,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "override"
      _keywords.ContextualKeyword._override << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "p"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5967,
      -1,
      -1,
      6345,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "pr"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      5994,
      -1,
      -1,
      -1,
      -1,
      -1,
      6129,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "pri"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6021,
      -1,
      -1,
      -1,
      -1,
      // "priv"
      -1,
      6048,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "priva"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6075,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "privat"
      -1,
      -1,
      -1,
      -1,
      -1,
      6102,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "private"
      _keywords.ContextualKeyword._private << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "pro"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6156,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "prot"
      -1,
      -1,
      -1,
      -1,
      -1,
      6183,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6318,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "prote"
      -1,
      -1,
      -1,
      6210,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "protec"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6237,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "protect"
      -1,
      -1,
      -1,
      -1,
      -1,
      6264,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "protecte"
      -1,
      -1,
      -1,
      -1,
      6291,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "protected"
      _keywords.ContextualKeyword._protected << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "proto"
      _keywords.ContextualKeyword._proto << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "pu"
      -1,
      -1,
      6372,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "pub"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6399,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "publ"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6426,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "publi"
      -1,
      -1,
      -1,
      6453,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "public"
      _keywords.ContextualKeyword._public << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "r"
      -1,
      -1,
      -1,
      -1,
      -1,
      6507,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "re"
      -1,
      6534,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6696,
      -1,
      -1,
      6831,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "rea"
      -1,
      -1,
      -1,
      -1,
      6561,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "read"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6588,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "reado"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6615,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "readon"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6642,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "readonl"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6669,
      -1,
      // "readonly"
      _keywords.ContextualKeyword._readonly << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "req"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6723,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "requ"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6750,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "requi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6777,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "requir"
      -1,
      -1,
      -1,
      -1,
      -1,
      6804,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "require"
      _keywords.ContextualKeyword._require << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ret"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6858,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "retu"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6885,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "retur"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6912,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "return"
      (_types.TokenType._return << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "s"
      -1,
      6966,
      -1,
      -1,
      -1,
      7182,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7236,
      7371,
      -1,
      7479,
      -1,
      7614,
      -1,
      // "sa"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      6993,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sat"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7020,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sati"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7047,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "satis"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7074,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "satisf"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7101,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "satisfi"
      -1,
      -1,
      -1,
      -1,
      -1,
      7128,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "satisfie"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7155,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "satisfies"
      _keywords.ContextualKeyword._satisfies << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "se"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7209,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "set"
      _keywords.ContextualKeyword._set << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "st"
      -1,
      7263,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sta"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7290,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "stat"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7317,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "stati"
      -1,
      -1,
      -1,
      7344,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "static"
      _keywords.ContextualKeyword._static << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "su"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7398,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sup"
      -1,
      -1,
      -1,
      -1,
      -1,
      7425,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "supe"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7452,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "super"
      (_types.TokenType._super << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sw"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7506,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "swi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7533,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "swit"
      -1,
      -1,
      -1,
      7560,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "switc"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7587,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "switch"
      (_types.TokenType._switch << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sy"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7641,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "sym"
      -1,
      -1,
      7668,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "symb"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7695,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "symbo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7722,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "symbol"
      _keywords.ContextualKeyword._symbol << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "t"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7776,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7938,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8046,
      -1,
      // "th"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7803,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7857,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "thi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7830,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "this"
      (_types.TokenType._this << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "thr"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7884,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "thro"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7911,
      -1,
      -1,
      -1,
      // "throw"
      (_types.TokenType._throw << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "tr"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      7965,
      -1,
      -1,
      -1,
      8019,
      -1,
      // "tru"
      -1,
      -1,
      -1,
      -1,
      -1,
      7992,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "true"
      (_types.TokenType._true << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "try"
      (_types.TokenType._try << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "ty"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8073,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "typ"
      -1,
      -1,
      -1,
      -1,
      -1,
      8100,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "type"
      _keywords.ContextualKeyword._type << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8127,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "typeo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8154,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "typeof"
      (_types.TokenType._typeof << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "u"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8208,
      -1,
      -1,
      -1,
      -1,
      8343,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "un"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8235,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "uni"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8262,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "uniq"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8289,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "uniqu"
      -1,
      -1,
      -1,
      -1,
      -1,
      8316,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "unique"
      _keywords.ContextualKeyword._unique << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "us"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8370,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "usi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8397,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "usin"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8424,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "using"
      _keywords.ContextualKeyword._using << 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "v"
      -1,
      8478,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8532,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "va"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8505,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "var"
      (_types.TokenType._var << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "vo"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8559,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "voi"
      -1,
      -1,
      -1,
      -1,
      8586,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "void"
      (_types.TokenType._void << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "w"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8640,
      8748,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "wh"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8667,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "whi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8694,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "whil"
      -1,
      -1,
      -1,
      -1,
      -1,
      8721,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "while"
      (_types.TokenType._while << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "wi"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8775,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "wit"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8802,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "with"
      (_types.TokenType._with << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "y"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8856,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "yi"
      -1,
      -1,
      -1,
      -1,
      -1,
      8883,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "yie"
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      8910,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "yiel"
      -1,
      -1,
      -1,
      -1,
      8937,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // "yield"
      (_types.TokenType._yield << 1) + 1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ]);
    exports.READ_WORD_TREE = READ_WORD_TREE;
  }
});

// ../../node_modules/sucrase/dist/parser/tokenizer/readWord.js
var require_readWord = __commonJS({
  "../../node_modules/sucrase/dist/parser/tokenizer/readWord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _base = require_base();
    var _charcodes = require_charcodes();
    var _identifier = require_identifier();
    var _index = require_tokenizer();
    var _readWordTree = require_readWordTree();
    var _types = require_types();
    function readWord() {
      let treePos = 0;
      let code = 0;
      let pos = _base.state.pos;
      while (pos < _base.input.length) {
        code = _base.input.charCodeAt(pos);
        if (code < _charcodes.charCodes.lowercaseA || code > _charcodes.charCodes.lowercaseZ) {
          break;
        }
        const next = _readWordTree.READ_WORD_TREE[treePos + (code - _charcodes.charCodes.lowercaseA) + 1];
        if (next === -1) {
          break;
        } else {
          treePos = next;
          pos++;
        }
      }
      const keywordValue = _readWordTree.READ_WORD_TREE[treePos];
      if (keywordValue > -1 && !_identifier.IS_IDENTIFIER_CHAR[code]) {
        _base.state.pos = pos;
        if (keywordValue & 1) {
          _index.finishToken.call(void 0, keywordValue >>> 1);
        } else {
          _index.finishToken.call(void 0, _types.TokenType.name, keywordValue >>> 1);
        }
        return;
      }
      while (pos < _base.input.length) {
        const ch = _base.input.charCodeAt(pos);
        if (_identifier.IS_IDENTIFIER_CHAR[ch]) {
          pos++;
        } else if (ch === _charcodes.charCodes.backslash) {
          pos += 2;
          if (_base.input.charCodeAt(pos) === _charcodes.charCodes.leftCurlyBrace) {
            while (pos < _base.input.length && _base.input.charCodeAt(pos) !== _charcodes.charCodes.rightCurlyBrace) {
              pos++;
            }
            pos++;
          }
        } else if (ch === _charcodes.charCodes.atSign && _base.input.charCodeAt(pos + 1) === _charcodes.charCodes.atSign) {
          pos += 2;
        } else {
          break;
        }
      }
      _base.state.pos = pos;
      _index.finishToken.call(void 0, _types.TokenType.name);
    }
    exports.default = readWord;
  }
});

// ../../node_modules/sucrase/dist/parser/tokenizer/index.js
var require_tokenizer = __commonJS({
  "../../node_modules/sucrase/dist/parser/tokenizer/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _base = require_base();
    var _util = require_util();
    var _charcodes = require_charcodes();
    var _identifier = require_identifier();
    var _whitespace = require_whitespace();
    var _keywords = require_keywords();
    var _readWord = require_readWord();
    var _readWord2 = _interopRequireDefault(_readWord);
    var _types = require_types();
    var IdentifierRole;
    (function(IdentifierRole2) {
      const Access = 0;
      IdentifierRole2[IdentifierRole2["Access"] = Access] = "Access";
      const ExportAccess = Access + 1;
      IdentifierRole2[IdentifierRole2["ExportAccess"] = ExportAccess] = "ExportAccess";
      const TopLevelDeclaration = ExportAccess + 1;
      IdentifierRole2[IdentifierRole2["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
      const FunctionScopedDeclaration = TopLevelDeclaration + 1;
      IdentifierRole2[IdentifierRole2["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
      const BlockScopedDeclaration = FunctionScopedDeclaration + 1;
      IdentifierRole2[IdentifierRole2["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
      const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;
      IdentifierRole2[IdentifierRole2["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
      const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;
      IdentifierRole2[IdentifierRole2["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
      const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;
      IdentifierRole2[IdentifierRole2["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
      const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;
      IdentifierRole2[IdentifierRole2["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
      const ImportDeclaration = ObjectShorthand + 1;
      IdentifierRole2[IdentifierRole2["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
      const ObjectKey = ImportDeclaration + 1;
      IdentifierRole2[IdentifierRole2["ObjectKey"] = ObjectKey] = "ObjectKey";
      const ImportAccess = ObjectKey + 1;
      IdentifierRole2[IdentifierRole2["ImportAccess"] = ImportAccess] = "ImportAccess";
    })(IdentifierRole || (exports.IdentifierRole = IdentifierRole = {}));
    var JSXRole;
    (function(JSXRole2) {
      const NoChildren = 0;
      JSXRole2[JSXRole2["NoChildren"] = NoChildren] = "NoChildren";
      const OneChild = NoChildren + 1;
      JSXRole2[JSXRole2["OneChild"] = OneChild] = "OneChild";
      const StaticChildren = OneChild + 1;
      JSXRole2[JSXRole2["StaticChildren"] = StaticChildren] = "StaticChildren";
      const KeyAfterPropSpread = StaticChildren + 1;
      JSXRole2[JSXRole2["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
    })(JSXRole || (exports.JSXRole = JSXRole = {}));
    function isDeclaration(token) {
      const role = token.identifierRole;
      return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    }
    exports.isDeclaration = isDeclaration;
    function isNonTopLevelDeclaration(token) {
      const role = token.identifierRole;
      return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    }
    exports.isNonTopLevelDeclaration = isNonTopLevelDeclaration;
    function isTopLevelDeclaration(token) {
      const role = token.identifierRole;
      return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;
    }
    exports.isTopLevelDeclaration = isTopLevelDeclaration;
    function isBlockScopedDeclaration(token) {
      const role = token.identifierRole;
      return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    }
    exports.isBlockScopedDeclaration = isBlockScopedDeclaration;
    function isFunctionScopedDeclaration(token) {
      const role = token.identifierRole;
      return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
    exports.isFunctionScopedDeclaration = isFunctionScopedDeclaration;
    function isObjectShorthandDeclaration(token) {
      return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
    exports.isObjectShorthandDeclaration = isObjectShorthandDeclaration;
    var Token = class {
      constructor() {
        this.type = _base.state.type;
        this.contextualKeyword = _base.state.contextualKeyword;
        this.start = _base.state.start;
        this.end = _base.state.end;
        this.scopeDepth = _base.state.scopeDepth;
        this.isType = _base.state.isType;
        this.identifierRole = null;
        this.jsxRole = null;
        this.shadowsGlobal = false;
        this.isAsyncOperation = false;
        this.contextId = null;
        this.rhsEndIndex = null;
        this.isExpression = false;
        this.numNullishCoalesceStarts = 0;
        this.numNullishCoalesceEnds = 0;
        this.isOptionalChainStart = false;
        this.isOptionalChainEnd = false;
        this.subscriptStartIndex = null;
        this.nullishStartIndex = null;
      }
      // Initially false for all tokens, then may be computed in a follow-up step that does scope
      // analysis.
      // Initially false for all tokens, but may be set during transform to mark it as containing an
      // await operation.
      // For assignments, the index of the RHS. For export tokens, the end of the export.
      // For class tokens, records if the class is a class expression or a class statement.
      // Number of times to insert a `nullishCoalesce(` snippet before this token.
      // Number of times to insert a `)` snippet after this token.
      // If true, insert an `optionalChain([` snippet before this token.
      // If true, insert a `])` snippet after this token.
      // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
      // subscript chain. This can be used to determine if this chain is an optional chain.
      // Tag for `??` operators to denote the root token for this nullish coalescing call.
    };
    exports.Token = Token;
    function next() {
      _base.state.tokens.push(new Token());
      nextToken();
    }
    exports.next = next;
    function nextTemplateToken() {
      _base.state.tokens.push(new Token());
      _base.state.start = _base.state.pos;
      readTmplToken();
    }
    exports.nextTemplateToken = nextTemplateToken;
    function retokenizeSlashAsRegex() {
      if (_base.state.type === _types.TokenType.assign) {
        --_base.state.pos;
      }
      readRegexp();
    }
    exports.retokenizeSlashAsRegex = retokenizeSlashAsRegex;
    function pushTypeContext(existingTokensInType) {
      for (let i = _base.state.tokens.length - existingTokensInType; i < _base.state.tokens.length; i++) {
        _base.state.tokens[i].isType = true;
      }
      const oldIsType = _base.state.isType;
      _base.state.isType = true;
      return oldIsType;
    }
    exports.pushTypeContext = pushTypeContext;
    function popTypeContext(oldIsType) {
      _base.state.isType = oldIsType;
    }
    exports.popTypeContext = popTypeContext;
    function eat(type) {
      if (match(type)) {
        next();
        return true;
      } else {
        return false;
      }
    }
    exports.eat = eat;
    function eatTypeToken(tokenType) {
      const oldIsType = _base.state.isType;
      _base.state.isType = true;
      eat(tokenType);
      _base.state.isType = oldIsType;
    }
    exports.eatTypeToken = eatTypeToken;
    function match(type) {
      return _base.state.type === type;
    }
    exports.match = match;
    function lookaheadType() {
      const snapshot = _base.state.snapshot();
      next();
      const type = _base.state.type;
      _base.state.restoreFromSnapshot(snapshot);
      return type;
    }
    exports.lookaheadType = lookaheadType;
    var TypeAndKeyword = class {
      constructor(type, contextualKeyword) {
        this.type = type;
        this.contextualKeyword = contextualKeyword;
      }
    };
    exports.TypeAndKeyword = TypeAndKeyword;
    function lookaheadTypeAndKeyword() {
      const snapshot = _base.state.snapshot();
      next();
      const type = _base.state.type;
      const contextualKeyword = _base.state.contextualKeyword;
      _base.state.restoreFromSnapshot(snapshot);
      return new TypeAndKeyword(type, contextualKeyword);
    }
    exports.lookaheadTypeAndKeyword = lookaheadTypeAndKeyword;
    function nextTokenStart() {
      return nextTokenStartSince(_base.state.pos);
    }
    exports.nextTokenStart = nextTokenStart;
    function nextTokenStartSince(pos) {
      _whitespace.skipWhiteSpace.lastIndex = pos;
      const skip = _whitespace.skipWhiteSpace.exec(_base.input);
      return pos + skip[0].length;
    }
    exports.nextTokenStartSince = nextTokenStartSince;
    function lookaheadCharCode() {
      return _base.input.charCodeAt(nextTokenStart());
    }
    exports.lookaheadCharCode = lookaheadCharCode;
    function nextToken() {
      skipSpace();
      _base.state.start = _base.state.pos;
      if (_base.state.pos >= _base.input.length) {
        const tokens = _base.state.tokens;
        if (tokens.length >= 2 && tokens[tokens.length - 1].start >= _base.input.length && tokens[tokens.length - 2].start >= _base.input.length) {
          _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
        }
        finishToken(_types.TokenType.eof);
        return;
      }
      readToken(_base.input.charCodeAt(_base.state.pos));
    }
    exports.nextToken = nextToken;
    function readToken(code) {
      if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash || code === _charcodes.charCodes.atSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.atSign) {
        _readWord2.default.call(void 0);
      } else {
        getTokenFromCode(code);
      }
    }
    function skipBlockComment() {
      while (_base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.asterisk || _base.input.charCodeAt(_base.state.pos + 1) !== _charcodes.charCodes.slash) {
        _base.state.pos++;
        if (_base.state.pos > _base.input.length) {
          _util.unexpected.call(void 0, "Unterminated comment", _base.state.pos - 2);
          return;
        }
      }
      _base.state.pos += 2;
    }
    function skipLineComment(startSkip) {
      let ch = _base.input.charCodeAt(_base.state.pos += startSkip);
      if (_base.state.pos < _base.input.length) {
        while (ch !== _charcodes.charCodes.lineFeed && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.lineSeparator && ch !== _charcodes.charCodes.paragraphSeparator && ++_base.state.pos < _base.input.length) {
          ch = _base.input.charCodeAt(_base.state.pos);
        }
      }
    }
    exports.skipLineComment = skipLineComment;
    function skipSpace() {
      while (_base.state.pos < _base.input.length) {
        const ch = _base.input.charCodeAt(_base.state.pos);
        switch (ch) {
          case _charcodes.charCodes.carriageReturn:
            if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.lineFeed) {
              ++_base.state.pos;
            }
          case _charcodes.charCodes.lineFeed:
          case _charcodes.charCodes.lineSeparator:
          case _charcodes.charCodes.paragraphSeparator:
            ++_base.state.pos;
            break;
          case _charcodes.charCodes.slash:
            switch (_base.input.charCodeAt(_base.state.pos + 1)) {
              case _charcodes.charCodes.asterisk:
                _base.state.pos += 2;
                skipBlockComment();
                break;
              case _charcodes.charCodes.slash:
                skipLineComment(2);
                break;
              default:
                return;
            }
            break;
          default:
            if (_whitespace.IS_WHITESPACE[ch]) {
              ++_base.state.pos;
            } else {
              return;
            }
        }
      }
    }
    exports.skipSpace = skipSpace;
    function finishToken(type, contextualKeyword = _keywords.ContextualKeyword.NONE) {
      _base.state.end = _base.state.pos;
      _base.state.type = type;
      _base.state.contextualKeyword = contextualKeyword;
    }
    exports.finishToken = finishToken;
    function readToken_dot() {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar >= _charcodes.charCodes.digit0 && nextChar <= _charcodes.charCodes.digit9) {
        readNumber(true);
        return;
      }
      if (nextChar === _charcodes.charCodes.dot && _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.dot) {
        _base.state.pos += 3;
        finishToken(_types.TokenType.ellipsis);
      } else {
        ++_base.state.pos;
        finishToken(_types.TokenType.dot);
      }
    }
    function readToken_slash() {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.assign, 2);
      } else {
        finishOp(_types.TokenType.slash, 1);
      }
    }
    function readToken_mult_modulo(code) {
      let tokenType = code === _charcodes.charCodes.asterisk ? _types.TokenType.star : _types.TokenType.modulo;
      let width = 1;
      let nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (code === _charcodes.charCodes.asterisk && nextChar === _charcodes.charCodes.asterisk) {
        width++;
        nextChar = _base.input.charCodeAt(_base.state.pos + 2);
        tokenType = _types.TokenType.exponent;
      }
      if (nextChar === _charcodes.charCodes.equalsTo && _base.input.charCodeAt(_base.state.pos + 2) !== _charcodes.charCodes.greaterThan) {
        width++;
        tokenType = _types.TokenType.assign;
      }
      finishOp(tokenType, width);
    }
    function readToken_pipe_amp(code) {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === code) {
        if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
          finishOp(_types.TokenType.assign, 3);
        } else {
          finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.logicalOR : _types.TokenType.logicalAND, 2);
        }
        return;
      }
      if (code === _charcodes.charCodes.verticalBar) {
        if (nextChar === _charcodes.charCodes.greaterThan) {
          finishOp(_types.TokenType.pipeline, 2);
          return;
        } else if (nextChar === _charcodes.charCodes.rightCurlyBrace && _base.isFlowEnabled) {
          finishOp(_types.TokenType.braceBarR, 2);
          return;
        }
      }
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.assign, 2);
        return;
      }
      finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.bitwiseOR : _types.TokenType.bitwiseAND, 1);
    }
    function readToken_caret() {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.assign, 2);
      } else {
        finishOp(_types.TokenType.bitwiseXOR, 1);
      }
    }
    function readToken_plus_min(code) {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === code) {
        finishOp(_types.TokenType.preIncDec, 2);
        return;
      }
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.assign, 2);
      } else if (code === _charcodes.charCodes.plusSign) {
        finishOp(_types.TokenType.plus, 1);
      } else {
        finishOp(_types.TokenType.minus, 1);
      }
    }
    function readToken_lt() {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === _charcodes.charCodes.lessThan) {
        if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
          finishOp(_types.TokenType.assign, 3);
          return;
        }
        if (_base.state.isType) {
          finishOp(_types.TokenType.lessThan, 1);
        } else {
          finishOp(_types.TokenType.bitShiftL, 2);
        }
        return;
      }
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.relationalOrEqual, 2);
      } else {
        finishOp(_types.TokenType.lessThan, 1);
      }
    }
    function readToken_gt() {
      if (_base.state.isType) {
        finishOp(_types.TokenType.greaterThan, 1);
        return;
      }
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === _charcodes.charCodes.greaterThan) {
        const size = _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.greaterThan ? 3 : 2;
        if (_base.input.charCodeAt(_base.state.pos + size) === _charcodes.charCodes.equalsTo) {
          finishOp(_types.TokenType.assign, size + 1);
          return;
        }
        finishOp(_types.TokenType.bitShiftR, size);
        return;
      }
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.relationalOrEqual, 2);
      } else {
        finishOp(_types.TokenType.greaterThan, 1);
      }
    }
    function rescan_gt() {
      if (_base.state.type === _types.TokenType.greaterThan) {
        _base.state.pos -= 1;
        readToken_gt();
      }
    }
    exports.rescan_gt = rescan_gt;
    function readToken_eq_excl(code) {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.equality, _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo ? 3 : 2);
        return;
      }
      if (code === _charcodes.charCodes.equalsTo && nextChar === _charcodes.charCodes.greaterThan) {
        _base.state.pos += 2;
        finishToken(_types.TokenType.arrow);
        return;
      }
      finishOp(code === _charcodes.charCodes.equalsTo ? _types.TokenType.eq : _types.TokenType.bang, 1);
    }
    function readToken_question() {
      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
      const nextChar2 = _base.input.charCodeAt(_base.state.pos + 2);
      if (nextChar === _charcodes.charCodes.questionMark && // In Flow (but not TypeScript), ??string is a valid type that should be
      // tokenized as two individual ? tokens.
      !(_base.isFlowEnabled && _base.state.isType)) {
        if (nextChar2 === _charcodes.charCodes.equalsTo) {
          finishOp(_types.TokenType.assign, 3);
        } else {
          finishOp(_types.TokenType.nullishCoalescing, 2);
        }
      } else if (nextChar === _charcodes.charCodes.dot && !(nextChar2 >= _charcodes.charCodes.digit0 && nextChar2 <= _charcodes.charCodes.digit9)) {
        _base.state.pos += 2;
        finishToken(_types.TokenType.questionDot);
      } else {
        ++_base.state.pos;
        finishToken(_types.TokenType.question);
      }
    }
    function getTokenFromCode(code) {
      switch (code) {
        case _charcodes.charCodes.numberSign:
          ++_base.state.pos;
          finishToken(_types.TokenType.hash);
          return;
        case _charcodes.charCodes.dot:
          readToken_dot();
          return;
        case _charcodes.charCodes.leftParenthesis:
          ++_base.state.pos;
          finishToken(_types.TokenType.parenL);
          return;
        case _charcodes.charCodes.rightParenthesis:
          ++_base.state.pos;
          finishToken(_types.TokenType.parenR);
          return;
        case _charcodes.charCodes.semicolon:
          ++_base.state.pos;
          finishToken(_types.TokenType.semi);
          return;
        case _charcodes.charCodes.comma:
          ++_base.state.pos;
          finishToken(_types.TokenType.comma);
          return;
        case _charcodes.charCodes.leftSquareBracket:
          ++_base.state.pos;
          finishToken(_types.TokenType.bracketL);
          return;
        case _charcodes.charCodes.rightSquareBracket:
          ++_base.state.pos;
          finishToken(_types.TokenType.bracketR);
          return;
        case _charcodes.charCodes.leftCurlyBrace:
          if (_base.isFlowEnabled && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.verticalBar) {
            finishOp(_types.TokenType.braceBarL, 2);
          } else {
            ++_base.state.pos;
            finishToken(_types.TokenType.braceL);
          }
          return;
        case _charcodes.charCodes.rightCurlyBrace:
          ++_base.state.pos;
          finishToken(_types.TokenType.braceR);
          return;
        case _charcodes.charCodes.colon:
          if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.colon) {
            finishOp(_types.TokenType.doubleColon, 2);
          } else {
            ++_base.state.pos;
            finishToken(_types.TokenType.colon);
          }
          return;
        case _charcodes.charCodes.questionMark:
          readToken_question();
          return;
        case _charcodes.charCodes.atSign:
          ++_base.state.pos;
          finishToken(_types.TokenType.at);
          return;
        case _charcodes.charCodes.graveAccent:
          ++_base.state.pos;
          finishToken(_types.TokenType.backQuote);
          return;
        case _charcodes.charCodes.digit0: {
          const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
          if (nextChar === _charcodes.charCodes.lowercaseX || nextChar === _charcodes.charCodes.uppercaseX || nextChar === _charcodes.charCodes.lowercaseO || nextChar === _charcodes.charCodes.uppercaseO || nextChar === _charcodes.charCodes.lowercaseB || nextChar === _charcodes.charCodes.uppercaseB) {
            readRadixNumber();
            return;
          }
        }
        case _charcodes.charCodes.digit1:
        case _charcodes.charCodes.digit2:
        case _charcodes.charCodes.digit3:
        case _charcodes.charCodes.digit4:
        case _charcodes.charCodes.digit5:
        case _charcodes.charCodes.digit6:
        case _charcodes.charCodes.digit7:
        case _charcodes.charCodes.digit8:
        case _charcodes.charCodes.digit9:
          readNumber(false);
          return;
        case _charcodes.charCodes.quotationMark:
        case _charcodes.charCodes.apostrophe:
          readString(code);
          return;
        case _charcodes.charCodes.slash:
          readToken_slash();
          return;
        case _charcodes.charCodes.percentSign:
        case _charcodes.charCodes.asterisk:
          readToken_mult_modulo(code);
          return;
        case _charcodes.charCodes.verticalBar:
        case _charcodes.charCodes.ampersand:
          readToken_pipe_amp(code);
          return;
        case _charcodes.charCodes.caret:
          readToken_caret();
          return;
        case _charcodes.charCodes.plusSign:
        case _charcodes.charCodes.dash:
          readToken_plus_min(code);
          return;
        case _charcodes.charCodes.lessThan:
          readToken_lt();
          return;
        case _charcodes.charCodes.greaterThan:
          readToken_gt();
          return;
        case _charcodes.charCodes.equalsTo:
        case _charcodes.charCodes.exclamationMark:
          readToken_eq_excl(code);
          return;
        case _charcodes.charCodes.tilde:
          finishOp(_types.TokenType.tilde, 1);
          return;
        default:
          break;
      }
      _util.unexpected.call(void 0, `Unexpected character '${String.fromCharCode(code)}'`, _base.state.pos);
    }
    exports.getTokenFromCode = getTokenFromCode;
    function finishOp(type, size) {
      _base.state.pos += size;
      finishToken(type);
    }
    function readRegexp() {
      const start = _base.state.pos;
      let escaped = false;
      let inClass = false;
      for (; ; ) {
        if (_base.state.pos >= _base.input.length) {
          _util.unexpected.call(void 0, "Unterminated regular expression", start);
          return;
        }
        const code = _base.input.charCodeAt(_base.state.pos);
        if (escaped) {
          escaped = false;
        } else {
          if (code === _charcodes.charCodes.leftSquareBracket) {
            inClass = true;
          } else if (code === _charcodes.charCodes.rightSquareBracket && inClass) {
            inClass = false;
          } else if (code === _charcodes.charCodes.slash && !inClass) {
            break;
          }
          escaped = code === _charcodes.charCodes.backslash;
        }
        ++_base.state.pos;
      }
      ++_base.state.pos;
      skipWord();
      finishToken(_types.TokenType.regexp);
    }
    function readInt() {
      while (true) {
        const code = _base.input.charCodeAt(_base.state.pos);
        if (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code === _charcodes.charCodes.underscore) {
          _base.state.pos++;
        } else {
          break;
        }
      }
    }
    function readRadixNumber() {
      _base.state.pos += 2;
      while (true) {
        const code = _base.input.charCodeAt(_base.state.pos);
        if (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF || code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF || code === _charcodes.charCodes.underscore) {
          _base.state.pos++;
        } else {
          break;
        }
      }
      const nextChar = _base.input.charCodeAt(_base.state.pos);
      if (nextChar === _charcodes.charCodes.lowercaseN) {
        ++_base.state.pos;
        finishToken(_types.TokenType.bigint);
      } else {
        finishToken(_types.TokenType.num);
      }
    }
    function readNumber(startsWithDot) {
      let isBigInt = false;
      let isDecimal = false;
      if (!startsWithDot) {
        readInt();
      }
      let nextChar = _base.input.charCodeAt(_base.state.pos);
      if (nextChar === _charcodes.charCodes.dot) {
        ++_base.state.pos;
        readInt();
        nextChar = _base.input.charCodeAt(_base.state.pos);
      }
      if (nextChar === _charcodes.charCodes.uppercaseE || nextChar === _charcodes.charCodes.lowercaseE) {
        nextChar = _base.input.charCodeAt(++_base.state.pos);
        if (nextChar === _charcodes.charCodes.plusSign || nextChar === _charcodes.charCodes.dash) {
          ++_base.state.pos;
        }
        readInt();
        nextChar = _base.input.charCodeAt(_base.state.pos);
      }
      if (nextChar === _charcodes.charCodes.lowercaseN) {
        ++_base.state.pos;
        isBigInt = true;
      } else if (nextChar === _charcodes.charCodes.lowercaseM) {
        ++_base.state.pos;
        isDecimal = true;
      }
      if (isBigInt) {
        finishToken(_types.TokenType.bigint);
        return;
      }
      if (isDecimal) {
        finishToken(_types.TokenType.decimal);
        return;
      }
      finishToken(_types.TokenType.num);
    }
    function readString(quote) {
      _base.state.pos++;
      for (; ; ) {
        if (_base.state.pos >= _base.input.length) {
          _util.unexpected.call(void 0, "Unterminated string constant");
          return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === _charcodes.charCodes.backslash) {
          _base.state.pos++;
        } else if (ch === quote) {
          break;
        }
        _base.state.pos++;
      }
      _base.state.pos++;
      finishToken(_types.TokenType.string);
    }
    function readTmplToken() {
      for (; ; ) {
        if (_base.state.pos >= _base.input.length) {
          _util.unexpected.call(void 0, "Unterminated template");
          return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === _charcodes.charCodes.graveAccent || ch === _charcodes.charCodes.dollarSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.leftCurlyBrace) {
          if (_base.state.pos === _base.state.start && match(_types.TokenType.template)) {
            if (ch === _charcodes.charCodes.dollarSign) {
              _base.state.pos += 2;
              finishToken(_types.TokenType.dollarBraceL);
              return;
            } else {
              ++_base.state.pos;
              finishToken(_types.TokenType.backQuote);
              return;
            }
          }
          finishToken(_types.TokenType.template);
          return;
        }
        if (ch === _charcodes.charCodes.backslash) {
          _base.state.pos++;
        }
        _base.state.pos++;
      }
    }
    function skipWord() {
      while (_base.state.pos < _base.input.length) {
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (_identifier.IS_IDENTIFIER_CHAR[ch]) {
          _base.state.pos++;
        } else if (ch === _charcodes.charCodes.backslash) {
          _base.state.pos += 2;
          if (_base.input.charCodeAt(_base.state.pos) === _charcodes.charCodes.leftCurlyBrace) {
            while (_base.state.pos < _base.input.length && _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.rightCurlyBrace) {
              _base.state.pos++;
            }
            _base.state.pos++;
          }
        } else {
          break;
        }
      }
    }
    exports.skipWord = skipWord;
  }
});

// ../../node_modules/sucrase/dist/parser/traverser/lval.js
var require_lval = __commonJS({
  "../../node_modules/sucrase/dist/parser/traverser/lval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _flow = require_flow();
    var _typescript = require_typescript();
    var _index = require_tokenizer();
    var _keywords = require_keywords();
    var _types = require_types();
    var _base = require_base();
    var _expression = require_expression();
    var _util = require_util();
    function parseSpread() {
      _index.next.call(void 0);
      _expression.parseMaybeAssign.call(void 0, false);
    }
    exports.parseSpread = parseSpread;
    function parseRest(isBlockScope) {
      _index.next.call(void 0);
      parseBindingAtom(isBlockScope);
    }
    exports.parseRest = parseRest;
    function parseBindingIdentifier(isBlockScope) {
      _expression.parseIdentifier.call(void 0);
      markPriorBindingIdentifier(isBlockScope);
    }
    exports.parseBindingIdentifier = parseBindingIdentifier;
    function parseImportedIdentifier() {
      _expression.parseIdentifier.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    }
    exports.parseImportedIdentifier = parseImportedIdentifier;
    function markPriorBindingIdentifier(isBlockScope) {
      let identifierRole;
      if (_base.state.scopeDepth === 0) {
        identifierRole = _index.IdentifierRole.TopLevelDeclaration;
      } else if (isBlockScope) {
        identifierRole = _index.IdentifierRole.BlockScopedDeclaration;
      } else {
        identifierRole = _index.IdentifierRole.FunctionScopedDeclaration;
      }
      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
    }
    exports.markPriorBindingIdentifier = markPriorBindingIdentifier;
    function parseBindingAtom(isBlockScope) {
      switch (_base.state.type) {
        case _types.TokenType._this: {
          const oldIsType = _index.pushTypeContext.call(void 0, 0);
          _index.next.call(void 0);
          _index.popTypeContext.call(void 0, oldIsType);
          return;
        }
        case _types.TokenType._yield:
        case _types.TokenType.name: {
          _base.state.type = _types.TokenType.name;
          parseBindingIdentifier(isBlockScope);
          return;
        }
        case _types.TokenType.bracketL: {
          _index.next.call(void 0);
          parseBindingList(
            _types.TokenType.bracketR,
            isBlockScope,
            true
            /* allowEmpty */
          );
          return;
        }
        case _types.TokenType.braceL:
          _expression.parseObj.call(void 0, true, isBlockScope);
          return;
        default:
          _util.unexpected.call(void 0);
      }
    }
    exports.parseBindingAtom = parseBindingAtom;
    function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {
      let first = true;
      let hasRemovedComma = false;
      const firstItemTokenIndex = _base.state.tokens.length;
      while (!_index.eat.call(void 0, close) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          _util.expect.call(void 0, _types.TokenType.comma);
          _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
          if (!hasRemovedComma && _base.state.tokens[firstItemTokenIndex].isType) {
            _base.state.tokens[_base.state.tokens.length - 1].isType = true;
            hasRemovedComma = true;
          }
        }
        if (allowEmpty && _index.match.call(void 0, _types.TokenType.comma)) {
        } else if (_index.eat.call(void 0, close)) {
          break;
        } else if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
          parseRest(isBlockScope);
          parseAssignableListItemTypes();
          _index.eat.call(void 0, _types.TokenType.comma);
          _util.expect.call(void 0, close);
          break;
        } else {
          parseAssignableListItem(allowModifiers, isBlockScope);
        }
      }
    }
    exports.parseBindingList = parseBindingList;
    function parseAssignableListItem(allowModifiers, isBlockScope) {
      if (allowModifiers) {
        _typescript.tsParseModifiers.call(void 0, [
          _keywords.ContextualKeyword._public,
          _keywords.ContextualKeyword._protected,
          _keywords.ContextualKeyword._private,
          _keywords.ContextualKeyword._readonly,
          _keywords.ContextualKeyword._override
        ]);
      }
      parseMaybeDefault(isBlockScope);
      parseAssignableListItemTypes();
      parseMaybeDefault(
        isBlockScope,
        true
        /* leftAlreadyParsed */
      );
    }
    function parseAssignableListItemTypes() {
      if (_base.isFlowEnabled) {
        _flow.flowParseAssignableListItemTypes.call(void 0);
      } else if (_base.isTypeScriptEnabled) {
        _typescript.tsParseAssignableListItemTypes.call(void 0);
      }
    }
    function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
      if (!leftAlreadyParsed) {
        parseBindingAtom(isBlockScope);
      }
      if (!_index.eat.call(void 0, _types.TokenType.eq)) {
        return;
      }
      const eqIndex = _base.state.tokens.length - 1;
      _expression.parseMaybeAssign.call(void 0);
      _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
    }
    exports.parseMaybeDefault = parseMaybeDefault;
  }
});

// ../../node_modules/sucrase/dist/parser/plugins/typescript.js
var require_typescript = __commonJS({
  "../../node_modules/sucrase/dist/parser/plugins/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_tokenizer();
    var _keywords = require_keywords();
    var _types = require_types();
    var _base = require_base();
    var _expression = require_expression();
    var _lval = require_lval();
    var _statement = require_statement();
    var _util = require_util();
    var _jsx = require_jsx();
    function tsIsIdentifier() {
      return _index.match.call(void 0, _types.TokenType.name);
    }
    function isLiteralPropertyName() {
      return _index.match.call(void 0, _types.TokenType.name) || Boolean(_base.state.type & _types.TokenType.IS_KEYWORD) || _index.match.call(void 0, _types.TokenType.string) || _index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.bigint) || _index.match.call(void 0, _types.TokenType.decimal);
    }
    function tsNextTokenCanFollowModifier() {
      const snapshot = _base.state.snapshot();
      _index.next.call(void 0);
      const canFollowModifier = (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.star) || _index.match.call(void 0, _types.TokenType.ellipsis) || _index.match.call(void 0, _types.TokenType.hash) || isLiteralPropertyName()) && !_util.hasPrecedingLineBreak.call(void 0);
      if (canFollowModifier) {
        return true;
      } else {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
      }
    }
    function tsParseModifiers(allowedModifiers) {
      while (true) {
        const modifier = tsParseModifier(allowedModifiers);
        if (modifier === null) {
          break;
        }
      }
    }
    exports.tsParseModifiers = tsParseModifiers;
    function tsParseModifier(allowedModifiers) {
      if (!_index.match.call(void 0, _types.TokenType.name)) {
        return null;
      }
      const modifier = _base.state.contextualKeyword;
      if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
        switch (modifier) {
          case _keywords.ContextualKeyword._readonly:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._readonly;
            break;
          case _keywords.ContextualKeyword._abstract:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
            break;
          case _keywords.ContextualKeyword._static:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
            break;
          case _keywords.ContextualKeyword._public:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._public;
            break;
          case _keywords.ContextualKeyword._private:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._private;
            break;
          case _keywords.ContextualKeyword._protected:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._protected;
            break;
          case _keywords.ContextualKeyword._override:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._override;
            break;
          case _keywords.ContextualKeyword._declare:
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
            break;
          default:
            break;
        }
        return modifier;
      }
      return null;
    }
    exports.tsParseModifier = tsParseModifier;
    function tsParseEntityName() {
      _expression.parseIdentifier.call(void 0);
      while (_index.eat.call(void 0, _types.TokenType.dot)) {
        _expression.parseIdentifier.call(void 0);
      }
    }
    function tsParseTypeReference() {
      tsParseEntityName();
      if (!_util.hasPrecedingLineBreak.call(void 0) && _index.match.call(void 0, _types.TokenType.lessThan)) {
        tsParseTypeArguments();
      }
    }
    function tsParseThisTypePredicate() {
      _index.next.call(void 0);
      tsParseTypeAnnotation();
    }
    function tsParseThisTypeNode() {
      _index.next.call(void 0);
    }
    function tsParseTypeQuery() {
      _util.expect.call(void 0, _types.TokenType._typeof);
      if (_index.match.call(void 0, _types.TokenType._import)) {
        tsParseImportType();
      } else {
        tsParseEntityName();
      }
      if (!_util.hasPrecedingLineBreak.call(void 0) && _index.match.call(void 0, _types.TokenType.lessThan)) {
        tsParseTypeArguments();
      }
    }
    function tsParseImportType() {
      _util.expect.call(void 0, _types.TokenType._import);
      _util.expect.call(void 0, _types.TokenType.parenL);
      _util.expect.call(void 0, _types.TokenType.string);
      _util.expect.call(void 0, _types.TokenType.parenR);
      if (_index.eat.call(void 0, _types.TokenType.dot)) {
        tsParseEntityName();
      }
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        tsParseTypeArguments();
      }
    }
    function tsParseTypeParameter() {
      _index.eat.call(void 0, _types.TokenType._const);
      const hadIn = _index.eat.call(void 0, _types.TokenType._in);
      const hadOut = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._out);
      _index.eat.call(void 0, _types.TokenType._const);
      if ((hadIn || hadOut) && !_index.match.call(void 0, _types.TokenType.name)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
      } else {
        _expression.parseIdentifier.call(void 0);
      }
      if (_index.eat.call(void 0, _types.TokenType._extends)) {
        tsParseType();
      }
      if (_index.eat.call(void 0, _types.TokenType.eq)) {
        tsParseType();
      }
    }
    function tsTryParseTypeParameters() {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        tsParseTypeParameters();
      }
    }
    exports.tsTryParseTypeParameters = tsTryParseTypeParameters;
    function tsParseTypeParameters() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
        _index.next.call(void 0);
      } else {
        _util.unexpected.call(void 0);
      }
      while (!_index.eat.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
        tsParseTypeParameter();
        _index.eat.call(void 0, _types.TokenType.comma);
      }
      _index.popTypeContext.call(void 0, oldIsType);
    }
    function tsFillSignature(returnToken) {
      const returnTokenRequired = returnToken === _types.TokenType.arrow;
      tsTryParseTypeParameters();
      _util.expect.call(void 0, _types.TokenType.parenL);
      _base.state.scopeDepth++;
      tsParseBindingListForSignature(
        false
        /* isBlockScope */
      );
      _base.state.scopeDepth--;
      if (returnTokenRequired) {
        tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (_index.match.call(void 0, returnToken)) {
        tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }
    function tsParseBindingListForSignature(isBlockScope) {
      _lval.parseBindingList.call(void 0, _types.TokenType.parenR, isBlockScope);
    }
    function tsParseTypeMemberSemicolon() {
      if (!_index.eat.call(void 0, _types.TokenType.comma)) {
        _util.semicolon.call(void 0);
      }
    }
    function tsParseSignatureMember() {
      tsFillSignature(_types.TokenType.colon);
      tsParseTypeMemberSemicolon();
    }
    function tsIsUnambiguouslyIndexSignature() {
      const snapshot = _base.state.snapshot();
      _index.next.call(void 0);
      const isIndexSignature = _index.eat.call(void 0, _types.TokenType.name) && _index.match.call(void 0, _types.TokenType.colon);
      _base.state.restoreFromSnapshot(snapshot);
      return isIndexSignature;
    }
    function tsTryParseIndexSignature() {
      if (!(_index.match.call(void 0, _types.TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {
        return false;
      }
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, _types.TokenType.bracketL);
      _expression.parseIdentifier.call(void 0);
      tsParseTypeAnnotation();
      _util.expect.call(void 0, _types.TokenType.bracketR);
      tsTryParseTypeAnnotation();
      tsParseTypeMemberSemicolon();
      _index.popTypeContext.call(void 0, oldIsType);
      return true;
    }
    function tsParsePropertyOrMethodSignature(isReadonly) {
      _index.eat.call(void 0, _types.TokenType.question);
      if (!isReadonly && (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan))) {
        tsFillSignature(_types.TokenType.colon);
        tsParseTypeMemberSemicolon();
      } else {
        tsTryParseTypeAnnotation();
        tsParseTypeMemberSemicolon();
      }
    }
    function tsParseTypeMember() {
      if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
        tsParseSignatureMember();
        return;
      }
      if (_index.match.call(void 0, _types.TokenType._new)) {
        _index.next.call(void 0);
        if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
          tsParseSignatureMember();
        } else {
          tsParsePropertyOrMethodSignature(false);
        }
        return;
      }
      const readonly = !!tsParseModifier([_keywords.ContextualKeyword._readonly]);
      const found = tsTryParseIndexSignature();
      if (found) {
        return;
      }
      if ((_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) && tsNextTokenCanFollowModifier()) {
      }
      _expression.parsePropertyName.call(
        void 0,
        -1
        /* Types don't need context IDs. */
      );
      tsParsePropertyOrMethodSignature(readonly);
    }
    function tsParseTypeLiteral() {
      tsParseObjectTypeMembers();
    }
    function tsParseObjectTypeMembers() {
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_index.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        tsParseTypeMember();
      }
    }
    function tsLookaheadIsStartOfMappedType() {
      const snapshot = _base.state.snapshot();
      const isStartOfMappedType = tsIsStartOfMappedType();
      _base.state.restoreFromSnapshot(snapshot);
      return isStartOfMappedType;
    }
    function tsIsStartOfMappedType() {
      _index.next.call(void 0);
      if (_index.eat.call(void 0, _types.TokenType.plus) || _index.eat.call(void 0, _types.TokenType.minus)) {
        return _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly);
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)) {
        _index.next.call(void 0);
      }
      if (!_index.match.call(void 0, _types.TokenType.bracketL)) {
        return false;
      }
      _index.next.call(void 0);
      if (!tsIsIdentifier()) {
        return false;
      }
      _index.next.call(void 0);
      return _index.match.call(void 0, _types.TokenType._in);
    }
    function tsParseMappedTypeParameter() {
      _expression.parseIdentifier.call(void 0);
      _util.expect.call(void 0, _types.TokenType._in);
      tsParseType();
    }
    function tsParseMappedType() {
      _util.expect.call(void 0, _types.TokenType.braceL);
      if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
        _index.next.call(void 0);
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._readonly);
      } else {
        _util.eatContextual.call(void 0, _keywords.ContextualKeyword._readonly);
      }
      _util.expect.call(void 0, _types.TokenType.bracketL);
      tsParseMappedTypeParameter();
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
        tsParseType();
      }
      _util.expect.call(void 0, _types.TokenType.bracketR);
      if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
        _index.next.call(void 0);
        _util.expect.call(void 0, _types.TokenType.question);
      } else {
        _index.eat.call(void 0, _types.TokenType.question);
      }
      tsTryParseType();
      _util.semicolon.call(void 0);
      _util.expect.call(void 0, _types.TokenType.braceR);
    }
    function tsParseTupleType() {
      _util.expect.call(void 0, _types.TokenType.bracketL);
      while (!_index.eat.call(void 0, _types.TokenType.bracketR) && !_base.state.error) {
        tsParseTupleElementType();
        _index.eat.call(void 0, _types.TokenType.comma);
      }
    }
    function tsParseTupleElementType() {
      if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
        tsParseType();
      } else {
        tsParseType();
        _index.eat.call(void 0, _types.TokenType.question);
      }
      if (_index.eat.call(void 0, _types.TokenType.colon)) {
        tsParseType();
      }
    }
    function tsParseParenthesizedType() {
      _util.expect.call(void 0, _types.TokenType.parenL);
      tsParseType();
      _util.expect.call(void 0, _types.TokenType.parenR);
    }
    function tsParseTemplateLiteralType() {
      _index.nextTemplateToken.call(void 0);
      _index.nextTemplateToken.call(void 0);
      while (!_index.match.call(void 0, _types.TokenType.backQuote) && !_base.state.error) {
        _util.expect.call(void 0, _types.TokenType.dollarBraceL);
        tsParseType();
        _index.nextTemplateToken.call(void 0);
        _index.nextTemplateToken.call(void 0);
      }
      _index.next.call(void 0);
    }
    var FunctionType;
    (function(FunctionType2) {
      const TSFunctionType = 0;
      FunctionType2[FunctionType2["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
      const TSConstructorType = TSFunctionType + 1;
      FunctionType2[FunctionType2["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
      const TSAbstractConstructorType = TSConstructorType + 1;
      FunctionType2[FunctionType2["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
    })(FunctionType || (FunctionType = {}));
    function tsParseFunctionOrConstructorType(type) {
      if (type === FunctionType.TSAbstractConstructorType) {
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._abstract);
      }
      if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {
        _util.expect.call(void 0, _types.TokenType._new);
      }
      const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
      _base.state.inDisallowConditionalTypesContext = false;
      tsFillSignature(_types.TokenType.arrow);
      _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    }
    function tsParseNonArrayType() {
      switch (_base.state.type) {
        case _types.TokenType.name:
          tsParseTypeReference();
          return;
        case _types.TokenType._void:
        case _types.TokenType._null:
          _index.next.call(void 0);
          return;
        case _types.TokenType.string:
        case _types.TokenType.num:
        case _types.TokenType.bigint:
        case _types.TokenType.decimal:
        case _types.TokenType._true:
        case _types.TokenType._false:
          _expression.parseLiteral.call(void 0);
          return;
        case _types.TokenType.minus:
          _index.next.call(void 0);
          _expression.parseLiteral.call(void 0);
          return;
        case _types.TokenType._this: {
          tsParseThisTypeNode();
          if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) && !_util.hasPrecedingLineBreak.call(void 0)) {
            tsParseThisTypePredicate();
          }
          return;
        }
        case _types.TokenType._typeof:
          tsParseTypeQuery();
          return;
        case _types.TokenType._import:
          tsParseImportType();
          return;
        case _types.TokenType.braceL:
          if (tsLookaheadIsStartOfMappedType()) {
            tsParseMappedType();
          } else {
            tsParseTypeLiteral();
          }
          return;
        case _types.TokenType.bracketL:
          tsParseTupleType();
          return;
        case _types.TokenType.parenL:
          tsParseParenthesizedType();
          return;
        case _types.TokenType.backQuote:
          tsParseTemplateLiteralType();
          return;
        default:
          if (_base.state.type & _types.TokenType.IS_KEYWORD) {
            _index.next.call(void 0);
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
            return;
          }
          break;
      }
      _util.unexpected.call(void 0);
    }
    function tsParseArrayTypeOrHigher() {
      tsParseNonArrayType();
      while (!_util.hasPrecedingLineBreak.call(void 0) && _index.eat.call(void 0, _types.TokenType.bracketL)) {
        if (!_index.eat.call(void 0, _types.TokenType.bracketR)) {
          tsParseType();
          _util.expect.call(void 0, _types.TokenType.bracketR);
        }
      }
    }
    function tsParseInferType() {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._infer);
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType._extends)) {
        const snapshot = _base.state.snapshot();
        _util.expect.call(void 0, _types.TokenType._extends);
        const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
        _base.state.inDisallowConditionalTypesContext = true;
        tsParseType();
        _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        if (_base.state.error || !_base.state.inDisallowConditionalTypesContext && _index.match.call(void 0, _types.TokenType.question)) {
          _base.state.restoreFromSnapshot(snapshot);
        }
      }
    }
    function tsParseTypeOperatorOrHigher() {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._keyof) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._unique) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)) {
        _index.next.call(void 0);
        tsParseTypeOperatorOrHigher();
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._infer)) {
        tsParseInferType();
      } else {
        const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
        _base.state.inDisallowConditionalTypesContext = false;
        tsParseArrayTypeOrHigher();
        _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    function tsParseIntersectionTypeOrHigher() {
      _index.eat.call(void 0, _types.TokenType.bitwiseAND);
      tsParseTypeOperatorOrHigher();
      if (_index.match.call(void 0, _types.TokenType.bitwiseAND)) {
        while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
          tsParseTypeOperatorOrHigher();
        }
      }
    }
    function tsParseUnionTypeOrHigher() {
      _index.eat.call(void 0, _types.TokenType.bitwiseOR);
      tsParseIntersectionTypeOrHigher();
      if (_index.match.call(void 0, _types.TokenType.bitwiseOR)) {
        while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
          tsParseIntersectionTypeOrHigher();
        }
      }
    }
    function tsIsStartOfFunctionType() {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        return true;
      }
      return _index.match.call(void 0, _types.TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
    }
    function tsSkipParameterStart() {
      if (_index.match.call(void 0, _types.TokenType.name) || _index.match.call(void 0, _types.TokenType._this)) {
        _index.next.call(void 0);
        return true;
      }
      if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {
        let depth = 1;
        _index.next.call(void 0);
        while (depth > 0 && !_base.state.error) {
          if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {
            depth++;
          } else if (_index.match.call(void 0, _types.TokenType.braceR) || _index.match.call(void 0, _types.TokenType.bracketR)) {
            depth--;
          }
          _index.next.call(void 0);
        }
        return true;
      }
      return false;
    }
    function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
      const snapshot = _base.state.snapshot();
      const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
      _base.state.restoreFromSnapshot(snapshot);
      return isUnambiguouslyStartOfFunctionType;
    }
    function tsIsUnambiguouslyStartOfFunctionType() {
      _index.next.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.parenR) || _index.match.call(void 0, _types.TokenType.ellipsis)) {
        return true;
      }
      if (tsSkipParameterStart()) {
        if (_index.match.call(void 0, _types.TokenType.colon) || _index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.question) || _index.match.call(void 0, _types.TokenType.eq)) {
          return true;
        }
        if (_index.match.call(void 0, _types.TokenType.parenR)) {
          _index.next.call(void 0);
          if (_index.match.call(void 0, _types.TokenType.arrow)) {
            return true;
          }
        }
      }
      return false;
    }
    function tsParseTypeOrTypePredicateAnnotation(returnToken) {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, returnToken);
      const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
      if (!finishedReturn) {
        tsParseType();
      }
      _index.popTypeContext.call(void 0, oldIsType);
    }
    function tsTryParseTypeOrTypePredicateAnnotation() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
      }
    }
    function tsTryParseTypeAnnotation() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        tsParseTypeAnnotation();
      }
    }
    exports.tsTryParseTypeAnnotation = tsTryParseTypeAnnotation;
    function tsTryParseType() {
      if (_index.eat.call(void 0, _types.TokenType.colon)) {
        tsParseType();
      }
    }
    function tsParseTypePredicateOrAssertsPrefix() {
      const snapshot = _base.state.snapshot();
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._asserts)) {
        _index.next.call(void 0);
        if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {
          tsParseType();
          return true;
        } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {
          _index.next.call(void 0);
          if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {
            tsParseType();
          }
          return true;
        } else {
          _base.state.restoreFromSnapshot(snapshot);
          return false;
        }
      } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {
        _index.next.call(void 0);
        if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) && !_util.hasPrecedingLineBreak.call(void 0)) {
          _index.next.call(void 0);
          tsParseType();
          return true;
        } else {
          _base.state.restoreFromSnapshot(snapshot);
          return false;
        }
      }
      return false;
    }
    function tsParseTypeAnnotation() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, _types.TokenType.colon);
      tsParseType();
      _index.popTypeContext.call(void 0, oldIsType);
    }
    exports.tsParseTypeAnnotation = tsParseTypeAnnotation;
    function tsParseType() {
      tsParseNonConditionalType();
      if (_base.state.inDisallowConditionalTypesContext || _util.hasPrecedingLineBreak.call(void 0) || !_index.eat.call(void 0, _types.TokenType._extends)) {
        return;
      }
      const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
      _base.state.inDisallowConditionalTypesContext = true;
      tsParseNonConditionalType();
      _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      _util.expect.call(void 0, _types.TokenType.question);
      tsParseType();
      _util.expect.call(void 0, _types.TokenType.colon);
      tsParseType();
    }
    exports.tsParseType = tsParseType;
    function isAbstractConstructorSignature() {
      return _util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) && _index.lookaheadType.call(void 0) === _types.TokenType._new;
    }
    function tsParseNonConditionalType() {
      if (tsIsStartOfFunctionType()) {
        tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
        return;
      }
      if (_index.match.call(void 0, _types.TokenType._new)) {
        tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
        return;
      } else if (isAbstractConstructorSignature()) {
        tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
        return;
      }
      tsParseUnionTypeOrHigher();
    }
    exports.tsParseNonConditionalType = tsParseNonConditionalType;
    function tsParseTypeAssertion() {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      tsParseType();
      _util.expect.call(void 0, _types.TokenType.greaterThan);
      _index.popTypeContext.call(void 0, oldIsType);
      _expression.parseMaybeUnary.call(void 0);
    }
    exports.tsParseTypeAssertion = tsParseTypeAssertion;
    function tsTryParseJSXTypeArgument() {
      if (_index.eat.call(void 0, _types.TokenType.jsxTagStart)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.typeParameterStart;
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
          tsParseType();
          _index.eat.call(void 0, _types.TokenType.comma);
        }
        _jsx.nextJSXTagToken.call(void 0);
        _index.popTypeContext.call(void 0, oldIsType);
      }
    }
    exports.tsTryParseJSXTypeArgument = tsTryParseJSXTypeArgument;
    function tsParseHeritageClause() {
      while (!_index.match.call(void 0, _types.TokenType.braceL) && !_base.state.error) {
        tsParseExpressionWithTypeArguments();
        _index.eat.call(void 0, _types.TokenType.comma);
      }
    }
    function tsParseExpressionWithTypeArguments() {
      tsParseEntityName();
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        tsParseTypeArguments();
      }
    }
    function tsParseInterfaceDeclaration() {
      _lval.parseBindingIdentifier.call(void 0, false);
      tsTryParseTypeParameters();
      if (_index.eat.call(void 0, _types.TokenType._extends)) {
        tsParseHeritageClause();
      }
      tsParseObjectTypeMembers();
    }
    function tsParseTypeAliasDeclaration() {
      _lval.parseBindingIdentifier.call(void 0, false);
      tsTryParseTypeParameters();
      _util.expect.call(void 0, _types.TokenType.eq);
      tsParseType();
      _util.semicolon.call(void 0);
    }
    function tsParseEnumMember() {
      if (_index.match.call(void 0, _types.TokenType.string)) {
        _expression.parseLiteral.call(void 0);
      } else {
        _expression.parseIdentifier.call(void 0);
      }
      if (_index.eat.call(void 0, _types.TokenType.eq)) {
        const eqIndex = _base.state.tokens.length - 1;
        _expression.parseMaybeAssign.call(void 0);
        _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
      }
    }
    function tsParseEnumDeclaration() {
      _lval.parseBindingIdentifier.call(void 0, false);
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_index.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        tsParseEnumMember();
        _index.eat.call(void 0, _types.TokenType.comma);
      }
    }
    function tsParseModuleBlock() {
      _util.expect.call(void 0, _types.TokenType.braceL);
      _statement.parseBlockBody.call(
        void 0,
        /* end */
        _types.TokenType.braceR
      );
    }
    function tsParseModuleOrNamespaceDeclaration() {
      _lval.parseBindingIdentifier.call(void 0, false);
      if (_index.eat.call(void 0, _types.TokenType.dot)) {
        tsParseModuleOrNamespaceDeclaration();
      } else {
        tsParseModuleBlock();
      }
    }
    function tsParseAmbientExternalModuleDeclaration() {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._global)) {
        _expression.parseIdentifier.call(void 0);
      } else if (_index.match.call(void 0, _types.TokenType.string)) {
        _expression.parseExprAtom.call(void 0);
      } else {
        _util.unexpected.call(void 0);
      }
      if (_index.match.call(void 0, _types.TokenType.braceL)) {
        tsParseModuleBlock();
      } else {
        _util.semicolon.call(void 0);
      }
    }
    function tsParseImportEqualsDeclaration() {
      _lval.parseImportedIdentifier.call(void 0);
      _util.expect.call(void 0, _types.TokenType.eq);
      tsParseModuleReference();
      _util.semicolon.call(void 0);
    }
    exports.tsParseImportEqualsDeclaration = tsParseImportEqualsDeclaration;
    function tsIsExternalModuleReference() {
      return _util.isContextual.call(void 0, _keywords.ContextualKeyword._require) && _index.lookaheadType.call(void 0) === _types.TokenType.parenL;
    }
    function tsParseModuleReference() {
      if (tsIsExternalModuleReference()) {
        tsParseExternalModuleReference();
      } else {
        tsParseEntityName();
      }
    }
    function tsParseExternalModuleReference() {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._require);
      _util.expect.call(void 0, _types.TokenType.parenL);
      if (!_index.match.call(void 0, _types.TokenType.string)) {
        _util.unexpected.call(void 0);
      }
      _expression.parseLiteral.call(void 0);
      _util.expect.call(void 0, _types.TokenType.parenR);
    }
    function tsTryParseDeclare() {
      if (_util.isLineTerminator.call(void 0)) {
        return false;
      }
      switch (_base.state.type) {
        case _types.TokenType._function: {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          _index.next.call(void 0);
          const functionStart = _base.state.start;
          _statement.parseFunction.call(
            void 0,
            functionStart,
            /* isStatement */
            true
          );
          _index.popTypeContext.call(void 0, oldIsType);
          return true;
        }
        case _types.TokenType._class: {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          _statement.parseClass.call(
            void 0,
            /* isStatement */
            true,
            /* optionalId */
            false
          );
          _index.popTypeContext.call(void 0, oldIsType);
          return true;
        }
        case _types.TokenType._const: {
          if (_index.match.call(void 0, _types.TokenType._const) && _util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
            const oldIsType = _index.pushTypeContext.call(void 0, 1);
            _util.expect.call(void 0, _types.TokenType._const);
            _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
            tsParseEnumDeclaration();
            _index.popTypeContext.call(void 0, oldIsType);
            return true;
          }
        }
        case _types.TokenType._var:
        case _types.TokenType._let: {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          _statement.parseVarStatement.call(void 0, _base.state.type !== _types.TokenType._var);
          _index.popTypeContext.call(void 0, oldIsType);
          return true;
        }
        case _types.TokenType.name: {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          const contextualKeyword = _base.state.contextualKeyword;
          let matched = false;
          if (contextualKeyword === _keywords.ContextualKeyword._global) {
            tsParseAmbientExternalModuleDeclaration();
            matched = true;
          } else {
            matched = tsParseDeclaration(
              contextualKeyword,
              /* isBeforeToken */
              true
            );
          }
          _index.popTypeContext.call(void 0, oldIsType);
          return matched;
        }
        default:
          return false;
      }
    }
    function tsTryParseExportDeclaration() {
      return tsParseDeclaration(
        _base.state.contextualKeyword,
        /* isBeforeToken */
        true
      );
    }
    function tsParseExpressionStatement(contextualKeyword) {
      switch (contextualKeyword) {
        case _keywords.ContextualKeyword._declare: {
          const declareTokenIndex = _base.state.tokens.length - 1;
          const matched = tsTryParseDeclare();
          if (matched) {
            _base.state.tokens[declareTokenIndex].type = _types.TokenType._declare;
            return true;
          }
          break;
        }
        case _keywords.ContextualKeyword._global:
          if (_index.match.call(void 0, _types.TokenType.braceL)) {
            tsParseModuleBlock();
            return true;
          }
          break;
        default:
          return tsParseDeclaration(
            contextualKeyword,
            /* isBeforeToken */
            false
          );
      }
      return false;
    }
    function tsParseDeclaration(contextualKeyword, isBeforeToken) {
      switch (contextualKeyword) {
        case _keywords.ContextualKeyword._abstract:
          if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType._class)) {
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
            _statement.parseClass.call(
              void 0,
              /* isStatement */
              true,
              /* optionalId */
              false
            );
            return true;
          }
          break;
        case _keywords.ContextualKeyword._enum:
          if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
            tsParseEnumDeclaration();
            return true;
          }
          break;
        case _keywords.ContextualKeyword._interface:
          if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
            const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
            tsParseInterfaceDeclaration();
            _index.popTypeContext.call(void 0, oldIsType);
            return true;
          }
          break;
        case _keywords.ContextualKeyword._module:
          if (tsCheckLineTerminator(isBeforeToken)) {
            if (_index.match.call(void 0, _types.TokenType.string)) {
              const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
              tsParseAmbientExternalModuleDeclaration();
              _index.popTypeContext.call(void 0, oldIsType);
              return true;
            } else if (_index.match.call(void 0, _types.TokenType.name)) {
              const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
              tsParseModuleOrNamespaceDeclaration();
              _index.popTypeContext.call(void 0, oldIsType);
              return true;
            }
          }
          break;
        case _keywords.ContextualKeyword._namespace:
          if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
            const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
            tsParseModuleOrNamespaceDeclaration();
            _index.popTypeContext.call(void 0, oldIsType);
            return true;
          }
          break;
        case _keywords.ContextualKeyword._type:
          if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
            const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
            tsParseTypeAliasDeclaration();
            _index.popTypeContext.call(void 0, oldIsType);
            return true;
          }
          break;
        default:
          break;
      }
      return false;
    }
    function tsCheckLineTerminator(isBeforeToken) {
      if (isBeforeToken) {
        _index.next.call(void 0);
        return true;
      } else {
        return !_util.isLineTerminator.call(void 0);
      }
    }
    function tsTryParseGenericAsyncArrowFunction() {
      const snapshot = _base.state.snapshot();
      tsParseTypeParameters();
      _statement.parseFunctionParams.call(void 0);
      tsTryParseTypeOrTypePredicateAnnotation();
      _util.expect.call(void 0, _types.TokenType.arrow);
      if (_base.state.error) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
      }
      _expression.parseFunctionBody.call(void 0, true);
      return true;
    }
    function tsParseTypeArgumentsWithPossibleBitshift() {
      if (_base.state.type === _types.TokenType.bitShiftL) {
        _base.state.pos -= 1;
        _index.finishToken.call(void 0, _types.TokenType.lessThan);
      }
      tsParseTypeArguments();
    }
    function tsParseTypeArguments() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, _types.TokenType.lessThan);
      while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
        tsParseType();
        _index.eat.call(void 0, _types.TokenType.comma);
      }
      if (!oldIsType) {
        _index.popTypeContext.call(void 0, oldIsType);
        _index.rescan_gt.call(void 0);
        _util.expect.call(void 0, _types.TokenType.greaterThan);
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
      } else {
        _util.expect.call(void 0, _types.TokenType.greaterThan);
        _index.popTypeContext.call(void 0, oldIsType);
      }
    }
    function tsIsDeclarationStart() {
      if (_index.match.call(void 0, _types.TokenType.name)) {
        switch (_base.state.contextualKeyword) {
          case _keywords.ContextualKeyword._abstract:
          case _keywords.ContextualKeyword._declare:
          case _keywords.ContextualKeyword._enum:
          case _keywords.ContextualKeyword._interface:
          case _keywords.ContextualKeyword._module:
          case _keywords.ContextualKeyword._namespace:
          case _keywords.ContextualKeyword._type:
            return true;
          default:
            break;
        }
      }
      return false;
    }
    exports.tsIsDeclarationStart = tsIsDeclarationStart;
    function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
      }
      if (!_index.match.call(void 0, _types.TokenType.braceL) && _util.isLineTerminator.call(void 0)) {
        let i = _base.state.tokens.length - 1;
        while (i >= 0 && (_base.state.tokens[i].start >= functionStart || _base.state.tokens[i].type === _types.TokenType._default || _base.state.tokens[i].type === _types.TokenType._export)) {
          _base.state.tokens[i].isType = true;
          i--;
        }
        return;
      }
      _expression.parseFunctionBody.call(void 0, false, funcContextId);
    }
    exports.tsParseFunctionBodyAndFinish = tsParseFunctionBodyAndFinish;
    function tsParseSubscript(startTokenIndex, noCalls, stopState) {
      if (!_util.hasPrecedingLineBreak.call(void 0) && _index.eat.call(void 0, _types.TokenType.bang)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.nonNullAssertion;
        return;
      }
      if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL)) {
        const snapshot = _base.state.snapshot();
        if (!noCalls && _expression.atPossibleAsync.call(void 0)) {
          const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
          if (asyncArrowFn) {
            return;
          }
        }
        tsParseTypeArgumentsWithPossibleBitshift();
        if (!noCalls && _index.eat.call(void 0, _types.TokenType.parenL)) {
          _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
          _expression.parseCallExpressionArguments.call(void 0);
        } else if (_index.match.call(void 0, _types.TokenType.backQuote)) {
          _expression.parseTemplate.call(void 0);
        } else if (
          // The remaining possible case is an instantiation expression, e.g.
          // Array<number> . Check for a few cases that would disqualify it and
          // cause us to bail out.
          // a<b>>c is not (a<b>)>c, but a<(b>>c)
          _base.state.type === _types.TokenType.greaterThan || // a<b>c is (a<b)>c
          _base.state.type !== _types.TokenType.parenL && Boolean(_base.state.type & _types.TokenType.IS_EXPRESSION_START) && !_util.hasPrecedingLineBreak.call(void 0)
        ) {
          _util.unexpected.call(void 0);
        }
        if (_base.state.error) {
          _base.state.restoreFromSnapshot(snapshot);
        } else {
          return;
        }
      } else if (!noCalls && _index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0) === _types.TokenType.lessThan) {
        _index.next.call(void 0);
        _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        tsParseTypeArguments();
        _util.expect.call(void 0, _types.TokenType.parenL);
        _expression.parseCallExpressionArguments.call(void 0);
      }
      _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
    }
    exports.tsParseSubscript = tsParseSubscript;
    function tsTryParseExport() {
      if (_index.eat.call(void 0, _types.TokenType._import)) {
        if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0) !== _types.TokenType.eq) {
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
        }
        tsParseImportEqualsDeclaration();
        return true;
      } else if (_index.eat.call(void 0, _types.TokenType.eq)) {
        _expression.parseExpression.call(void 0);
        _util.semicolon.call(void 0);
        return true;
      } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._namespace);
        _expression.parseIdentifier.call(void 0);
        _util.semicolon.call(void 0);
        return true;
      } else {
        if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
          const nextType = _index.lookaheadType.call(void 0);
          if (nextType === _types.TokenType.braceL || nextType === _types.TokenType.star) {
            _index.next.call(void 0);
          }
        }
        return false;
      }
    }
    exports.tsTryParseExport = tsTryParseExport;
    function tsParseImportSpecifier() {
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
        return;
      }
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
        _base.state.tokens[_base.state.tokens.length - 2].isType = true;
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        return;
      }
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
        _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
        return;
      }
      _expression.parseIdentifier.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
      _base.state.tokens[_base.state.tokens.length - 4].isType = true;
      _base.state.tokens[_base.state.tokens.length - 3].isType = true;
      _base.state.tokens[_base.state.tokens.length - 2].isType = true;
      _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    }
    exports.tsParseImportSpecifier = tsParseImportSpecifier;
    function tsParseExportSpecifier() {
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
        return;
      }
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
        _base.state.tokens[_base.state.tokens.length - 2].isType = true;
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        return;
      }
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
        _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
        return;
      }
      _expression.parseIdentifier.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
      _base.state.tokens[_base.state.tokens.length - 4].isType = true;
      _base.state.tokens[_base.state.tokens.length - 3].isType = true;
      _base.state.tokens[_base.state.tokens.length - 2].isType = true;
      _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    }
    exports.tsParseExportSpecifier = tsParseExportSpecifier;
    function tsTryParseExportDefaultExpression() {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) && _index.lookaheadType.call(void 0) === _types.TokenType._class) {
        _base.state.type = _types.TokenType._abstract;
        _index.next.call(void 0);
        _statement.parseClass.call(void 0, true, true);
        return true;
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 2);
        tsParseDeclaration(_keywords.ContextualKeyword._interface, true);
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      return false;
    }
    exports.tsTryParseExportDefaultExpression = tsTryParseExportDefaultExpression;
    function tsTryParseStatementContent() {
      if (_base.state.type === _types.TokenType._const) {
        const ahead = _index.lookaheadTypeAndKeyword.call(void 0);
        if (ahead.type === _types.TokenType.name && ahead.contextualKeyword === _keywords.ContextualKeyword._enum) {
          _util.expect.call(void 0, _types.TokenType._const);
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
          _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
          tsParseEnumDeclaration();
          return true;
        }
      }
      return false;
    }
    exports.tsTryParseStatementContent = tsTryParseStatementContent;
    function tsTryParseClassMemberWithIsStatic(isStatic) {
      const memberStartIndexAfterStatic = _base.state.tokens.length;
      tsParseModifiers([
        _keywords.ContextualKeyword._abstract,
        _keywords.ContextualKeyword._readonly,
        _keywords.ContextualKeyword._declare,
        _keywords.ContextualKeyword._static,
        _keywords.ContextualKeyword._override
      ]);
      const modifiersEndIndex = _base.state.tokens.length;
      const found = tsTryParseIndexSignature();
      if (found) {
        const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;
        for (let i = memberStartIndex; i < modifiersEndIndex; i++) {
          _base.state.tokens[i].isType = true;
        }
        return true;
      }
      return false;
    }
    exports.tsTryParseClassMemberWithIsStatic = tsTryParseClassMemberWithIsStatic;
    function tsParseIdentifierStatement(contextualKeyword) {
      const matched = tsParseExpressionStatement(contextualKeyword);
      if (!matched) {
        _util.semicolon.call(void 0);
      }
    }
    exports.tsParseIdentifierStatement = tsParseIdentifierStatement;
    function tsParseExportDeclaration() {
      const isDeclare = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._declare);
      if (isDeclare) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
      }
      let matchedDeclaration = false;
      if (_index.match.call(void 0, _types.TokenType.name)) {
        if (isDeclare) {
          const oldIsType = _index.pushTypeContext.call(void 0, 2);
          matchedDeclaration = tsTryParseExportDeclaration();
          _index.popTypeContext.call(void 0, oldIsType);
        } else {
          matchedDeclaration = tsTryParseExportDeclaration();
        }
      }
      if (!matchedDeclaration) {
        if (isDeclare) {
          const oldIsType = _index.pushTypeContext.call(void 0, 2);
          _statement.parseStatement.call(void 0, true);
          _index.popTypeContext.call(void 0, oldIsType);
        } else {
          _statement.parseStatement.call(void 0, true);
        }
      }
    }
    exports.tsParseExportDeclaration = tsParseExportDeclaration;
    function tsAfterParseClassSuper(hasSuper) {
      if (hasSuper && (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL))) {
        tsParseTypeArgumentsWithPossibleBitshift();
      }
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        tsParseHeritageClause();
        _index.popTypeContext.call(void 0, oldIsType);
      }
    }
    exports.tsAfterParseClassSuper = tsAfterParseClassSuper;
    function tsStartParseObjPropValue() {
      tsTryParseTypeParameters();
    }
    exports.tsStartParseObjPropValue = tsStartParseObjPropValue;
    function tsStartParseFunctionParams() {
      tsTryParseTypeParameters();
    }
    exports.tsStartParseFunctionParams = tsStartParseFunctionParams;
    function tsAfterParseVarHead() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      if (!_util.hasPrecedingLineBreak.call(void 0)) {
        _index.eat.call(void 0, _types.TokenType.bang);
      }
      tsTryParseTypeAnnotation();
      _index.popTypeContext.call(void 0, oldIsType);
    }
    exports.tsAfterParseVarHead = tsAfterParseVarHead;
    function tsStartParseAsyncArrowFromCallExpression() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        tsParseTypeAnnotation();
      }
    }
    exports.tsStartParseAsyncArrowFromCallExpression = tsStartParseAsyncArrowFromCallExpression;
    function tsParseMaybeAssign(noIn, isWithinParens) {
      if (_base.isJSXEnabled) {
        return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
      } else {
        return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
      }
    }
    exports.tsParseMaybeAssign = tsParseMaybeAssign;
    function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
      if (!_index.match.call(void 0, _types.TokenType.lessThan)) {
        return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
      }
      const snapshot = _base.state.snapshot();
      let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
      if (_base.state.error) {
        _base.state.restoreFromSnapshot(snapshot);
      } else {
        return wasArrow;
      }
      _base.state.type = _types.TokenType.typeParameterStart;
      tsParseTypeParameters();
      wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
      if (!wasArrow) {
        _util.unexpected.call(void 0);
      }
      return wasArrow;
    }
    exports.tsParseMaybeAssignWithJSX = tsParseMaybeAssignWithJSX;
    function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
      if (!_index.match.call(void 0, _types.TokenType.lessThan)) {
        return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
      }
      const snapshot = _base.state.snapshot();
      tsParseTypeParameters();
      const wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
      if (!wasArrow) {
        _util.unexpected.call(void 0);
      }
      if (_base.state.error) {
        _base.state.restoreFromSnapshot(snapshot);
      } else {
        return wasArrow;
      }
      return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    }
    exports.tsParseMaybeAssignWithoutJSX = tsParseMaybeAssignWithoutJSX;
    function tsParseArrow() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        const snapshot = _base.state.snapshot();
        tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
        if (_util.canInsertSemicolon.call(void 0))
          _util.unexpected.call(void 0);
        if (!_index.match.call(void 0, _types.TokenType.arrow))
          _util.unexpected.call(void 0);
        if (_base.state.error) {
          _base.state.restoreFromSnapshot(snapshot);
        }
      }
      return _index.eat.call(void 0, _types.TokenType.arrow);
    }
    exports.tsParseArrow = tsParseArrow;
    function tsParseAssignableListItemTypes() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _index.eat.call(void 0, _types.TokenType.question);
      tsTryParseTypeAnnotation();
      _index.popTypeContext.call(void 0, oldIsType);
    }
    exports.tsParseAssignableListItemTypes = tsParseAssignableListItemTypes;
    function tsParseMaybeDecoratorArguments() {
      if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL)) {
        tsParseTypeArgumentsWithPossibleBitshift();
      }
      _statement.baseParseMaybeDecoratorArguments.call(void 0);
    }
    exports.tsParseMaybeDecoratorArguments = tsParseMaybeDecoratorArguments;
  }
});

// ../../node_modules/sucrase/dist/parser/plugins/jsx/index.js
var require_jsx = __commonJS({
  "../../node_modules/sucrase/dist/parser/plugins/jsx/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_tokenizer();
    var _types = require_types();
    var _base = require_base();
    var _expression = require_expression();
    var _util = require_util();
    var _charcodes = require_charcodes();
    var _identifier = require_identifier();
    var _typescript = require_typescript();
    function jsxReadToken() {
      let sawNewline = false;
      let sawNonWhitespace = false;
      while (true) {
        if (_base.state.pos >= _base.input.length) {
          _util.unexpected.call(void 0, "Unterminated JSX contents");
          return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === _charcodes.charCodes.lessThan || ch === _charcodes.charCodes.leftCurlyBrace) {
          if (_base.state.pos === _base.state.start) {
            if (ch === _charcodes.charCodes.lessThan) {
              _base.state.pos++;
              _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);
              return;
            }
            _index.getTokenFromCode.call(void 0, ch);
            return;
          }
          if (sawNewline && !sawNonWhitespace) {
            _index.finishToken.call(void 0, _types.TokenType.jsxEmptyText);
          } else {
            _index.finishToken.call(void 0, _types.TokenType.jsxText);
          }
          return;
        }
        if (ch === _charcodes.charCodes.lineFeed) {
          sawNewline = true;
        } else if (ch !== _charcodes.charCodes.space && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.tab) {
          sawNonWhitespace = true;
        }
        _base.state.pos++;
      }
    }
    function jsxReadString(quote) {
      _base.state.pos++;
      for (; ; ) {
        if (_base.state.pos >= _base.input.length) {
          _util.unexpected.call(void 0, "Unterminated string constant");
          return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === quote) {
          _base.state.pos++;
          break;
        }
        _base.state.pos++;
      }
      _index.finishToken.call(void 0, _types.TokenType.string);
    }
    function jsxReadWord() {
      let ch;
      do {
        if (_base.state.pos > _base.input.length) {
          _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
          return;
        }
        ch = _base.input.charCodeAt(++_base.state.pos);
      } while (_identifier.IS_IDENTIFIER_CHAR[ch] || ch === _charcodes.charCodes.dash);
      _index.finishToken.call(void 0, _types.TokenType.jsxName);
    }
    function jsxParseIdentifier() {
      nextJSXTagToken();
    }
    function jsxParseNamespacedName(identifierRole) {
      jsxParseIdentifier();
      if (!_index.eat.call(void 0, _types.TokenType.colon)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
        return;
      }
      jsxParseIdentifier();
    }
    function jsxParseElementName() {
      const firstTokenIndex = _base.state.tokens.length;
      jsxParseNamespacedName(_index.IdentifierRole.Access);
      let hadDot = false;
      while (_index.match.call(void 0, _types.TokenType.dot)) {
        hadDot = true;
        nextJSXTagToken();
        jsxParseIdentifier();
      }
      if (!hadDot) {
        const firstToken = _base.state.tokens[firstTokenIndex];
        const firstChar = _base.input.charCodeAt(firstToken.start);
        if (firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ) {
          firstToken.identifierRole = null;
        }
      }
    }
    function jsxParseAttributeValue() {
      switch (_base.state.type) {
        case _types.TokenType.braceL:
          _index.next.call(void 0);
          _expression.parseExpression.call(void 0);
          nextJSXTagToken();
          return;
        case _types.TokenType.jsxTagStart:
          jsxParseElement();
          nextJSXTagToken();
          return;
        case _types.TokenType.string:
          nextJSXTagToken();
          return;
        default:
          _util.unexpected.call(void 0, "JSX value should be either an expression or a quoted JSX text");
      }
    }
    function jsxParseSpreadChild() {
      _util.expect.call(void 0, _types.TokenType.ellipsis);
      _expression.parseExpression.call(void 0);
    }
    function jsxParseOpeningElement(initialTokenIndex) {
      if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
        return false;
      }
      jsxParseElementName();
      if (_base.isTypeScriptEnabled) {
        _typescript.tsTryParseJSXTypeArgument.call(void 0);
      }
      let hasSeenPropSpread = false;
      while (!_index.match.call(void 0, _types.TokenType.slash) && !_index.match.call(void 0, _types.TokenType.jsxTagEnd) && !_base.state.error) {
        if (_index.eat.call(void 0, _types.TokenType.braceL)) {
          hasSeenPropSpread = true;
          _util.expect.call(void 0, _types.TokenType.ellipsis);
          _expression.parseMaybeAssign.call(void 0);
          nextJSXTagToken();
          continue;
        }
        if (hasSeenPropSpread && _base.state.end - _base.state.start === 3 && _base.input.charCodeAt(_base.state.start) === _charcodes.charCodes.lowercaseK && _base.input.charCodeAt(_base.state.start + 1) === _charcodes.charCodes.lowercaseE && _base.input.charCodeAt(_base.state.start + 2) === _charcodes.charCodes.lowercaseY) {
          _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.KeyAfterPropSpread;
        }
        jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);
        if (_index.match.call(void 0, _types.TokenType.eq)) {
          nextJSXTagToken();
          jsxParseAttributeValue();
        }
      }
      const isSelfClosing = _index.match.call(void 0, _types.TokenType.slash);
      if (isSelfClosing) {
        nextJSXTagToken();
      }
      return isSelfClosing;
    }
    function jsxParseClosingElement() {
      if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
        return;
      }
      jsxParseElementName();
    }
    function jsxParseElementAt() {
      const initialTokenIndex = _base.state.tokens.length - 1;
      _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.NoChildren;
      let numExplicitChildren = 0;
      const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);
      if (!isSelfClosing) {
        nextJSXExprToken();
        while (true) {
          switch (_base.state.type) {
            case _types.TokenType.jsxTagStart:
              nextJSXTagToken();
              if (_index.match.call(void 0, _types.TokenType.slash)) {
                nextJSXTagToken();
                jsxParseClosingElement();
                if (_base.state.tokens[initialTokenIndex].jsxRole !== _index.JSXRole.KeyAfterPropSpread) {
                  if (numExplicitChildren === 1) {
                    _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.OneChild;
                  } else if (numExplicitChildren > 1) {
                    _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.StaticChildren;
                  }
                }
                return;
              }
              numExplicitChildren++;
              jsxParseElementAt();
              nextJSXExprToken();
              break;
            case _types.TokenType.jsxText:
              numExplicitChildren++;
              nextJSXExprToken();
              break;
            case _types.TokenType.jsxEmptyText:
              nextJSXExprToken();
              break;
            case _types.TokenType.braceL:
              _index.next.call(void 0);
              if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
                jsxParseSpreadChild();
                nextJSXExprToken();
                numExplicitChildren += 2;
              } else {
                if (!_index.match.call(void 0, _types.TokenType.braceR)) {
                  numExplicitChildren++;
                  _expression.parseExpression.call(void 0);
                }
                nextJSXExprToken();
              }
              break;
            default:
              _util.unexpected.call(void 0);
              return;
          }
        }
      }
    }
    function jsxParseElement() {
      nextJSXTagToken();
      jsxParseElementAt();
    }
    exports.jsxParseElement = jsxParseElement;
    function nextJSXTagToken() {
      _base.state.tokens.push(new (0, _index.Token)());
      _index.skipSpace.call(void 0);
      _base.state.start = _base.state.pos;
      const code = _base.input.charCodeAt(_base.state.pos);
      if (_identifier.IS_IDENTIFIER_START[code]) {
        jsxReadWord();
      } else if (code === _charcodes.charCodes.quotationMark || code === _charcodes.charCodes.apostrophe) {
        jsxReadString(code);
      } else {
        ++_base.state.pos;
        switch (code) {
          case _charcodes.charCodes.greaterThan:
            _index.finishToken.call(void 0, _types.TokenType.jsxTagEnd);
            break;
          case _charcodes.charCodes.lessThan:
            _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);
            break;
          case _charcodes.charCodes.slash:
            _index.finishToken.call(void 0, _types.TokenType.slash);
            break;
          case _charcodes.charCodes.equalsTo:
            _index.finishToken.call(void 0, _types.TokenType.eq);
            break;
          case _charcodes.charCodes.leftCurlyBrace:
            _index.finishToken.call(void 0, _types.TokenType.braceL);
            break;
          case _charcodes.charCodes.dot:
            _index.finishToken.call(void 0, _types.TokenType.dot);
            break;
          case _charcodes.charCodes.colon:
            _index.finishToken.call(void 0, _types.TokenType.colon);
            break;
          default:
            _util.unexpected.call(void 0);
        }
      }
    }
    exports.nextJSXTagToken = nextJSXTagToken;
    function nextJSXExprToken() {
      _base.state.tokens.push(new (0, _index.Token)());
      _base.state.start = _base.state.pos;
      jsxReadToken();
    }
  }
});

// ../../node_modules/sucrase/dist/parser/plugins/types.js
var require_types2 = __commonJS({
  "../../node_modules/sucrase/dist/parser/plugins/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_tokenizer();
    var _types = require_types();
    var _base = require_base();
    var _expression = require_expression();
    var _flow = require_flow();
    var _typescript = require_typescript();
    function typedParseConditional(noIn) {
      if (_index.match.call(void 0, _types.TokenType.question)) {
        const nextType = _index.lookaheadType.call(void 0);
        if (nextType === _types.TokenType.colon || nextType === _types.TokenType.comma || nextType === _types.TokenType.parenR) {
          return;
        }
      }
      _expression.baseParseConditional.call(void 0, noIn);
    }
    exports.typedParseConditional = typedParseConditional;
    function typedParseParenItem() {
      _index.eatTypeToken.call(void 0, _types.TokenType.question);
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        if (_base.isTypeScriptEnabled) {
          _typescript.tsParseTypeAnnotation.call(void 0);
        } else if (_base.isFlowEnabled) {
          _flow.flowParseTypeAnnotation.call(void 0);
        }
      }
    }
    exports.typedParseParenItem = typedParseParenItem;
  }
});

// ../../node_modules/sucrase/dist/parser/traverser/expression.js
var require_expression = __commonJS({
  "../../node_modules/sucrase/dist/parser/traverser/expression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _flow = require_flow();
    var _index = require_jsx();
    var _types = require_types2();
    var _typescript = require_typescript();
    var _index3 = require_tokenizer();
    var _keywords = require_keywords();
    var _state = require_state();
    var _types3 = require_types();
    var _charcodes = require_charcodes();
    var _identifier = require_identifier();
    var _base = require_base();
    var _lval = require_lval();
    var _statement = require_statement();
    var _util = require_util();
    var StopState = class {
      constructor(stop) {
        this.stop = stop;
      }
    };
    exports.StopState = StopState;
    function parseExpression(noIn = false) {
      parseMaybeAssign(noIn);
      if (_index3.match.call(void 0, _types3.TokenType.comma)) {
        while (_index3.eat.call(void 0, _types3.TokenType.comma)) {
          parseMaybeAssign(noIn);
        }
      }
    }
    exports.parseExpression = parseExpression;
    function parseMaybeAssign(noIn = false, isWithinParens = false) {
      if (_base.isTypeScriptEnabled) {
        return _typescript.tsParseMaybeAssign.call(void 0, noIn, isWithinParens);
      } else if (_base.isFlowEnabled) {
        return _flow.flowParseMaybeAssign.call(void 0, noIn, isWithinParens);
      } else {
        return baseParseMaybeAssign(noIn, isWithinParens);
      }
    }
    exports.parseMaybeAssign = parseMaybeAssign;
    function baseParseMaybeAssign(noIn, isWithinParens) {
      if (_index3.match.call(void 0, _types3.TokenType._yield)) {
        parseYield();
        return false;
      }
      if (_index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.name) || _index3.match.call(void 0, _types3.TokenType._yield)) {
        _base.state.potentialArrowAt = _base.state.start;
      }
      const wasArrow = parseMaybeConditional(noIn);
      if (isWithinParens) {
        parseParenItem();
      }
      if (_base.state.type & _types3.TokenType.IS_ASSIGN) {
        _index3.next.call(void 0);
        parseMaybeAssign(noIn);
        return false;
      }
      return wasArrow;
    }
    exports.baseParseMaybeAssign = baseParseMaybeAssign;
    function parseMaybeConditional(noIn) {
      const wasArrow = parseExprOps(noIn);
      if (wasArrow) {
        return true;
      }
      parseConditional(noIn);
      return false;
    }
    function parseConditional(noIn) {
      if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
        _types.typedParseConditional.call(void 0, noIn);
      } else {
        baseParseConditional(noIn);
      }
    }
    function baseParseConditional(noIn) {
      if (_index3.eat.call(void 0, _types3.TokenType.question)) {
        parseMaybeAssign();
        _util.expect.call(void 0, _types3.TokenType.colon);
        parseMaybeAssign(noIn);
      }
    }
    exports.baseParseConditional = baseParseConditional;
    function parseExprOps(noIn) {
      const startTokenIndex = _base.state.tokens.length;
      const wasArrow = parseMaybeUnary();
      if (wasArrow) {
        return true;
      }
      parseExprOp(startTokenIndex, -1, noIn);
      return false;
    }
    function parseExprOp(startTokenIndex, minPrec, noIn) {
      if (_base.isTypeScriptEnabled && (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec && !_util.hasPrecedingLineBreak.call(void 0) && (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as) || _util.eatContextual.call(void 0, _keywords.ContextualKeyword._satisfies))) {
        const oldIsType = _index3.pushTypeContext.call(void 0, 1);
        _typescript.tsParseType.call(void 0);
        _index3.popTypeContext.call(void 0, oldIsType);
        _index3.rescan_gt.call(void 0);
        parseExprOp(startTokenIndex, minPrec, noIn);
        return;
      }
      const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;
      if (prec > 0 && (!noIn || !_index3.match.call(void 0, _types3.TokenType._in))) {
        if (prec > minPrec) {
          const op = _base.state.type;
          _index3.next.call(void 0);
          if (op === _types3.TokenType.nullishCoalescing) {
            _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
          }
          const rhsStartTokenIndex = _base.state.tokens.length;
          parseMaybeUnary();
          parseExprOp(rhsStartTokenIndex, op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
          if (op === _types3.TokenType.nullishCoalescing) {
            _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
            _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
          }
          parseExprOp(startTokenIndex, minPrec, noIn);
        }
      }
    }
    function parseMaybeUnary() {
      if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && _index3.eat.call(void 0, _types3.TokenType.lessThan)) {
        _typescript.tsParseTypeAssertion.call(void 0);
        return false;
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._module) && _index3.lookaheadCharCode.call(void 0) === _charcodes.charCodes.leftCurlyBrace && !_util.hasFollowingLineBreak.call(void 0)) {
        parseModuleExpression();
        return false;
      }
      if (_base.state.type & _types3.TokenType.IS_PREFIX) {
        _index3.next.call(void 0);
        parseMaybeUnary();
        return false;
      }
      const wasArrow = parseExprSubscripts();
      if (wasArrow) {
        return true;
      }
      while (_base.state.type & _types3.TokenType.IS_POSTFIX && !_util.canInsertSemicolon.call(void 0)) {
        if (_base.state.type === _types3.TokenType.preIncDec) {
          _base.state.type = _types3.TokenType.postIncDec;
        }
        _index3.next.call(void 0);
      }
      return false;
    }
    exports.parseMaybeUnary = parseMaybeUnary;
    function parseExprSubscripts() {
      const startTokenIndex = _base.state.tokens.length;
      const wasArrow = parseExprAtom();
      if (wasArrow) {
        return true;
      }
      parseSubscripts(startTokenIndex);
      if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) {
        _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;
      }
      return false;
    }
    exports.parseExprSubscripts = parseExprSubscripts;
    function parseSubscripts(startTokenIndex, noCalls = false) {
      if (_base.isFlowEnabled) {
        _flow.flowParseSubscripts.call(void 0, startTokenIndex, noCalls);
      } else {
        baseParseSubscripts(startTokenIndex, noCalls);
      }
    }
    function baseParseSubscripts(startTokenIndex, noCalls = false) {
      const stopState = new StopState(false);
      do {
        parseSubscript(startTokenIndex, noCalls, stopState);
      } while (!stopState.stop && !_base.state.error);
    }
    exports.baseParseSubscripts = baseParseSubscripts;
    function parseSubscript(startTokenIndex, noCalls, stopState) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
      } else if (_base.isFlowEnabled) {
        _flow.flowParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
      } else {
        baseParseSubscript(startTokenIndex, noCalls, stopState);
      }
    }
    function baseParseSubscript(startTokenIndex, noCalls, stopState) {
      if (!noCalls && _index3.eat.call(void 0, _types3.TokenType.doubleColon)) {
        parseNoCallExpr();
        stopState.stop = true;
        parseSubscripts(startTokenIndex, noCalls);
      } else if (_index3.match.call(void 0, _types3.TokenType.questionDot)) {
        _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
        if (noCalls && _index3.lookaheadType.call(void 0) === _types3.TokenType.parenL) {
          stopState.stop = true;
          return;
        }
        _index3.next.call(void 0);
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
          parseExpression();
          _util.expect.call(void 0, _types3.TokenType.bracketR);
        } else if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
          parseCallExpressionArguments();
        } else {
          parseMaybePrivateName();
        }
      } else if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        parseMaybePrivateName();
      } else if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        parseExpression();
        _util.expect.call(void 0, _types3.TokenType.bracketR);
      } else if (!noCalls && _index3.match.call(void 0, _types3.TokenType.parenL)) {
        if (atPossibleAsync()) {
          const snapshot = _base.state.snapshot();
          const asyncStartTokenIndex = _base.state.tokens.length;
          _index3.next.call(void 0);
          _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
          const callContextId = _base.getNextContextId.call(void 0);
          _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
          parseCallExpressionArguments();
          _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
          if (shouldParseAsyncArrow()) {
            _base.state.restoreFromSnapshot(snapshot);
            stopState.stop = true;
            _base.state.scopeDepth++;
            _statement.parseFunctionParams.call(void 0);
            parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
          }
        } else {
          _index3.next.call(void 0);
          _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
          const callContextId = _base.getNextContextId.call(void 0);
          _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
          parseCallExpressionArguments();
          _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
        }
      } else if (_index3.match.call(void 0, _types3.TokenType.backQuote)) {
        parseTemplate();
      } else {
        stopState.stop = true;
      }
    }
    exports.baseParseSubscript = baseParseSubscript;
    function atPossibleAsync() {
      return _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && !_util.canInsertSemicolon.call(void 0);
    }
    exports.atPossibleAsync = atPossibleAsync;
    function parseCallExpressionArguments() {
      let first = true;
      while (!_index3.eat.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          _util.expect.call(void 0, _types3.TokenType.comma);
          if (_index3.eat.call(void 0, _types3.TokenType.parenR)) {
            break;
          }
        }
        parseExprListItem(false);
      }
    }
    exports.parseCallExpressionArguments = parseCallExpressionArguments;
    function shouldParseAsyncArrow() {
      return _index3.match.call(void 0, _types3.TokenType.colon) || _index3.match.call(void 0, _types3.TokenType.arrow);
    }
    function parseAsyncArrowFromCallExpression(startTokenIndex) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsStartParseAsyncArrowFromCallExpression.call(void 0);
      } else if (_base.isFlowEnabled) {
        _flow.flowStartParseAsyncArrowFromCallExpression.call(void 0);
      }
      _util.expect.call(void 0, _types3.TokenType.arrow);
      parseArrowExpression(startTokenIndex);
    }
    function parseNoCallExpr() {
      const startTokenIndex = _base.state.tokens.length;
      parseExprAtom();
      parseSubscripts(startTokenIndex, true);
    }
    function parseExprAtom() {
      if (_index3.eat.call(void 0, _types3.TokenType.modulo)) {
        parseIdentifier();
        return false;
      }
      if (_index3.match.call(void 0, _types3.TokenType.jsxText) || _index3.match.call(void 0, _types3.TokenType.jsxEmptyText)) {
        parseLiteral();
        return false;
      } else if (_index3.match.call(void 0, _types3.TokenType.lessThan) && _base.isJSXEnabled) {
        _base.state.type = _types3.TokenType.jsxTagStart;
        _index.jsxParseElement.call(void 0);
        _index3.next.call(void 0);
        return false;
      }
      const canBeArrow = _base.state.potentialArrowAt === _base.state.start;
      switch (_base.state.type) {
        case _types3.TokenType.slash:
        case _types3.TokenType.assign:
          _index3.retokenizeSlashAsRegex.call(void 0);
        case _types3.TokenType._super:
        case _types3.TokenType._this:
        case _types3.TokenType.regexp:
        case _types3.TokenType.num:
        case _types3.TokenType.bigint:
        case _types3.TokenType.decimal:
        case _types3.TokenType.string:
        case _types3.TokenType._null:
        case _types3.TokenType._true:
        case _types3.TokenType._false:
          _index3.next.call(void 0);
          return false;
        case _types3.TokenType._import:
          _index3.next.call(void 0);
          if (_index3.match.call(void 0, _types3.TokenType.dot)) {
            _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
            _index3.next.call(void 0);
            parseIdentifier();
          }
          return false;
        case _types3.TokenType.name: {
          const startTokenIndex = _base.state.tokens.length;
          const functionStart = _base.state.start;
          const contextualKeyword = _base.state.contextualKeyword;
          parseIdentifier();
          if (contextualKeyword === _keywords.ContextualKeyword._await) {
            parseAwait();
            return false;
          } else if (contextualKeyword === _keywords.ContextualKeyword._async && _index3.match.call(void 0, _types3.TokenType._function) && !_util.canInsertSemicolon.call(void 0)) {
            _index3.next.call(void 0);
            _statement.parseFunction.call(void 0, functionStart, false);
            return false;
          } else if (canBeArrow && contextualKeyword === _keywords.ContextualKeyword._async && !_util.canInsertSemicolon.call(void 0) && _index3.match.call(void 0, _types3.TokenType.name)) {
            _base.state.scopeDepth++;
            _lval.parseBindingIdentifier.call(void 0, false);
            _util.expect.call(void 0, _types3.TokenType.arrow);
            parseArrowExpression(startTokenIndex);
            return true;
          } else if (_index3.match.call(void 0, _types3.TokenType._do) && !_util.canInsertSemicolon.call(void 0)) {
            _index3.next.call(void 0);
            _statement.parseBlock.call(void 0);
            return false;
          }
          if (canBeArrow && !_util.canInsertSemicolon.call(void 0) && _index3.match.call(void 0, _types3.TokenType.arrow)) {
            _base.state.scopeDepth++;
            _lval.markPriorBindingIdentifier.call(void 0, false);
            _util.expect.call(void 0, _types3.TokenType.arrow);
            parseArrowExpression(startTokenIndex);
            return true;
          }
          _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.Access;
          return false;
        }
        case _types3.TokenType._do: {
          _index3.next.call(void 0);
          _statement.parseBlock.call(void 0);
          return false;
        }
        case _types3.TokenType.parenL: {
          const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
          return wasArrow;
        }
        case _types3.TokenType.bracketL:
          _index3.next.call(void 0);
          parseExprList(_types3.TokenType.bracketR, true);
          return false;
        case _types3.TokenType.braceL:
          parseObj(false, false);
          return false;
        case _types3.TokenType._function:
          parseFunctionExpression();
          return false;
        case _types3.TokenType.at:
          _statement.parseDecorators.call(void 0);
        case _types3.TokenType._class:
          _statement.parseClass.call(void 0, false);
          return false;
        case _types3.TokenType._new:
          parseNew();
          return false;
        case _types3.TokenType.backQuote:
          parseTemplate();
          return false;
        case _types3.TokenType.doubleColon: {
          _index3.next.call(void 0);
          parseNoCallExpr();
          return false;
        }
        case _types3.TokenType.hash: {
          const code = _index3.lookaheadCharCode.call(void 0);
          if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) {
            parseMaybePrivateName();
          } else {
            _index3.next.call(void 0);
          }
          return false;
        }
        default:
          _util.unexpected.call(void 0);
          return false;
      }
    }
    exports.parseExprAtom = parseExprAtom;
    function parseMaybePrivateName() {
      _index3.eat.call(void 0, _types3.TokenType.hash);
      parseIdentifier();
    }
    function parseFunctionExpression() {
      const functionStart = _base.state.start;
      parseIdentifier();
      if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
        parseIdentifier();
      }
      _statement.parseFunction.call(void 0, functionStart, false);
    }
    function parseLiteral() {
      _index3.next.call(void 0);
    }
    exports.parseLiteral = parseLiteral;
    function parseParenExpression() {
      _util.expect.call(void 0, _types3.TokenType.parenL);
      parseExpression();
      _util.expect.call(void 0, _types3.TokenType.parenR);
    }
    exports.parseParenExpression = parseParenExpression;
    function parseParenAndDistinguishExpression(canBeArrow) {
      const snapshot = _base.state.snapshot();
      const startTokenIndex = _base.state.tokens.length;
      _util.expect.call(void 0, _types3.TokenType.parenL);
      let first = true;
      while (!_index3.match.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          _util.expect.call(void 0, _types3.TokenType.comma);
          if (_index3.match.call(void 0, _types3.TokenType.parenR)) {
            break;
          }
        }
        if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
          _lval.parseRest.call(
            void 0,
            false
            /* isBlockScope */
          );
          parseParenItem();
          break;
        } else {
          parseMaybeAssign(false, true);
        }
      }
      _util.expect.call(void 0, _types3.TokenType.parenR);
      if (canBeArrow && shouldParseArrow()) {
        const wasArrow = parseArrow();
        if (wasArrow) {
          _base.state.restoreFromSnapshot(snapshot);
          _base.state.scopeDepth++;
          _statement.parseFunctionParams.call(void 0);
          parseArrow();
          parseArrowExpression(startTokenIndex);
          if (_base.state.error) {
            _base.state.restoreFromSnapshot(snapshot);
            parseParenAndDistinguishExpression(false);
            return false;
          }
          return true;
        }
      }
      return false;
    }
    function shouldParseArrow() {
      return _index3.match.call(void 0, _types3.TokenType.colon) || !_util.canInsertSemicolon.call(void 0);
    }
    function parseArrow() {
      if (_base.isTypeScriptEnabled) {
        return _typescript.tsParseArrow.call(void 0);
      } else if (_base.isFlowEnabled) {
        return _flow.flowParseArrow.call(void 0);
      } else {
        return _index3.eat.call(void 0, _types3.TokenType.arrow);
      }
    }
    exports.parseArrow = parseArrow;
    function parseParenItem() {
      if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
        _types.typedParseParenItem.call(void 0);
      }
    }
    function parseNew() {
      _util.expect.call(void 0, _types3.TokenType._new);
      if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
        parseIdentifier();
        return;
      }
      parseNewCallee();
      if (_base.isFlowEnabled) {
        _flow.flowStartParseNewArguments.call(void 0);
      }
      if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
        parseExprList(_types3.TokenType.parenR);
      }
    }
    function parseNewCallee() {
      parseNoCallExpr();
      _index3.eat.call(void 0, _types3.TokenType.questionDot);
    }
    function parseTemplate() {
      _index3.nextTemplateToken.call(void 0);
      _index3.nextTemplateToken.call(void 0);
      while (!_index3.match.call(void 0, _types3.TokenType.backQuote) && !_base.state.error) {
        _util.expect.call(void 0, _types3.TokenType.dollarBraceL);
        parseExpression();
        _index3.nextTemplateToken.call(void 0);
        _index3.nextTemplateToken.call(void 0);
      }
      _index3.next.call(void 0);
    }
    exports.parseTemplate = parseTemplate;
    function parseObj(isPattern, isBlockScope) {
      const contextId = _base.getNextContextId.call(void 0);
      let first = true;
      _index3.next.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
      while (!_index3.eat.call(void 0, _types3.TokenType.braceR) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          _util.expect.call(void 0, _types3.TokenType.comma);
          if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
            break;
          }
        }
        let isGenerator = false;
        if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
          const previousIndex = _base.state.tokens.length;
          _lval.parseSpread.call(void 0);
          if (isPattern) {
            if (_base.state.tokens.length === previousIndex + 2) {
              _lval.markPriorBindingIdentifier.call(void 0, isBlockScope);
            }
            if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
              break;
            }
          }
          continue;
        }
        if (!isPattern) {
          isGenerator = _index3.eat.call(void 0, _types3.TokenType.star);
        }
        if (!isPattern && _util.isContextual.call(void 0, _keywords.ContextualKeyword._async)) {
          if (isGenerator)
            _util.unexpected.call(void 0);
          parseIdentifier();
          if (_index3.match.call(void 0, _types3.TokenType.colon) || _index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.braceR) || _index3.match.call(void 0, _types3.TokenType.eq) || _index3.match.call(void 0, _types3.TokenType.comma)) {
          } else {
            if (_index3.match.call(void 0, _types3.TokenType.star)) {
              _index3.next.call(void 0);
              isGenerator = true;
            }
            parsePropertyName(contextId);
          }
        } else {
          parsePropertyName(contextId);
        }
        parseObjPropValue(isPattern, isBlockScope, contextId);
      }
      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
    }
    exports.parseObj = parseObj;
    function isGetterOrSetterMethod(isPattern) {
      return !isPattern && (_index3.match.call(void 0, _types3.TokenType.string) || // get "string"() {}
      _index3.match.call(void 0, _types3.TokenType.num) || // get 1() {}
      _index3.match.call(void 0, _types3.TokenType.bracketL) || // get ["string"]() {}
      _index3.match.call(void 0, _types3.TokenType.name) || // get foo() {}
      !!(_base.state.type & _types3.TokenType.IS_KEYWORD));
    }
    function parseObjectMethod(isPattern, objectContextId) {
      const functionStart = _base.state.start;
      if (_index3.match.call(void 0, _types3.TokenType.parenL)) {
        if (isPattern)
          _util.unexpected.call(void 0);
        parseMethod(
          functionStart,
          /* isConstructor */
          false
        );
        return true;
      }
      if (isGetterOrSetterMethod(isPattern)) {
        parsePropertyName(objectContextId);
        parseMethod(
          functionStart,
          /* isConstructor */
          false
        );
        return true;
      }
      return false;
    }
    function parseObjectProperty(isPattern, isBlockScope) {
      if (_index3.eat.call(void 0, _types3.TokenType.colon)) {
        if (isPattern) {
          _lval.parseMaybeDefault.call(void 0, isBlockScope);
        } else {
          parseMaybeAssign(false);
        }
        return;
      }
      let identifierRole;
      if (isPattern) {
        if (_base.state.scopeDepth === 0) {
          identifierRole = _index3.IdentifierRole.ObjectShorthandTopLevelDeclaration;
        } else if (isBlockScope) {
          identifierRole = _index3.IdentifierRole.ObjectShorthandBlockScopedDeclaration;
        } else {
          identifierRole = _index3.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
        }
      } else {
        identifierRole = _index3.IdentifierRole.ObjectShorthand;
      }
      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
      _lval.parseMaybeDefault.call(void 0, isBlockScope, true);
    }
    function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsStartParseObjPropValue.call(void 0);
      } else if (_base.isFlowEnabled) {
        _flow.flowStartParseObjPropValue.call(void 0);
      }
      const wasMethod = parseObjectMethod(isPattern, objectContextId);
      if (!wasMethod) {
        parseObjectProperty(isPattern, isBlockScope);
      }
    }
    function parsePropertyName(objectContextId) {
      if (_base.isFlowEnabled) {
        _flow.flowParseVariance.call(void 0);
      }
      if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
        _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
        parseMaybeAssign();
        _util.expect.call(void 0, _types3.TokenType.bracketR);
        _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
      } else {
        if (_index3.match.call(void 0, _types3.TokenType.num) || _index3.match.call(void 0, _types3.TokenType.string) || _index3.match.call(void 0, _types3.TokenType.bigint) || _index3.match.call(void 0, _types3.TokenType.decimal)) {
          parseExprAtom();
        } else {
          parseMaybePrivateName();
        }
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectKey;
        _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
      }
    }
    exports.parsePropertyName = parsePropertyName;
    function parseMethod(functionStart, isConstructor) {
      const funcContextId = _base.getNextContextId.call(void 0);
      _base.state.scopeDepth++;
      const startTokenIndex = _base.state.tokens.length;
      const allowModifiers = isConstructor;
      _statement.parseFunctionParams.call(void 0, allowModifiers, funcContextId);
      parseFunctionBodyAndFinish(functionStart, funcContextId);
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
      _base.state.scopeDepth--;
    }
    exports.parseMethod = parseMethod;
    function parseArrowExpression(startTokenIndex) {
      parseFunctionBody(true);
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
      _base.state.scopeDepth--;
    }
    exports.parseArrowExpression = parseArrowExpression;
    function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseFunctionBodyAndFinish.call(void 0, functionStart, funcContextId);
      } else if (_base.isFlowEnabled) {
        _flow.flowParseFunctionBodyAndFinish.call(void 0, funcContextId);
      } else {
        parseFunctionBody(false, funcContextId);
      }
    }
    exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;
    function parseFunctionBody(allowExpression, funcContextId = 0) {
      const isExpression = allowExpression && !_index3.match.call(void 0, _types3.TokenType.braceL);
      if (isExpression) {
        parseMaybeAssign();
      } else {
        _statement.parseBlock.call(void 0, true, funcContextId);
      }
    }
    exports.parseFunctionBody = parseFunctionBody;
    function parseExprList(close, allowEmpty = false) {
      let first = true;
      while (!_index3.eat.call(void 0, close) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          _util.expect.call(void 0, _types3.TokenType.comma);
          if (_index3.eat.call(void 0, close))
            break;
        }
        parseExprListItem(allowEmpty);
      }
    }
    function parseExprListItem(allowEmpty) {
      if (allowEmpty && _index3.match.call(void 0, _types3.TokenType.comma)) {
      } else if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
        _lval.parseSpread.call(void 0);
        parseParenItem();
      } else if (_index3.match.call(void 0, _types3.TokenType.question)) {
        _index3.next.call(void 0);
      } else {
        parseMaybeAssign(false, true);
      }
    }
    function parseIdentifier() {
      _index3.next.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
    }
    exports.parseIdentifier = parseIdentifier;
    function parseAwait() {
      parseMaybeUnary();
    }
    function parseYield() {
      _index3.next.call(void 0);
      if (!_index3.match.call(void 0, _types3.TokenType.semi) && !_util.canInsertSemicolon.call(void 0)) {
        _index3.eat.call(void 0, _types3.TokenType.star);
        parseMaybeAssign();
      }
    }
    function parseModuleExpression() {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);
      _util.expect.call(void 0, _types3.TokenType.braceL);
      _statement.parseBlockBody.call(void 0, _types3.TokenType.braceR);
    }
  }
});

// ../../node_modules/sucrase/dist/parser/plugins/flow.js
var require_flow = __commonJS({
  "../../node_modules/sucrase/dist/parser/plugins/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_tokenizer();
    var _keywords = require_keywords();
    var _types = require_types();
    var _base = require_base();
    var _expression = require_expression();
    var _statement = require_statement();
    var _util = require_util();
    function isMaybeDefaultImport(lookahead) {
      return (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from;
    }
    function flowParseTypeInitialiser(tok) {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, tok || _types.TokenType.colon);
      flowParseType();
      _index.popTypeContext.call(void 0, oldIsType);
    }
    function flowParsePredicate() {
      _util.expect.call(void 0, _types.TokenType.modulo);
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);
      if (_index.eat.call(void 0, _types.TokenType.parenL)) {
        _expression.parseExpression.call(void 0);
        _util.expect.call(void 0, _types.TokenType.parenR);
      }
    }
    function flowParseTypeAndPredicateInitialiser() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, _types.TokenType.colon);
      if (_index.match.call(void 0, _types.TokenType.modulo)) {
        flowParsePredicate();
      } else {
        flowParseType();
        if (_index.match.call(void 0, _types.TokenType.modulo)) {
          flowParsePredicate();
        }
      }
      _index.popTypeContext.call(void 0, oldIsType);
    }
    function flowParseDeclareClass() {
      _index.next.call(void 0);
      flowParseInterfaceish(
        /* isClass */
        true
      );
    }
    function flowParseDeclareFunction() {
      _index.next.call(void 0);
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
      }
      _util.expect.call(void 0, _types.TokenType.parenL);
      flowParseFunctionTypeParams();
      _util.expect.call(void 0, _types.TokenType.parenR);
      flowParseTypeAndPredicateInitialiser();
      _util.semicolon.call(void 0);
    }
    function flowParseDeclare() {
      if (_index.match.call(void 0, _types.TokenType._class)) {
        flowParseDeclareClass();
      } else if (_index.match.call(void 0, _types.TokenType._function)) {
        flowParseDeclareFunction();
      } else if (_index.match.call(void 0, _types.TokenType._var)) {
        flowParseDeclareVariable();
      } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {
        if (_index.eat.call(void 0, _types.TokenType.dot)) {
          flowParseDeclareModuleExports();
        } else {
          flowParseDeclareModule();
        }
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
        flowParseDeclareTypeAlias();
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
        flowParseDeclareOpaqueType();
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
        flowParseDeclareInterface();
      } else if (_index.match.call(void 0, _types.TokenType._export)) {
        flowParseDeclareExportDeclaration();
      } else {
        _util.unexpected.call(void 0);
      }
    }
    function flowParseDeclareVariable() {
      _index.next.call(void 0);
      flowParseTypeAnnotatableIdentifier();
      _util.semicolon.call(void 0);
    }
    function flowParseDeclareModule() {
      if (_index.match.call(void 0, _types.TokenType.string)) {
        _expression.parseExprAtom.call(void 0);
      } else {
        _expression.parseIdentifier.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        if (_index.match.call(void 0, _types.TokenType._import)) {
          _index.next.call(void 0);
          _statement.parseImport.call(void 0);
        } else {
          _util.unexpected.call(void 0);
        }
      }
      _util.expect.call(void 0, _types.TokenType.braceR);
    }
    function flowParseDeclareExportDeclaration() {
      _util.expect.call(void 0, _types.TokenType._export);
      if (_index.eat.call(void 0, _types.TokenType._default)) {
        if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {
          flowParseDeclare();
        } else {
          flowParseType();
          _util.semicolon.call(void 0);
        }
      } else if (_index.match.call(void 0, _types.TokenType._var) || // declare export var ...
      _index.match.call(void 0, _types.TokenType._function) || // declare export function ...
      _index.match.call(void 0, _types.TokenType._class) || // declare export class ...
      _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
        flowParseDeclare();
      } else if (_index.match.call(void 0, _types.TokenType.star) || // declare export * from ''
      _index.match.call(void 0, _types.TokenType.braceL) || // declare export {} ...
      _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || // declare export interface ...
      _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || // declare export type ...
      _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
        _statement.parseExport.call(void 0);
      } else {
        _util.unexpected.call(void 0);
      }
    }
    function flowParseDeclareModuleExports() {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._exports);
      flowParseTypeAnnotation();
      _util.semicolon.call(void 0);
    }
    function flowParseDeclareTypeAlias() {
      _index.next.call(void 0);
      flowParseTypeAlias();
    }
    function flowParseDeclareOpaqueType() {
      _index.next.call(void 0);
      flowParseOpaqueType(true);
    }
    function flowParseDeclareInterface() {
      _index.next.call(void 0);
      flowParseInterfaceish();
    }
    function flowParseInterfaceish(isClass = false) {
      flowParseRestrictedIdentifier();
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
      }
      if (_index.eat.call(void 0, _types.TokenType._extends)) {
        do {
          flowParseInterfaceExtends();
        } while (!isClass && _index.eat.call(void 0, _types.TokenType.comma));
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._mixins)) {
        _index.next.call(void 0);
        do {
          flowParseInterfaceExtends();
        } while (_index.eat.call(void 0, _types.TokenType.comma));
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
        _index.next.call(void 0);
        do {
          flowParseInterfaceExtends();
        } while (_index.eat.call(void 0, _types.TokenType.comma));
      }
      flowParseObjectType(isClass, false, isClass);
    }
    function flowParseInterfaceExtends() {
      flowParseQualifiedTypeIdentifier(false);
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    }
    function flowParseInterface() {
      flowParseInterfaceish();
    }
    function flowParseRestrictedIdentifier() {
      _expression.parseIdentifier.call(void 0);
    }
    function flowParseTypeAlias() {
      flowParseRestrictedIdentifier();
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
      }
      flowParseTypeInitialiser(_types.TokenType.eq);
      _util.semicolon.call(void 0);
    }
    function flowParseOpaqueType(declare) {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
      flowParseRestrictedIdentifier();
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
      }
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        flowParseTypeInitialiser(_types.TokenType.colon);
      }
      if (!declare) {
        flowParseTypeInitialiser(_types.TokenType.eq);
      }
      _util.semicolon.call(void 0);
    }
    function flowParseTypeParameter() {
      flowParseVariance();
      flowParseTypeAnnotatableIdentifier();
      if (_index.eat.call(void 0, _types.TokenType.eq)) {
        flowParseType();
      }
    }
    function flowParseTypeParameterDeclaration() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
        _index.next.call(void 0);
      } else {
        _util.unexpected.call(void 0);
      }
      do {
        flowParseTypeParameter();
        if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
          _util.expect.call(void 0, _types.TokenType.comma);
        }
      } while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error);
      _util.expect.call(void 0, _types.TokenType.greaterThan);
      _index.popTypeContext.call(void 0, oldIsType);
    }
    exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;
    function flowParseTypeParameterInstantiation() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _util.expect.call(void 0, _types.TokenType.lessThan);
      while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
        flowParseType();
        if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
          _util.expect.call(void 0, _types.TokenType.comma);
        }
      }
      _util.expect.call(void 0, _types.TokenType.greaterThan);
      _index.popTypeContext.call(void 0, oldIsType);
    }
    function flowParseInterfaceType() {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._interface);
      if (_index.eat.call(void 0, _types.TokenType._extends)) {
        do {
          flowParseInterfaceExtends();
        } while (_index.eat.call(void 0, _types.TokenType.comma));
      }
      flowParseObjectType(false, false, false);
    }
    function flowParseObjectPropertyKey() {
      if (_index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.string)) {
        _expression.parseExprAtom.call(void 0);
      } else {
        _expression.parseIdentifier.call(void 0);
      }
    }
    function flowParseObjectTypeIndexer() {
      if (_index.lookaheadType.call(void 0) === _types.TokenType.colon) {
        flowParseObjectPropertyKey();
        flowParseTypeInitialiser();
      } else {
        flowParseType();
      }
      _util.expect.call(void 0, _types.TokenType.bracketR);
      flowParseTypeInitialiser();
    }
    function flowParseObjectTypeInternalSlot() {
      flowParseObjectPropertyKey();
      _util.expect.call(void 0, _types.TokenType.bracketR);
      _util.expect.call(void 0, _types.TokenType.bracketR);
      if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
        flowParseObjectTypeMethodish();
      } else {
        _index.eat.call(void 0, _types.TokenType.question);
        flowParseTypeInitialiser();
      }
    }
    function flowParseObjectTypeMethodish() {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
      }
      _util.expect.call(void 0, _types.TokenType.parenL);
      while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
        flowParseFunctionTypeParam();
        if (!_index.match.call(void 0, _types.TokenType.parenR)) {
          _util.expect.call(void 0, _types.TokenType.comma);
        }
      }
      if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
        flowParseFunctionTypeParam();
      }
      _util.expect.call(void 0, _types.TokenType.parenR);
      flowParseTypeInitialiser();
    }
    function flowParseObjectTypeCallProperty() {
      flowParseObjectTypeMethodish();
    }
    function flowParseObjectType(allowStatic, allowExact, allowProto) {
      let endDelim;
      if (allowExact && _index.match.call(void 0, _types.TokenType.braceBarL)) {
        _util.expect.call(void 0, _types.TokenType.braceBarL);
        endDelim = _types.TokenType.braceBarR;
      } else {
        _util.expect.call(void 0, _types.TokenType.braceL);
        endDelim = _types.TokenType.braceR;
      }
      while (!_index.match.call(void 0, endDelim) && !_base.state.error) {
        if (allowProto && _util.isContextual.call(void 0, _keywords.ContextualKeyword._proto)) {
          const lookahead = _index.lookaheadType.call(void 0);
          if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
            _index.next.call(void 0);
            allowStatic = false;
          }
        }
        if (allowStatic && _util.isContextual.call(void 0, _keywords.ContextualKeyword._static)) {
          const lookahead = _index.lookaheadType.call(void 0);
          if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
            _index.next.call(void 0);
          }
        }
        flowParseVariance();
        if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
          if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
            flowParseObjectTypeInternalSlot();
          } else {
            flowParseObjectTypeIndexer();
          }
        } else if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
          flowParseObjectTypeCallProperty();
        } else {
          if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) {
            const lookahead = _index.lookaheadType.call(void 0);
            if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {
              _index.next.call(void 0);
            }
          }
          flowParseObjectTypeProperty();
        }
        flowObjectTypeSemicolon();
      }
      _util.expect.call(void 0, endDelim);
    }
    function flowParseObjectTypeProperty() {
      if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
        _util.expect.call(void 0, _types.TokenType.ellipsis);
        if (!_index.eat.call(void 0, _types.TokenType.comma)) {
          _index.eat.call(void 0, _types.TokenType.semi);
        }
        if (_index.match.call(void 0, _types.TokenType.braceR)) {
          return;
        }
        flowParseType();
      } else {
        flowParseObjectPropertyKey();
        if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
          flowParseObjectTypeMethodish();
        } else {
          _index.eat.call(void 0, _types.TokenType.question);
          flowParseTypeInitialiser();
        }
      }
    }
    function flowObjectTypeSemicolon() {
      if (!_index.eat.call(void 0, _types.TokenType.semi) && !_index.eat.call(void 0, _types.TokenType.comma) && !_index.match.call(void 0, _types.TokenType.braceR) && !_index.match.call(void 0, _types.TokenType.braceBarR)) {
        _util.unexpected.call(void 0);
      }
    }
    function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
      if (!initialIdAlreadyParsed) {
        _expression.parseIdentifier.call(void 0);
      }
      while (_index.eat.call(void 0, _types.TokenType.dot)) {
        _expression.parseIdentifier.call(void 0);
      }
    }
    function flowParseGenericType() {
      flowParseQualifiedTypeIdentifier(true);
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    }
    function flowParseTypeofType() {
      _util.expect.call(void 0, _types.TokenType._typeof);
      flowParsePrimaryType();
    }
    function flowParseTupleType() {
      _util.expect.call(void 0, _types.TokenType.bracketL);
      while (_base.state.pos < _base.input.length && !_index.match.call(void 0, _types.TokenType.bracketR)) {
        flowParseType();
        if (_index.match.call(void 0, _types.TokenType.bracketR)) {
          break;
        }
        _util.expect.call(void 0, _types.TokenType.comma);
      }
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
    function flowParseFunctionTypeParam() {
      const lookahead = _index.lookaheadType.call(void 0);
      if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
        _expression.parseIdentifier.call(void 0);
        _index.eat.call(void 0, _types.TokenType.question);
        flowParseTypeInitialiser();
      } else {
        flowParseType();
      }
    }
    function flowParseFunctionTypeParams() {
      while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
        flowParseFunctionTypeParam();
        if (!_index.match.call(void 0, _types.TokenType.parenR)) {
          _util.expect.call(void 0, _types.TokenType.comma);
        }
      }
      if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
        flowParseFunctionTypeParam();
      }
    }
    function flowParsePrimaryType() {
      let isGroupedType = false;
      const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
      switch (_base.state.type) {
        case _types.TokenType.name: {
          if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
            flowParseInterfaceType();
            return;
          }
          _expression.parseIdentifier.call(void 0);
          flowParseGenericType();
          return;
        }
        case _types.TokenType.braceL:
          flowParseObjectType(false, false, false);
          return;
        case _types.TokenType.braceBarL:
          flowParseObjectType(false, true, false);
          return;
        case _types.TokenType.bracketL:
          flowParseTupleType();
          return;
        case _types.TokenType.lessThan:
          flowParseTypeParameterDeclaration();
          _util.expect.call(void 0, _types.TokenType.parenL);
          flowParseFunctionTypeParams();
          _util.expect.call(void 0, _types.TokenType.parenR);
          _util.expect.call(void 0, _types.TokenType.arrow);
          flowParseType();
          return;
        case _types.TokenType.parenL:
          _index.next.call(void 0);
          if (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis)) {
            if (_index.match.call(void 0, _types.TokenType.name)) {
              const token = _index.lookaheadType.call(void 0);
              isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            _base.state.noAnonFunctionType = false;
            flowParseType();
            _base.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (_base.state.noAnonFunctionType || !(_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.parenR) && _index.lookaheadType.call(void 0) === _types.TokenType.arrow)) {
              _util.expect.call(void 0, _types.TokenType.parenR);
              return;
            } else {
              _index.eat.call(void 0, _types.TokenType.comma);
            }
          }
          flowParseFunctionTypeParams();
          _util.expect.call(void 0, _types.TokenType.parenR);
          _util.expect.call(void 0, _types.TokenType.arrow);
          flowParseType();
          return;
        case _types.TokenType.minus:
          _index.next.call(void 0);
          _expression.parseLiteral.call(void 0);
          return;
        case _types.TokenType.string:
        case _types.TokenType.num:
        case _types.TokenType._true:
        case _types.TokenType._false:
        case _types.TokenType._null:
        case _types.TokenType._this:
        case _types.TokenType._void:
        case _types.TokenType.star:
          _index.next.call(void 0);
          return;
        default:
          if (_base.state.type === _types.TokenType._typeof) {
            flowParseTypeofType();
            return;
          } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
            _index.next.call(void 0);
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
            return;
          }
      }
      _util.unexpected.call(void 0);
    }
    function flowParsePostfixType() {
      flowParsePrimaryType();
      while (!_util.canInsertSemicolon.call(void 0) && (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.questionDot))) {
        _index.eat.call(void 0, _types.TokenType.questionDot);
        _util.expect.call(void 0, _types.TokenType.bracketL);
        if (_index.eat.call(void 0, _types.TokenType.bracketR)) {
        } else {
          flowParseType();
          _util.expect.call(void 0, _types.TokenType.bracketR);
        }
      }
    }
    function flowParsePrefixType() {
      if (_index.eat.call(void 0, _types.TokenType.question)) {
        flowParsePrefixType();
      } else {
        flowParsePostfixType();
      }
    }
    function flowParseAnonFunctionWithoutParens() {
      flowParsePrefixType();
      if (!_base.state.noAnonFunctionType && _index.eat.call(void 0, _types.TokenType.arrow)) {
        flowParseType();
      }
    }
    function flowParseIntersectionType() {
      _index.eat.call(void 0, _types.TokenType.bitwiseAND);
      flowParseAnonFunctionWithoutParens();
      while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
        flowParseAnonFunctionWithoutParens();
      }
    }
    function flowParseUnionType() {
      _index.eat.call(void 0, _types.TokenType.bitwiseOR);
      flowParseIntersectionType();
      while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
        flowParseIntersectionType();
      }
    }
    function flowParseType() {
      flowParseUnionType();
    }
    function flowParseTypeAnnotation() {
      flowParseTypeInitialiser();
    }
    exports.flowParseTypeAnnotation = flowParseTypeAnnotation;
    function flowParseTypeAnnotatableIdentifier() {
      _expression.parseIdentifier.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        flowParseTypeAnnotation();
      }
    }
    function flowParseVariance() {
      if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
        _index.next.call(void 0);
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
      }
    }
    exports.flowParseVariance = flowParseVariance;
    function flowParseFunctionBodyAndFinish(funcContextId) {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        flowParseTypeAndPredicateInitialiser();
      }
      _expression.parseFunctionBody.call(void 0, false, funcContextId);
    }
    exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;
    function flowParseSubscript(startTokenIndex, noCalls, stopState) {
      if (_index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0) === _types.TokenType.lessThan) {
        if (noCalls) {
          stopState.stop = true;
          return;
        }
        _index.next.call(void 0);
        flowParseTypeParameterInstantiation();
        _util.expect.call(void 0, _types.TokenType.parenL);
        _expression.parseCallExpressionArguments.call(void 0);
        return;
      } else if (!noCalls && _index.match.call(void 0, _types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        flowParseTypeParameterInstantiation();
        _util.expect.call(void 0, _types.TokenType.parenL);
        _expression.parseCallExpressionArguments.call(void 0);
        if (_base.state.error) {
          _base.state.restoreFromSnapshot(snapshot);
        } else {
          return;
        }
      }
      _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
    }
    exports.flowParseSubscript = flowParseSubscript;
    function flowStartParseNewArguments() {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        flowParseTypeParameterInstantiation();
        if (_base.state.error) {
          _base.state.restoreFromSnapshot(snapshot);
        }
      }
    }
    exports.flowStartParseNewArguments = flowStartParseNewArguments;
    function flowTryParseStatement() {
      if (_index.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
        const oldIsType = _index.pushTypeContext.call(void 0, 0);
        _index.next.call(void 0);
        flowParseInterface();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
        flowParseEnumDeclaration();
        return true;
      }
      return false;
    }
    exports.flowTryParseStatement = flowTryParseStatement;
    function flowTryParseExportDefaultExpression() {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
        flowParseEnumDeclaration();
        return true;
      }
      return false;
    }
    exports.flowTryParseExportDefaultExpression = flowTryParseExportDefaultExpression;
    function flowParseIdentifierStatement(contextualKeyword) {
      if (contextualKeyword === _keywords.ContextualKeyword._declare) {
        if (_index.match.call(void 0, _types.TokenType._class) || _index.match.call(void 0, _types.TokenType.name) || _index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._var) || _index.match.call(void 0, _types.TokenType._export)) {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          flowParseDeclare();
          _index.popTypeContext.call(void 0, oldIsType);
        }
      } else if (_index.match.call(void 0, _types.TokenType.name)) {
        if (contextualKeyword === _keywords.ContextualKeyword._interface) {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          flowParseInterface();
          _index.popTypeContext.call(void 0, oldIsType);
        } else if (contextualKeyword === _keywords.ContextualKeyword._type) {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          flowParseTypeAlias();
          _index.popTypeContext.call(void 0, oldIsType);
        } else if (contextualKeyword === _keywords.ContextualKeyword._opaque) {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          flowParseOpaqueType(false);
          _index.popTypeContext.call(void 0, oldIsType);
        }
      }
      _util.semicolon.call(void 0);
    }
    exports.flowParseIdentifierStatement = flowParseIdentifierStatement;
    function flowShouldParseExportDeclaration() {
      return _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._enum);
    }
    exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;
    function flowShouldDisallowExportDefaultSpecifier() {
      return _index.match.call(void 0, _types.TokenType.name) && (_base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.contextualKeyword === _keywords.ContextualKeyword._interface || _base.state.contextualKeyword === _keywords.ContextualKeyword._opaque || _base.state.contextualKeyword === _keywords.ContextualKeyword._enum);
    }
    exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;
    function flowParseExportDeclaration() {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        _index.next.call(void 0);
        if (_index.match.call(void 0, _types.TokenType.braceL)) {
          _statement.parseExportSpecifiers.call(void 0);
          _statement.parseExportFrom.call(void 0);
        } else {
          flowParseTypeAlias();
        }
        _index.popTypeContext.call(void 0, oldIsType);
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        _index.next.call(void 0);
        flowParseOpaqueType(false);
        _index.popTypeContext.call(void 0, oldIsType);
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        _index.next.call(void 0);
        flowParseInterface();
        _index.popTypeContext.call(void 0, oldIsType);
      } else {
        _statement.parseStatement.call(void 0, true);
      }
    }
    exports.flowParseExportDeclaration = flowParseExportDeclaration;
    function flowShouldParseExportStar() {
      return _index.match.call(void 0, _types.TokenType.star) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0) === _types.TokenType.star;
    }
    exports.flowShouldParseExportStar = flowShouldParseExportStar;
    function flowParseExportStar() {
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._type)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 2);
        _statement.baseParseExportStar.call(void 0);
        _index.popTypeContext.call(void 0, oldIsType);
      } else {
        _statement.baseParseExportStar.call(void 0);
      }
    }
    exports.flowParseExportStar = flowParseExportStar;
    function flowAfterParseClassSuper(hasSuper) {
      if (hasSuper && _index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 0);
        _index.next.call(void 0);
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
        do {
          flowParseRestrictedIdentifier();
          if (_index.match.call(void 0, _types.TokenType.lessThan)) {
            flowParseTypeParameterInstantiation();
          }
        } while (_index.eat.call(void 0, _types.TokenType.comma));
        _index.popTypeContext.call(void 0, oldIsType);
      }
    }
    exports.flowAfterParseClassSuper = flowAfterParseClassSuper;
    function flowStartParseObjPropValue() {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
        if (!_index.match.call(void 0, _types.TokenType.parenL))
          _util.unexpected.call(void 0);
      }
    }
    exports.flowStartParseObjPropValue = flowStartParseObjPropValue;
    function flowParseAssignableListItemTypes() {
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _index.eat.call(void 0, _types.TokenType.question);
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        flowParseTypeAnnotation();
      }
      _index.popTypeContext.call(void 0, oldIsType);
    }
    exports.flowParseAssignableListItemTypes = flowParseAssignableListItemTypes;
    function flowStartParseImportSpecifiers() {
      if (_index.match.call(void 0, _types.TokenType._typeof) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
        const lh = _index.lookaheadTypeAndKeyword.call(void 0);
        if (isMaybeDefaultImport(lh) || lh.type === _types.TokenType.braceL || lh.type === _types.TokenType.star) {
          _index.next.call(void 0);
        }
      }
    }
    exports.flowStartParseImportSpecifiers = flowStartParseImportSpecifiers;
    function flowParseImportSpecifier() {
      const isTypeKeyword = _base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.type === _types.TokenType._typeof;
      if (isTypeKeyword) {
        _index.next.call(void 0);
      } else {
        _expression.parseIdentifier.call(void 0);
      }
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as) && !_util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._as)) {
        _expression.parseIdentifier.call(void 0);
        if (isTypeKeyword && !_index.match.call(void 0, _types.TokenType.name) && !(_base.state.type & _types.TokenType.IS_KEYWORD)) {
        } else {
          _expression.parseIdentifier.call(void 0);
        }
      } else {
        if (isTypeKeyword && (_index.match.call(void 0, _types.TokenType.name) || !!(_base.state.type & _types.TokenType.IS_KEYWORD))) {
          _expression.parseIdentifier.call(void 0);
        }
        if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
          _expression.parseIdentifier.call(void 0);
        }
      }
    }
    exports.flowParseImportSpecifier = flowParseImportSpecifier;
    function flowStartParseFunctionParams() {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 0);
        flowParseTypeParameterDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
      }
    }
    exports.flowStartParseFunctionParams = flowStartParseFunctionParams;
    function flowAfterParseVarHead() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        flowParseTypeAnnotation();
      }
    }
    exports.flowAfterParseVarHead = flowAfterParseVarHead;
    function flowStartParseAsyncArrowFromCallExpression() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
        _base.state.noAnonFunctionType = true;
        flowParseTypeAnnotation();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
    }
    exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;
    function flowParseMaybeAssign(noIn, isWithinParens) {
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
        if (_base.state.error) {
          _base.state.restoreFromSnapshot(snapshot);
          _base.state.type = _types.TokenType.typeParameterStart;
        } else {
          return wasArrow;
        }
        const oldIsType = _index.pushTypeContext.call(void 0, 0);
        flowParseTypeParameterDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
        if (wasArrow) {
          return true;
        }
        _util.unexpected.call(void 0);
      }
      return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    }
    exports.flowParseMaybeAssign = flowParseMaybeAssign;
    function flowParseArrow() {
      if (_index.match.call(void 0, _types.TokenType.colon)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 0);
        const snapshot = _base.state.snapshot();
        const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
        _base.state.noAnonFunctionType = true;
        flowParseTypeAndPredicateInitialiser();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;
        if (_util.canInsertSemicolon.call(void 0))
          _util.unexpected.call(void 0);
        if (!_index.match.call(void 0, _types.TokenType.arrow))
          _util.unexpected.call(void 0);
        if (_base.state.error) {
          _base.state.restoreFromSnapshot(snapshot);
        }
        _index.popTypeContext.call(void 0, oldIsType);
      }
      return _index.eat.call(void 0, _types.TokenType.arrow);
    }
    exports.flowParseArrow = flowParseArrow;
    function flowParseSubscripts(startTokenIndex, noCalls = false) {
      if (_base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && _index.match.call(void 0, _types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        const wasArrow = parseAsyncArrowWithTypeParameters();
        if (wasArrow && !_base.state.error) {
          return;
        }
        _base.state.restoreFromSnapshot(snapshot);
      }
      _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);
    }
    exports.flowParseSubscripts = flowParseSubscripts;
    function parseAsyncArrowWithTypeParameters() {
      _base.state.scopeDepth++;
      const startTokenIndex = _base.state.tokens.length;
      _statement.parseFunctionParams.call(void 0);
      if (!_expression.parseArrow.call(void 0)) {
        return false;
      }
      _expression.parseArrowExpression.call(void 0, startTokenIndex);
      return true;
    }
    function flowParseEnumDeclaration() {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
      _expression.parseIdentifier.call(void 0);
      flowParseEnumBody();
    }
    function flowParseEnumBody() {
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {
        _index.next.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.braceL);
      flowParseEnumMembers();
      _util.expect.call(void 0, _types.TokenType.braceR);
    }
    function flowParseEnumMembers() {
      while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
          break;
        }
        flowParseEnumMember();
        if (!_index.match.call(void 0, _types.TokenType.braceR)) {
          _util.expect.call(void 0, _types.TokenType.comma);
        }
      }
    }
    function flowParseEnumMember() {
      _expression.parseIdentifier.call(void 0);
      if (_index.eat.call(void 0, _types.TokenType.eq)) {
        _index.next.call(void 0);
      }
    }
  }
});

// ../../node_modules/sucrase/dist/parser/traverser/statement.js
var require_statement = __commonJS({
  "../../node_modules/sucrase/dist/parser/traverser/statement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_parser();
    var _flow = require_flow();
    var _typescript = require_typescript();
    var _tokenizer = require_tokenizer();
    var _keywords = require_keywords();
    var _state = require_state();
    var _types = require_types();
    var _charcodes = require_charcodes();
    var _base = require_base();
    var _expression = require_expression();
    var _lval = require_lval();
    var _util = require_util();
    function parseTopLevel() {
      parseBlockBody(_types.TokenType.eof);
      _base.state.scopes.push(new (0, _state.Scope)(0, _base.state.tokens.length, true));
      if (_base.state.scopeDepth !== 0) {
        throw new Error(`Invalid scope depth at end of file: ${_base.state.scopeDepth}`);
      }
      return new (0, _index.File)(_base.state.tokens, _base.state.scopes);
    }
    exports.parseTopLevel = parseTopLevel;
    function parseStatement(declaration) {
      if (_base.isFlowEnabled) {
        if (_flow.flowTryParseStatement.call(void 0)) {
          return;
        }
      }
      if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
        parseDecorators();
      }
      parseStatementContent(declaration);
    }
    exports.parseStatement = parseStatement;
    function parseStatementContent(declaration) {
      if (_base.isTypeScriptEnabled) {
        if (_typescript.tsTryParseStatementContent.call(void 0)) {
          return;
        }
      }
      const starttype = _base.state.type;
      switch (starttype) {
        case _types.TokenType._break:
        case _types.TokenType._continue:
          parseBreakContinueStatement();
          return;
        case _types.TokenType._debugger:
          parseDebuggerStatement();
          return;
        case _types.TokenType._do:
          parseDoStatement();
          return;
        case _types.TokenType._for:
          parseForStatement();
          return;
        case _types.TokenType._function:
          if (_tokenizer.lookaheadType.call(void 0) === _types.TokenType.dot)
            break;
          if (!declaration)
            _util.unexpected.call(void 0);
          parseFunctionStatement();
          return;
        case _types.TokenType._class:
          if (!declaration)
            _util.unexpected.call(void 0);
          parseClass(true);
          return;
        case _types.TokenType._if:
          parseIfStatement();
          return;
        case _types.TokenType._return:
          parseReturnStatement();
          return;
        case _types.TokenType._switch:
          parseSwitchStatement();
          return;
        case _types.TokenType._throw:
          parseThrowStatement();
          return;
        case _types.TokenType._try:
          parseTryStatement();
          return;
        case _types.TokenType._let:
        case _types.TokenType._const:
          if (!declaration)
            _util.unexpected.call(void 0);
        case _types.TokenType._var:
          parseVarStatement(starttype !== _types.TokenType._var);
          return;
        case _types.TokenType._while:
          parseWhileStatement();
          return;
        case _types.TokenType.braceL:
          parseBlock();
          return;
        case _types.TokenType.semi:
          parseEmptyStatement();
          return;
        case _types.TokenType._export:
        case _types.TokenType._import: {
          const nextType = _tokenizer.lookaheadType.call(void 0);
          if (nextType === _types.TokenType.parenL || nextType === _types.TokenType.dot) {
            break;
          }
          _tokenizer.next.call(void 0);
          if (starttype === _types.TokenType._import) {
            parseImport();
          } else {
            parseExport();
          }
          return;
        }
        case _types.TokenType.name:
          if (_base.state.contextualKeyword === _keywords.ContextualKeyword._async) {
            const functionStart = _base.state.start;
            const snapshot = _base.state.snapshot();
            _tokenizer.next.call(void 0);
            if (_tokenizer.match.call(void 0, _types.TokenType._function) && !_util.canInsertSemicolon.call(void 0)) {
              _util.expect.call(void 0, _types.TokenType._function);
              parseFunction(functionStart, true);
              return;
            } else {
              _base.state.restoreFromSnapshot(snapshot);
            }
          } else if (_base.state.contextualKeyword === _keywords.ContextualKeyword._using && !_util.hasFollowingLineBreak.call(void 0) && // Statements like `using[0]` and `using in foo` aren't actual using
          // declarations.
          _tokenizer.lookaheadType.call(void 0) === _types.TokenType.name) {
            parseVarStatement(true);
            return;
          } else if (startsAwaitUsing()) {
            _util.expectContextual.call(void 0, _keywords.ContextualKeyword._await);
            parseVarStatement(true);
            return;
          }
        default:
          break;
      }
      const initialTokensLength = _base.state.tokens.length;
      _expression.parseExpression.call(void 0);
      let simpleName = null;
      if (_base.state.tokens.length === initialTokensLength + 1) {
        const token = _base.state.tokens[_base.state.tokens.length - 1];
        if (token.type === _types.TokenType.name) {
          simpleName = token.contextualKeyword;
        }
      }
      if (simpleName == null) {
        _util.semicolon.call(void 0);
        return;
      }
      if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {
        parseLabeledStatement();
      } else {
        parseIdentifierStatement(simpleName);
      }
    }
    function startsAwaitUsing() {
      if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._await)) {
        return false;
      }
      const snapshot = _base.state.snapshot();
      _tokenizer.next.call(void 0);
      if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._using) || _util.hasPrecedingLineBreak.call(void 0)) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
      }
      _tokenizer.next.call(void 0);
      if (!_tokenizer.match.call(void 0, _types.TokenType.name) || _util.hasPrecedingLineBreak.call(void 0)) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
      }
      _base.state.restoreFromSnapshot(snapshot);
      return true;
    }
    function parseDecorators() {
      while (_tokenizer.match.call(void 0, _types.TokenType.at)) {
        parseDecorator();
      }
    }
    exports.parseDecorators = parseDecorators;
    function parseDecorator() {
      _tokenizer.next.call(void 0);
      if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {
        _expression.parseExpression.call(void 0);
        _util.expect.call(void 0, _types.TokenType.parenR);
      } else {
        _expression.parseIdentifier.call(void 0);
        while (_tokenizer.eat.call(void 0, _types.TokenType.dot)) {
          _expression.parseIdentifier.call(void 0);
        }
        parseMaybeDecoratorArguments();
      }
    }
    function parseMaybeDecoratorArguments() {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseMaybeDecoratorArguments.call(void 0);
      } else {
        baseParseMaybeDecoratorArguments();
      }
    }
    function baseParseMaybeDecoratorArguments() {
      if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {
        _expression.parseCallExpressionArguments.call(void 0);
      }
    }
    exports.baseParseMaybeDecoratorArguments = baseParseMaybeDecoratorArguments;
    function parseBreakContinueStatement() {
      _tokenizer.next.call(void 0);
      if (!_util.isLineTerminator.call(void 0)) {
        _expression.parseIdentifier.call(void 0);
        _util.semicolon.call(void 0);
      }
    }
    function parseDebuggerStatement() {
      _tokenizer.next.call(void 0);
      _util.semicolon.call(void 0);
    }
    function parseDoStatement() {
      _tokenizer.next.call(void 0);
      parseStatement(false);
      _util.expect.call(void 0, _types.TokenType._while);
      _expression.parseParenExpression.call(void 0);
      _tokenizer.eat.call(void 0, _types.TokenType.semi);
    }
    function parseForStatement() {
      _base.state.scopeDepth++;
      const startTokenIndex = _base.state.tokens.length;
      parseAmbiguousForStatement();
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));
      _base.state.scopeDepth--;
    }
    function isUsingInLoop() {
      if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._using)) {
        return false;
      }
      if (_util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._of)) {
        return false;
      }
      return true;
    }
    function parseAmbiguousForStatement() {
      _tokenizer.next.call(void 0);
      let forAwait = false;
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._await)) {
        forAwait = true;
        _tokenizer.next.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.parenL);
      if (_tokenizer.match.call(void 0, _types.TokenType.semi)) {
        if (forAwait) {
          _util.unexpected.call(void 0);
        }
        parseFor();
        return;
      }
      const isAwaitUsing = startsAwaitUsing();
      if (isAwaitUsing || _tokenizer.match.call(void 0, _types.TokenType._var) || _tokenizer.match.call(void 0, _types.TokenType._let) || _tokenizer.match.call(void 0, _types.TokenType._const) || isUsingInLoop()) {
        if (isAwaitUsing) {
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._await);
        }
        _tokenizer.next.call(void 0);
        parseVar(true, _base.state.type !== _types.TokenType._var);
        if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {
          parseForIn(forAwait);
          return;
        }
        parseFor();
        return;
      }
      _expression.parseExpression.call(void 0, true);
      if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {
        parseForIn(forAwait);
        return;
      }
      if (forAwait) {
        _util.unexpected.call(void 0);
      }
      parseFor();
    }
    function parseFunctionStatement() {
      const functionStart = _base.state.start;
      _tokenizer.next.call(void 0);
      parseFunction(functionStart, true);
    }
    function parseIfStatement() {
      _tokenizer.next.call(void 0);
      _expression.parseParenExpression.call(void 0);
      parseStatement(false);
      if (_tokenizer.eat.call(void 0, _types.TokenType._else)) {
        parseStatement(false);
      }
    }
    function parseReturnStatement() {
      _tokenizer.next.call(void 0);
      if (!_util.isLineTerminator.call(void 0)) {
        _expression.parseExpression.call(void 0);
        _util.semicolon.call(void 0);
      }
    }
    function parseSwitchStatement() {
      _tokenizer.next.call(void 0);
      _expression.parseParenExpression.call(void 0);
      _base.state.scopeDepth++;
      const startTokenIndex = _base.state.tokens.length;
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_tokenizer.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        if (_tokenizer.match.call(void 0, _types.TokenType._case) || _tokenizer.match.call(void 0, _types.TokenType._default)) {
          const isCase = _tokenizer.match.call(void 0, _types.TokenType._case);
          _tokenizer.next.call(void 0);
          if (isCase) {
            _expression.parseExpression.call(void 0);
          }
          _util.expect.call(void 0, _types.TokenType.colon);
        } else {
          parseStatement(true);
        }
      }
      _tokenizer.next.call(void 0);
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));
      _base.state.scopeDepth--;
    }
    function parseThrowStatement() {
      _tokenizer.next.call(void 0);
      _expression.parseExpression.call(void 0);
      _util.semicolon.call(void 0);
    }
    function parseCatchClauseParam() {
      _lval.parseBindingAtom.call(
        void 0,
        true
        /* isBlockScope */
      );
      if (_base.isTypeScriptEnabled) {
        _typescript.tsTryParseTypeAnnotation.call(void 0);
      }
    }
    function parseTryStatement() {
      _tokenizer.next.call(void 0);
      parseBlock();
      if (_tokenizer.match.call(void 0, _types.TokenType._catch)) {
        _tokenizer.next.call(void 0);
        let catchBindingStartTokenIndex = null;
        if (_tokenizer.match.call(void 0, _types.TokenType.parenL)) {
          _base.state.scopeDepth++;
          catchBindingStartTokenIndex = _base.state.tokens.length;
          _util.expect.call(void 0, _types.TokenType.parenL);
          parseCatchClauseParam();
          _util.expect.call(void 0, _types.TokenType.parenR);
        }
        parseBlock();
        if (catchBindingStartTokenIndex != null) {
          const endTokenIndex = _base.state.tokens.length;
          _base.state.scopes.push(new (0, _state.Scope)(catchBindingStartTokenIndex, endTokenIndex, false));
          _base.state.scopeDepth--;
        }
      }
      if (_tokenizer.eat.call(void 0, _types.TokenType._finally)) {
        parseBlock();
      }
    }
    function parseVarStatement(isBlockScope) {
      _tokenizer.next.call(void 0);
      parseVar(false, isBlockScope);
      _util.semicolon.call(void 0);
    }
    exports.parseVarStatement = parseVarStatement;
    function parseWhileStatement() {
      _tokenizer.next.call(void 0);
      _expression.parseParenExpression.call(void 0);
      parseStatement(false);
    }
    function parseEmptyStatement() {
      _tokenizer.next.call(void 0);
    }
    function parseLabeledStatement() {
      parseStatement(true);
    }
    function parseIdentifierStatement(contextualKeyword) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseIdentifierStatement.call(void 0, contextualKeyword);
      } else if (_base.isFlowEnabled) {
        _flow.flowParseIdentifierStatement.call(void 0, contextualKeyword);
      } else {
        _util.semicolon.call(void 0);
      }
    }
    function parseBlock(isFunctionScope = false, contextId = 0) {
      const startTokenIndex = _base.state.tokens.length;
      _base.state.scopeDepth++;
      _util.expect.call(void 0, _types.TokenType.braceL);
      if (contextId) {
        _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
      }
      parseBlockBody(_types.TokenType.braceR);
      if (contextId) {
        _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
      }
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, isFunctionScope));
      _base.state.scopeDepth--;
    }
    exports.parseBlock = parseBlock;
    function parseBlockBody(end) {
      while (!_tokenizer.eat.call(void 0, end) && !_base.state.error) {
        parseStatement(true);
      }
    }
    exports.parseBlockBody = parseBlockBody;
    function parseFor() {
      _util.expect.call(void 0, _types.TokenType.semi);
      if (!_tokenizer.match.call(void 0, _types.TokenType.semi)) {
        _expression.parseExpression.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.semi);
      if (!_tokenizer.match.call(void 0, _types.TokenType.parenR)) {
        _expression.parseExpression.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.parenR);
      parseStatement(false);
    }
    function parseForIn(forAwait) {
      if (forAwait) {
        _util.eatContextual.call(void 0, _keywords.ContextualKeyword._of);
      } else {
        _tokenizer.next.call(void 0);
      }
      _expression.parseExpression.call(void 0);
      _util.expect.call(void 0, _types.TokenType.parenR);
      parseStatement(false);
    }
    function parseVar(isFor, isBlockScope) {
      while (true) {
        parseVarHead(isBlockScope);
        if (_tokenizer.eat.call(void 0, _types.TokenType.eq)) {
          const eqIndex = _base.state.tokens.length - 1;
          _expression.parseMaybeAssign.call(void 0, isFor);
          _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
        }
        if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) {
          break;
        }
      }
    }
    function parseVarHead(isBlockScope) {
      _lval.parseBindingAtom.call(void 0, isBlockScope);
      if (_base.isTypeScriptEnabled) {
        _typescript.tsAfterParseVarHead.call(void 0);
      } else if (_base.isFlowEnabled) {
        _flow.flowAfterParseVarHead.call(void 0);
      }
    }
    function parseFunction(functionStart, isStatement, optionalId = false) {
      if (_tokenizer.match.call(void 0, _types.TokenType.star)) {
        _tokenizer.next.call(void 0);
      }
      if (isStatement && !optionalId && !_tokenizer.match.call(void 0, _types.TokenType.name) && !_tokenizer.match.call(void 0, _types.TokenType._yield)) {
        _util.unexpected.call(void 0);
      }
      let nameScopeStartTokenIndex = null;
      if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
        if (!isStatement) {
          nameScopeStartTokenIndex = _base.state.tokens.length;
          _base.state.scopeDepth++;
        }
        _lval.parseBindingIdentifier.call(void 0, false);
      }
      const startTokenIndex = _base.state.tokens.length;
      _base.state.scopeDepth++;
      parseFunctionParams();
      _expression.parseFunctionBodyAndFinish.call(void 0, functionStart);
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
      _base.state.scopeDepth--;
      if (nameScopeStartTokenIndex !== null) {
        _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, true));
        _base.state.scopeDepth--;
      }
    }
    exports.parseFunction = parseFunction;
    function parseFunctionParams(allowModifiers = false, funcContextId = 0) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsStartParseFunctionParams.call(void 0);
      } else if (_base.isFlowEnabled) {
        _flow.flowStartParseFunctionParams.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.parenL);
      if (funcContextId) {
        _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
      }
      _lval.parseBindingList.call(
        void 0,
        _types.TokenType.parenR,
        false,
        false,
        allowModifiers,
        funcContextId
      );
      if (funcContextId) {
        _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
      }
    }
    exports.parseFunctionParams = parseFunctionParams;
    function parseClass(isStatement, optionalId = false) {
      const contextId = _base.getNextContextId.call(void 0);
      _tokenizer.next.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
      _base.state.tokens[_base.state.tokens.length - 1].isExpression = !isStatement;
      let nameScopeStartTokenIndex = null;
      if (!isStatement) {
        nameScopeStartTokenIndex = _base.state.tokens.length;
        _base.state.scopeDepth++;
      }
      parseClassId(isStatement, optionalId);
      parseClassSuper();
      const openBraceIndex = _base.state.tokens.length;
      parseClassBody(contextId);
      if (_base.state.error) {
        return;
      }
      _base.state.tokens[openBraceIndex].contextId = contextId;
      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
      if (nameScopeStartTokenIndex !== null) {
        const endTokenIndex = _base.state.tokens.length;
        _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, false));
        _base.state.scopeDepth--;
      }
    }
    exports.parseClass = parseClass;
    function isClassProperty() {
      return _tokenizer.match.call(void 0, _types.TokenType.eq) || _tokenizer.match.call(void 0, _types.TokenType.semi) || _tokenizer.match.call(void 0, _types.TokenType.braceR) || _tokenizer.match.call(void 0, _types.TokenType.bang) || _tokenizer.match.call(void 0, _types.TokenType.colon);
    }
    function isClassMethod() {
      return _tokenizer.match.call(void 0, _types.TokenType.parenL) || _tokenizer.match.call(void 0, _types.TokenType.lessThan);
    }
    function parseClassBody(classContextId) {
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        if (_tokenizer.eat.call(void 0, _types.TokenType.semi)) {
          continue;
        }
        if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
          parseDecorator();
          continue;
        }
        const memberStart = _base.state.start;
        parseClassMember(memberStart, classContextId);
      }
    }
    function parseClassMember(memberStart, classContextId) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseModifiers.call(void 0, [
          _keywords.ContextualKeyword._declare,
          _keywords.ContextualKeyword._public,
          _keywords.ContextualKeyword._protected,
          _keywords.ContextualKeyword._private,
          _keywords.ContextualKeyword._override
        ]);
      }
      let isStatic = false;
      if (_tokenizer.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._static) {
        _expression.parseIdentifier.call(void 0);
        if (isClassMethod()) {
          parseClassMethod(
            memberStart,
            /* isConstructor */
            false
          );
          return;
        } else if (isClassProperty()) {
          parseClassProperty();
          return;
        }
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
        isStatic = true;
        if (_tokenizer.match.call(void 0, _types.TokenType.braceL)) {
          _base.state.tokens[_base.state.tokens.length - 1].contextId = classContextId;
          parseBlock();
          return;
        }
      }
      parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
    }
    function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
      if (_base.isTypeScriptEnabled) {
        if (_typescript.tsTryParseClassMemberWithIsStatic.call(void 0, isStatic)) {
          return;
        }
      }
      if (_tokenizer.eat.call(void 0, _types.TokenType.star)) {
        parseClassPropertyName(classContextId);
        parseClassMethod(
          memberStart,
          /* isConstructor */
          false
        );
        return;
      }
      parseClassPropertyName(classContextId);
      let isConstructor = false;
      const token = _base.state.tokens[_base.state.tokens.length - 1];
      if (token.contextualKeyword === _keywords.ContextualKeyword._constructor) {
        isConstructor = true;
      }
      parsePostMemberNameModifiers();
      if (isClassMethod()) {
        parseClassMethod(memberStart, isConstructor);
      } else if (isClassProperty()) {
        parseClassProperty();
      } else if (token.contextualKeyword === _keywords.ContextualKeyword._async && !_util.isLineTerminator.call(void 0)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._async;
        const isGenerator = _tokenizer.match.call(void 0, _types.TokenType.star);
        if (isGenerator) {
          _tokenizer.next.call(void 0);
        }
        parseClassPropertyName(classContextId);
        parsePostMemberNameModifiers();
        parseClassMethod(
          memberStart,
          false
          /* isConstructor */
        );
      } else if ((token.contextualKeyword === _keywords.ContextualKeyword._get || token.contextualKeyword === _keywords.ContextualKeyword._set) && !(_util.isLineTerminator.call(void 0) && _tokenizer.match.call(void 0, _types.TokenType.star))) {
        if (token.contextualKeyword === _keywords.ContextualKeyword._get) {
          _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._get;
        } else {
          _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._set;
        }
        parseClassPropertyName(classContextId);
        parseClassMethod(
          memberStart,
          /* isConstructor */
          false
        );
      } else if (token.contextualKeyword === _keywords.ContextualKeyword._accessor && !_util.isLineTerminator.call(void 0)) {
        parseClassPropertyName(classContextId);
        parseClassProperty();
      } else if (_util.isLineTerminator.call(void 0)) {
        parseClassProperty();
      } else {
        _util.unexpected.call(void 0);
      }
    }
    function parseClassMethod(functionStart, isConstructor) {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsTryParseTypeParameters.call(void 0);
      } else if (_base.isFlowEnabled) {
        if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {
          _flow.flowParseTypeParameterDeclaration.call(void 0);
        }
      }
      _expression.parseMethod.call(void 0, functionStart, isConstructor);
    }
    function parseClassPropertyName(classContextId) {
      _expression.parsePropertyName.call(void 0, classContextId);
    }
    exports.parseClassPropertyName = parseClassPropertyName;
    function parsePostMemberNameModifiers() {
      if (_base.isTypeScriptEnabled) {
        const oldIsType = _tokenizer.pushTypeContext.call(void 0, 0);
        _tokenizer.eat.call(void 0, _types.TokenType.question);
        _tokenizer.popTypeContext.call(void 0, oldIsType);
      }
    }
    exports.parsePostMemberNameModifiers = parsePostMemberNameModifiers;
    function parseClassProperty() {
      if (_base.isTypeScriptEnabled) {
        _tokenizer.eatTypeToken.call(void 0, _types.TokenType.bang);
        _typescript.tsTryParseTypeAnnotation.call(void 0);
      } else if (_base.isFlowEnabled) {
        if (_tokenizer.match.call(void 0, _types.TokenType.colon)) {
          _flow.flowParseTypeAnnotation.call(void 0);
        }
      }
      if (_tokenizer.match.call(void 0, _types.TokenType.eq)) {
        const equalsTokenIndex = _base.state.tokens.length;
        _tokenizer.next.call(void 0);
        _expression.parseMaybeAssign.call(void 0);
        _base.state.tokens[equalsTokenIndex].rhsEndIndex = _base.state.tokens.length;
      }
      _util.semicolon.call(void 0);
    }
    exports.parseClassProperty = parseClassProperty;
    function parseClassId(isStatement, optionalId = false) {
      if (_base.isTypeScriptEnabled && (!isStatement || optionalId) && _util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
        return;
      }
      if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
        _lval.parseBindingIdentifier.call(void 0, true);
      }
      if (_base.isTypeScriptEnabled) {
        _typescript.tsTryParseTypeParameters.call(void 0);
      } else if (_base.isFlowEnabled) {
        if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {
          _flow.flowParseTypeParameterDeclaration.call(void 0);
        }
      }
    }
    function parseClassSuper() {
      let hasSuper = false;
      if (_tokenizer.eat.call(void 0, _types.TokenType._extends)) {
        _expression.parseExprSubscripts.call(void 0);
        hasSuper = true;
      } else {
        hasSuper = false;
      }
      if (_base.isTypeScriptEnabled) {
        _typescript.tsAfterParseClassSuper.call(void 0, hasSuper);
      } else if (_base.isFlowEnabled) {
        _flow.flowAfterParseClassSuper.call(void 0, hasSuper);
      }
    }
    function parseExport() {
      const exportIndex = _base.state.tokens.length - 1;
      if (_base.isTypeScriptEnabled) {
        if (_typescript.tsTryParseExport.call(void 0)) {
          return;
        }
      }
      if (shouldParseExportStar()) {
        parseExportStar();
      } else if (isExportDefaultSpecifier()) {
        _expression.parseIdentifier.call(void 0);
        if (_tokenizer.match.call(void 0, _types.TokenType.comma) && _tokenizer.lookaheadType.call(void 0) === _types.TokenType.star) {
          _util.expect.call(void 0, _types.TokenType.comma);
          _util.expect.call(void 0, _types.TokenType.star);
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);
          _expression.parseIdentifier.call(void 0);
        } else {
          parseExportSpecifiersMaybe();
        }
        parseExportFrom();
      } else if (_tokenizer.eat.call(void 0, _types.TokenType._default)) {
        parseExportDefaultExpression();
      } else if (shouldParseExportDeclaration()) {
        parseExportDeclaration();
      } else {
        parseExportSpecifiers();
        parseExportFrom();
      }
      _base.state.tokens[exportIndex].rhsEndIndex = _base.state.tokens.length;
    }
    exports.parseExport = parseExport;
    function parseExportDefaultExpression() {
      if (_base.isTypeScriptEnabled) {
        if (_typescript.tsTryParseExportDefaultExpression.call(void 0)) {
          return;
        }
      }
      if (_base.isFlowEnabled) {
        if (_flow.flowTryParseExportDefaultExpression.call(void 0)) {
          return;
        }
      }
      const functionStart = _base.state.start;
      if (_tokenizer.eat.call(void 0, _types.TokenType._function)) {
        parseFunction(functionStart, true, true);
      } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._async) && _tokenizer.lookaheadType.call(void 0) === _types.TokenType._function) {
        _util.eatContextual.call(void 0, _keywords.ContextualKeyword._async);
        _tokenizer.eat.call(void 0, _types.TokenType._function);
        parseFunction(functionStart, true, true);
      } else if (_tokenizer.match.call(void 0, _types.TokenType._class)) {
        parseClass(true, true);
      } else if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
        parseDecorators();
        parseClass(true, true);
      } else {
        _expression.parseMaybeAssign.call(void 0);
        _util.semicolon.call(void 0);
      }
    }
    function parseExportDeclaration() {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseExportDeclaration.call(void 0);
      } else if (_base.isFlowEnabled) {
        _flow.flowParseExportDeclaration.call(void 0);
      } else {
        parseStatement(true);
      }
    }
    function isExportDefaultSpecifier() {
      if (_base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0)) {
        return false;
      } else if (_base.isFlowEnabled && _flow.flowShouldDisallowExportDefaultSpecifier.call(void 0)) {
        return false;
      }
      if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
        return _base.state.contextualKeyword !== _keywords.ContextualKeyword._async;
      }
      if (!_tokenizer.match.call(void 0, _types.TokenType._default)) {
        return false;
      }
      const _next = _tokenizer.nextTokenStart.call(void 0);
      const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0);
      const hasFrom = lookahead.type === _types.TokenType.name && lookahead.contextualKeyword === _keywords.ContextualKeyword._from;
      if (lookahead.type === _types.TokenType.comma) {
        return true;
      }
      if (hasFrom) {
        const nextAfterFrom = _base.input.charCodeAt(_tokenizer.nextTokenStartSince.call(void 0, _next + 4));
        return nextAfterFrom === _charcodes.charCodes.quotationMark || nextAfterFrom === _charcodes.charCodes.apostrophe;
      }
      return false;
    }
    function parseExportSpecifiersMaybe() {
      if (_tokenizer.eat.call(void 0, _types.TokenType.comma)) {
        parseExportSpecifiers();
      }
    }
    function parseExportFrom() {
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {
        _expression.parseExprAtom.call(void 0);
        maybeParseImportAttributes();
      }
      _util.semicolon.call(void 0);
    }
    exports.parseExportFrom = parseExportFrom;
    function shouldParseExportStar() {
      if (_base.isFlowEnabled) {
        return _flow.flowShouldParseExportStar.call(void 0);
      } else {
        return _tokenizer.match.call(void 0, _types.TokenType.star);
      }
    }
    function parseExportStar() {
      if (_base.isFlowEnabled) {
        _flow.flowParseExportStar.call(void 0);
      } else {
        baseParseExportStar();
      }
    }
    function baseParseExportStar() {
      _util.expect.call(void 0, _types.TokenType.star);
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {
        parseExportNamespace();
      } else {
        parseExportFrom();
      }
    }
    exports.baseParseExportStar = baseParseExportStar;
    function parseExportNamespace() {
      _tokenizer.next.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._as;
      _expression.parseIdentifier.call(void 0);
      parseExportSpecifiersMaybe();
      parseExportFrom();
    }
    function shouldParseExportDeclaration() {
      return _base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0) || _base.isFlowEnabled && _flow.flowShouldParseExportDeclaration.call(void 0) || _base.state.type === _types.TokenType._var || _base.state.type === _types.TokenType._const || _base.state.type === _types.TokenType._let || _base.state.type === _types.TokenType._function || _base.state.type === _types.TokenType._class || _util.isContextual.call(void 0, _keywords.ContextualKeyword._async) || _tokenizer.match.call(void 0, _types.TokenType.at);
    }
    function parseExportSpecifiers() {
      let first = true;
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          _util.expect.call(void 0, _types.TokenType.comma);
          if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {
            break;
          }
        }
        parseExportSpecifier();
      }
    }
    exports.parseExportSpecifiers = parseExportSpecifiers;
    function parseExportSpecifier() {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseExportSpecifier.call(void 0);
        return;
      }
      _expression.parseIdentifier.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ExportAccess;
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
        _expression.parseIdentifier.call(void 0);
      }
    }
    function isImportReflection() {
      const snapshot = _base.state.snapshot();
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {
        if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._from)) {
          _base.state.restoreFromSnapshot(snapshot);
          return true;
        } else {
          _base.state.restoreFromSnapshot(snapshot);
          return false;
        }
      } else if (_tokenizer.match.call(void 0, _types.TokenType.comma)) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
      } else {
        _base.state.restoreFromSnapshot(snapshot);
        return true;
      }
    }
    function parseMaybeImportReflection() {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._module) && isImportReflection()) {
        _tokenizer.next.call(void 0);
      }
    }
    function parseImport() {
      if (_base.isTypeScriptEnabled && _tokenizer.match.call(void 0, _types.TokenType.name) && _tokenizer.lookaheadType.call(void 0) === _types.TokenType.eq) {
        _typescript.tsParseImportEqualsDeclaration.call(void 0);
        return;
      }
      if (_base.isTypeScriptEnabled && _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
        const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0);
        if (lookahead.type === _types.TokenType.name && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from) {
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
          if (_tokenizer.lookaheadType.call(void 0) === _types.TokenType.eq) {
            _typescript.tsParseImportEqualsDeclaration.call(void 0);
            return;
          }
        } else if (lookahead.type === _types.TokenType.star || lookahead.type === _types.TokenType.braceL) {
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
        }
      }
      if (_tokenizer.match.call(void 0, _types.TokenType.string)) {
        _expression.parseExprAtom.call(void 0);
      } else {
        parseMaybeImportReflection();
        parseImportSpecifiers();
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._from);
        _expression.parseExprAtom.call(void 0);
      }
      maybeParseImportAttributes();
      _util.semicolon.call(void 0);
    }
    exports.parseImport = parseImport;
    function shouldParseDefaultImport() {
      return _tokenizer.match.call(void 0, _types.TokenType.name);
    }
    function parseImportSpecifierLocal() {
      _lval.parseImportedIdentifier.call(void 0);
    }
    function parseImportSpecifiers() {
      if (_base.isFlowEnabled) {
        _flow.flowStartParseImportSpecifiers.call(void 0);
      }
      let first = true;
      if (shouldParseDefaultImport()) {
        parseImportSpecifierLocal();
        if (!_tokenizer.eat.call(void 0, _types.TokenType.comma))
          return;
      }
      if (_tokenizer.match.call(void 0, _types.TokenType.star)) {
        _tokenizer.next.call(void 0);
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);
        parseImportSpecifierLocal();
        return;
      }
      _util.expect.call(void 0, _types.TokenType.braceL);
      while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
        if (first) {
          first = false;
        } else {
          if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {
            _util.unexpected.call(
              void 0,
              "ES2015 named imports do not destructure. Use another statement for destructuring after the import."
            );
          }
          _util.expect.call(void 0, _types.TokenType.comma);
          if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {
            break;
          }
        }
        parseImportSpecifier();
      }
    }
    function parseImportSpecifier() {
      if (_base.isTypeScriptEnabled) {
        _typescript.tsParseImportSpecifier.call(void 0);
        return;
      }
      if (_base.isFlowEnabled) {
        _flow.flowParseImportSpecifier.call(void 0);
        return;
      }
      _lval.parseImportedIdentifier.call(void 0);
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ImportAccess;
        _tokenizer.next.call(void 0);
        _lval.parseImportedIdentifier.call(void 0);
      }
    }
    function maybeParseImportAttributes() {
      if (_tokenizer.match.call(void 0, _types.TokenType._with) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._assert) && !_util.hasPrecedingLineBreak.call(void 0)) {
        _tokenizer.next.call(void 0);
        _expression.parseObj.call(void 0, false, false);
      }
    }
  }
});

// ../../node_modules/sucrase/dist/parser/traverser/index.js
var require_traverser = __commonJS({
  "../../node_modules/sucrase/dist/parser/traverser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _index = require_tokenizer();
    var _charcodes = require_charcodes();
    var _base = require_base();
    var _statement = require_statement();
    function parseFile() {
      if (_base.state.pos === 0 && _base.input.charCodeAt(0) === _charcodes.charCodes.numberSign && _base.input.charCodeAt(1) === _charcodes.charCodes.exclamationMark) {
        _index.skipLineComment.call(void 0, 2);
      }
      _index.nextToken.call(void 0);
      return _statement.parseTopLevel.call(void 0);
    }
    exports.parseFile = parseFile;
  }
});

// ../../node_modules/sucrase/dist/parser/index.js
var require_parser = __commonJS({
  "../../node_modules/sucrase/dist/parser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _base = require_base();
    var _index = require_traverser();
    var File = class {
      constructor(tokens, scopes) {
        this.tokens = tokens;
        this.scopes = scopes;
      }
    };
    exports.File = File;
    function parse4(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled) {
      if (isFlowEnabled && isTypeScriptEnabled) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      _base.initParser.call(void 0, input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
      const result = _index.parseFile.call(void 0);
      if (_base.state.error) {
        throw _base.augmentError.call(void 0, _base.state.error);
      }
      return result;
    }
    exports.parse = parse4;
  }
});

// ../../node_modules/sucrase/dist/util/isAsyncOperation.js
var require_isAsyncOperation = __commonJS({
  "../../node_modules/sucrase/dist/util/isAsyncOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _keywords = require_keywords();
    function isAsyncOperation(tokens) {
      let index = tokens.currentIndex();
      let depth = 0;
      const startToken = tokens.currentToken();
      do {
        const token = tokens.tokens[index];
        if (token.isOptionalChainStart) {
          depth++;
        }
        if (token.isOptionalChainEnd) {
          depth--;
        }
        depth += token.numNullishCoalesceStarts;
        depth -= token.numNullishCoalesceEnds;
        if (token.contextualKeyword === _keywords.ContextualKeyword._await && token.identifierRole == null && token.scopeDepth === startToken.scopeDepth) {
          return true;
        }
        index += 1;
      } while (depth > 0 && index < tokens.tokens.length);
      return false;
    }
    exports.default = isAsyncOperation;
  }
});

// ../../node_modules/sucrase/dist/TokenProcessor.js
var require_TokenProcessor = __commonJS({
  "../../node_modules/sucrase/dist/TokenProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _types = require_types();
    var _isAsyncOperation = require_isAsyncOperation();
    var _isAsyncOperation2 = _interopRequireDefault(_isAsyncOperation);
    var TokenProcessor2 = class _TokenProcessor {
      __init() {
        this.resultCode = "";
      }
      // Array mapping input token index to optional string index position in the
      // output code.
      __init2() {
        this.resultMappings = new Array(this.tokens.length);
      }
      __init3() {
        this.tokenIndex = 0;
      }
      constructor(code, tokens, isFlowEnabled, disableESTransforms, helperManager) {
        ;
        this.code = code;
        this.tokens = tokens;
        this.isFlowEnabled = isFlowEnabled;
        this.disableESTransforms = disableESTransforms;
        this.helperManager = helperManager;
        _TokenProcessor.prototype.__init.call(this);
        _TokenProcessor.prototype.__init2.call(this);
        _TokenProcessor.prototype.__init3.call(this);
      }
      /**
       * Snapshot the token state in a way that can be restored later, useful for
       * things like lookahead.
       *
       * resultMappings do not need to be copied since in all use cases, they will
       * be overwritten anyway after restore.
       */
      snapshot() {
        return {
          resultCode: this.resultCode,
          tokenIndex: this.tokenIndex
        };
      }
      restoreToSnapshot(snapshot) {
        this.resultCode = snapshot.resultCode;
        this.tokenIndex = snapshot.tokenIndex;
      }
      /**
       * Remove and return the code generated since the snapshot, leaving the
       * current token position in-place. Unlike most TokenProcessor operations,
       * this operation can result in input/output line number mismatches because
       * the removed code may contain newlines, so this operation should be used
       * sparingly.
       */
      dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
        const result = this.resultCode.slice(snapshot.resultCode.length);
        this.resultCode = snapshot.resultCode;
        return result;
      }
      reset() {
        this.resultCode = "";
        this.resultMappings = new Array(this.tokens.length);
        this.tokenIndex = 0;
      }
      matchesContextualAtIndex(index, contextualKeyword) {
        return this.matches1AtIndex(index, _types.TokenType.name) && this.tokens[index].contextualKeyword === contextualKeyword;
      }
      identifierNameAtIndex(index) {
        return this.identifierNameForToken(this.tokens[index]);
      }
      identifierNameAtRelativeIndex(relativeIndex) {
        return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
      }
      identifierName() {
        return this.identifierNameForToken(this.currentToken());
      }
      identifierNameForToken(token) {
        return this.code.slice(token.start, token.end);
      }
      rawCodeForToken(token) {
        return this.code.slice(token.start, token.end);
      }
      stringValueAtIndex(index) {
        return this.stringValueForToken(this.tokens[index]);
      }
      stringValue() {
        return this.stringValueForToken(this.currentToken());
      }
      stringValueForToken(token) {
        return this.code.slice(token.start + 1, token.end - 1);
      }
      matches1AtIndex(index, t1) {
        return this.tokens[index].type === t1;
      }
      matches2AtIndex(index, t1, t2) {
        return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
      }
      matches3AtIndex(index, t1, t2, t3) {
        return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;
      }
      matches1(t1) {
        return this.tokens[this.tokenIndex].type === t1;
      }
      matches2(t1, t2) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
      }
      matches3(t1, t2, t3) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;
      }
      matches4(t1, t2, t3, t4) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;
      }
      matches5(t1, t2, t3, t4, t5) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;
      }
      matchesContextual(contextualKeyword) {
        return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
      }
      matchesContextIdAndLabel(type, contextId) {
        return this.matches1(type) && this.currentToken().contextId === contextId;
      }
      previousWhitespaceAndComments() {
        let whitespaceAndComments = this.code.slice(
          this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
          this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length
        );
        if (this.isFlowEnabled) {
          whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
        }
        return whitespaceAndComments;
      }
      replaceToken(newCode) {
        this.resultCode += this.previousWhitespaceAndComments();
        this.appendTokenPrefix();
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += newCode;
        this.appendTokenSuffix();
        this.tokenIndex++;
      }
      replaceTokenTrimmingLeftWhitespace(newCode) {
        this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
        this.appendTokenPrefix();
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += newCode;
        this.appendTokenSuffix();
        this.tokenIndex++;
      }
      removeInitialToken() {
        this.replaceToken("");
      }
      removeToken() {
        this.replaceTokenTrimmingLeftWhitespace("");
      }
      /**
       * Remove all code until the next }, accounting for balanced braces.
       */
      removeBalancedCode() {
        let braceDepth = 0;
        while (!this.isAtEnd()) {
          if (this.matches1(_types.TokenType.braceL)) {
            braceDepth++;
          } else if (this.matches1(_types.TokenType.braceR)) {
            if (braceDepth === 0) {
              return;
            }
            braceDepth--;
          }
          this.removeToken();
        }
      }
      copyExpectedToken(tokenType) {
        if (this.tokens[this.tokenIndex].type !== tokenType) {
          throw new Error(`Expected token ${tokenType}`);
        }
        this.copyToken();
      }
      copyToken() {
        this.resultCode += this.previousWhitespaceAndComments();
        this.appendTokenPrefix();
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += this.code.slice(
          this.tokens[this.tokenIndex].start,
          this.tokens[this.tokenIndex].end
        );
        this.appendTokenSuffix();
        this.tokenIndex++;
      }
      copyTokenWithPrefix(prefix) {
        this.resultCode += this.previousWhitespaceAndComments();
        this.appendTokenPrefix();
        this.resultCode += prefix;
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += this.code.slice(
          this.tokens[this.tokenIndex].start,
          this.tokens[this.tokenIndex].end
        );
        this.appendTokenSuffix();
        this.tokenIndex++;
      }
      appendTokenPrefix() {
        const token = this.currentToken();
        if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {
          token.isAsyncOperation = _isAsyncOperation2.default.call(void 0, this);
        }
        if (this.disableESTransforms) {
          return;
        }
        if (token.numNullishCoalesceStarts) {
          for (let i = 0; i < token.numNullishCoalesceStarts; i++) {
            if (token.isAsyncOperation) {
              this.resultCode += "await ";
              this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
            } else {
              this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
            }
            this.resultCode += "(";
          }
        }
        if (token.isOptionalChainStart) {
          if (token.isAsyncOperation) {
            this.resultCode += "await ";
          }
          if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === _types.TokenType._delete) {
            if (token.isAsyncOperation) {
              this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
            } else {
              this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
            }
          } else if (token.isAsyncOperation) {
            this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
          } else {
            this.resultCode += this.helperManager.getHelperName("optionalChain");
          }
          this.resultCode += "([";
        }
      }
      appendTokenSuffix() {
        const token = this.currentToken();
        if (token.isOptionalChainEnd && !this.disableESTransforms) {
          this.resultCode += "])";
        }
        if (token.numNullishCoalesceEnds && !this.disableESTransforms) {
          for (let i = 0; i < token.numNullishCoalesceEnds; i++) {
            this.resultCode += "))";
          }
        }
      }
      appendCode(code) {
        this.resultCode += code;
      }
      currentToken() {
        return this.tokens[this.tokenIndex];
      }
      currentTokenCode() {
        const token = this.currentToken();
        return this.code.slice(token.start, token.end);
      }
      tokenAtRelativeIndex(relativeIndex) {
        return this.tokens[this.tokenIndex + relativeIndex];
      }
      currentIndex() {
        return this.tokenIndex;
      }
      /**
       * Move to the next token. Only suitable in preprocessing steps. When
       * generating new code, you should use copyToken or removeToken.
       */
      nextToken() {
        if (this.tokenIndex === this.tokens.length) {
          throw new Error("Unexpectedly reached end of input.");
        }
        this.tokenIndex++;
      }
      previousToken() {
        this.tokenIndex--;
      }
      finish() {
        if (this.tokenIndex !== this.tokens.length) {
          throw new Error("Tried to finish processing tokens before reaching the end.");
        }
        this.resultCode += this.previousWhitespaceAndComments();
        return { code: this.resultCode, mappings: this.resultMappings };
      }
      isAtEnd() {
        return this.tokenIndex === this.tokens.length;
      }
    };
    exports.default = TokenProcessor2;
  }
});

// ../../node_modules/cjs-module-lexer/dist/lexer.mjs
var lexer_exports = {};
__export(lexer_exports, {
  init: () => init,
  parse: () => parse2
});
function parse2(g2, I = "@") {
  if (!A)
    throw new Error("Not initialized");
  const D = g2.length + 1, N = (A.__heap_base.value || A.__heap_base) + 4 * D - A.memory.buffer.byteLength;
  N > 0 && A.memory.grow(Math.ceil(N / 65536));
  const k = A.sa(D);
  if ((Q ? C : E)(g2, new Uint16Array(A.memory.buffer, k, D)), !A.parseCJS(k, g2.length, 0, 0, 0))
    throw Object.assign(new Error(`Parse error ${I}${A.e()}:${g2.slice(0, A.e()).split("\n").length}:${A.e() - g2.lastIndexOf("\n", A.e() - 1)}`), { idx: A.e() });
  let w = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), J = /* @__PURE__ */ new Set();
  for (; A.rre(); ) {
    const Q3 = B(g2.slice(A.res(), A.ree()));
    Q3 && o.add(Q3);
  }
  for (; A.ru(); )
    J.add(B(g2.slice(A.us(), A.ue())));
  for (; A.re(); ) {
    let Q3 = B(g2.slice(A.es(), A.ee()));
    void 0 === Q3 || J.has(Q3) || w.add(Q3);
  }
  return { exports: [...w], reexports: [...o] };
}
function B(A3) {
  if ('"' !== A3[0] && "'" !== A3[0])
    return A3;
  try {
    const Q3 = (0, eval)(A3);
    for (let A4 = 0; A4 < Q3.length; A4++) {
      const B3 = 64512 & Q3.charCodeAt(A4);
      if (!(B3 < 55296)) {
        if (55296 !== B3)
          return;
        if (56320 != (64512 & Q3.charCodeAt(++A4)))
          return;
      }
    }
    return Q3;
  } catch {
  }
}
function E(A3, Q3) {
  const B3 = A3.length;
  let E3 = 0;
  for (; E3 < B3; ) {
    const B4 = A3.charCodeAt(E3);
    Q3[E3++] = (255 & B4) << 8 | B4 >>> 8;
  }
}
function C(A3, Q3) {
  const B3 = A3.length;
  let E3 = 0;
  for (; E3 < B3; )
    Q3[E3] = A3.charCodeAt(E3++);
}
function init() {
  return g || (g = (async () => {
    const Q3 = await WebAssembly.compile((B3 = "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EBENACACLwEAQS5HDQELQQAgAkESajYCvKABAkAgAi8BEiIDQdMARw0AIAIvARRB9ABHDQEgAi8BFkHhAEcNASACLwEYQfIARw0BQQAgAkEaajYCvKABIAIvARohAwsgA0H//wNxQShHDQBBACgCsKABQQAoAoxANgIAQQBBATsBhkBBAEEAKAK8oAEiAkECajYCvKABIAIvAQJB8gBHDQBBAhAQGgtBAEEAKAK8oAE2AoxADAELAkAgAkEEakHtAEHwAEHvAEHyAEH0ABATRQ0AIAAQEUUNABAkQQAoArygASEAC0EAIAA2AoxAC0EAKALAoAEhA0EAKAK8oAEhAgwACwsgAgv3AQEEf0EAIQECQEEAKAK8oAEiAkECakHlAEHxAEH1AEHpAEHyAEHlABAmRQ0AQQAhAUEAIAJBDmo2ArygAQJAECdBKEcNAEEAQQAoArygAUECajYCvKABECchA0EAKAK8oAEhBAJAIANBJ0YNACADQSJHDQELIAMQHEEAQQAoArygAUECaiIDNgK8oAEQJ0EpRw0AAkAgAEF/aiIBQQFLDQACQAJAIAEOAgEAAQsgBCADQQAoAqAfEQAAQQEPCyAEIANBACgCoB8RAABBAQ8LQQAoArSgASAENgIAQQAoArSgASADNgIEQQEPC0EAIAI2ArygAQsgAQsdAAJAQQAoApgfIABHDQBBAQ8LIABBfmovAQAQJQv+AgEEf0EAKAKYHyEBAkADQCAAQX5qIQIgAC8BACIDQSBHDQEgACABSyEEIAIhACAEDQALCwJAIANBPUcNAAJAA0AgAkF+aiEAIAIvAQBBIEcNASACIAFLIQQgACECIAQNAAsLIABBAmohAiAAQQRqIQNBACEEAkADQCACECghACACIAFNDQEgAEUNASAAQdwARg0CIAAQKUUNASACQX5BfCAAQYCABEkbaiECIAAQKiEEDAALCyAEQQFxRQ0AIAIvAQBBIEcNAEEAKAK0oAEiBEEAKAKwH0YNACAEIAM2AgwgBCACQQJqNgIIIAJBfmohAEEgIQICQANAIABBAmogAU0NASACQf//A3FBIEcNASAALwEAIQIgAEF+aiEADAALCyACQf//A3FBjn9qIgJBAksNAAJAAkACQCACDgMAAwEACyAAQfYAQeEAECsNAQwCCyAAQewAQeUAECsNACAAQeMAQe8AQe4AQfMAECxFDQELQQAgBEEQajYCtKABCws/AQF/QQAhBgJAIAAvAQAgAUcNACAALwECIAJHDQAgAC8BBCADRw0AIAAvAQYgBEcNACAALwEIIAVGIQYLIAYLpCYBCH9BAEEAKAK8oAEiAUEMajYCvKABIAFBCmohAQJAECdBLkcNAEEAQQAoArygAUECajYCvKABAkACQBAnIgJB5ABHDQBBACgCvKABIgBBAmpB5QBB5gBB6QBB7gBB5QBB0ABB8gBB7wBB8ABB5QBB8gBB9ABB+QAQL0UNAkEAIABBHGo2ArygASAAQRpqIQEQJ0EoRw0CQQBBACgCvKABQQJqNgK8oAEQJxAwRQ0CECdBLEcNAkEAQQAoArygAUECajYCvKABAkAQJyIAQSdGDQAgAEEiRw0DC0EAKAK8oAEhAiAAEBxBAEEAKAK8oAFBAmoiADYCvKABECdBLEcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygAQJAECciA0HlAEcNAEEAKAK8oAEiA0ECakHuAEH1AEHtAEHlAEHyAEHhAEHiAEHsAEHlABAxRQ0CQQAgA0EUajYCvKABECdBOkcNAkEAQQAoArygAUECajYCvKABECdB9ABHDQJBACgCvKABIgMvAQJB8gBHDQIgAy8BBEH1AEcNAiADLwEGQeUARw0CQQAgA0EIajYCvKABECdBLEcNAkEAQQAoArygAUECajYCvKABECchAwsCQCADQecARg0AIANB9gBHDQJBACgCvKABIgMvAQJB4QBHDQIgAy8BBEHsAEcNAiADLwEGQfUARw0CIAMvAQhB5QBHDQJBACADQQpqNgK8oAEQJ0E6Rw0CIAIgAEEAKAKcHxEAAEEAIAE2ArygAQ8LQQAoArygASIDLwECQeUARw0BIAMvAQRB9ABHDQFBACADQQZqNgK8oAECQBAnIgNBOkcNAEEAQQAoArygAUECajYCvKABECdB5gBHDQJBACgCvKABIgNBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNAkEAIANBEGoiAzYCvKABAkAQJyIEQShGDQAgA0EAKAK8oAFGDQMgBBAtRQ0DCxAnIQMLIANBKEcNAUEAQQAoArygAUECajYCvKABECdBKUcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygARAnQfIARw0BQQAoArygASIDQQJqQeUAQfQAQfUAQfIAQe4AEBNFDQFBACADQQxqNgK8oAEQJxAtRQ0BAkACQAJAECciA0HbAEYNACADQS5HDQJBAEEAKAK8oAFBAmo2ArygARAnEC0NAQwEC0EAQQAoArygAUECajYCvKABAkAQJyIDQSdGDQAgA0EiRw0ECyADEBxBAEEAKAK8oAFBAmo2ArygARAnQd0ARw0DQQBBACgCvKABQQJqNgK8oAELECchAwsCQCADQTtHDQBBAEEAKAK8oAFBAmo2ArygARAnIQMLIANB/QBHDQFBAEEAKAK8oAFBAmo2ArygAQJAECciA0EsRw0AQQBBACgCvKABQQJqNgK8oAEQJyEDCyADQf0ARw0BQQBBACgCvKABQQJqNgK8oAEQJ0EpRw0BIAIgAEEAKAKcHxEAAA8LIAJB6wBHDQEgAEUNAUEAKAK8oAEiAC8BAkHlAEcNASAALwEEQfkARw0BIAAvAQZB8wBHDQEgAEEGaiEBQQAgAEEIajYCvKABECdBKEcNAUEAQQAoArygAUECajYCvKABECchAEEAKAK8oAEhAiAAEC1FDQFBACgCvKABIQAQJ0EpRw0BQQBBACgCvKABIgFBAmo2ArygARAnQS5HDQFBAEEAKAK8oAFBAmo2ArygARAnQeYARw0BQQAoArygASIDQQJqQe8AQfIAQcUAQeEAQeMAQegAECZFDQFBACADQQ5qNgK8oAEQJyEDQQAoArygASIEQX5qIQEgA0EoRw0BQQAgBEECajYCvKABECdB5gBHDQFBACgCvKABIgNBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNAUEAIANBEGo2ArygARAnQShHDQFBAEEAKAK8oAFBAmo2ArygARAnIQNBACgCvKABIQQgAxAtRQ0BQQAoArygASEDECdBKUcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygARAnQekARw0BQQAoArygASIFLwECQeYARw0BQQAgBUEEajYCvKABECdBKEcNAUEAQQAoArygAUECajYCvKABECcaQQAoArygASIFIAQgAyAEayIDEEENASAAIAJrIgZBAXUhB0EAIAUgA0EBdSIIQQF0ajYCvKAB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ASADLwEGQQpGGyEBDAALC0EAIAE2ArygARAdDwtBACABNgK8oAELOAEBf0EAQQE6APAfQQAoArygASEAQQBBACgCwKABQQJqNgK8oAFBACAAQQAoApgfa0EBdTYC7B8LzgEBBX9BACgCvKABIQBBACgCwKABIQEDQCAAIgJBAmohAAJAAkAgAiABTw0AIAAvAQAiA0Gkf2oiBEEETQ0BIANBJEcNAiACLwEEQfsARw0CQQBBAC8BhEAiAEEBajsBhEBBACgCoGAgAEEBdGpBAC8BiEA7AQBBACACQQRqNgK8oAFBAEEALwGGQEEBaiIAOwGIQEEAIAA7AYZADwtBACAANgK8oAEQHQ8LAkACQCAEDgUBAgICAAELQQAgADYCvKABDwsgAkEEaiEADAALC7YCAQJ/QQBBACgCvKABIgFBDmo2ArygAQJAAkACQBAnIgJB2wBGDQAgAkE9Rg0BIAJBLkcNAkEAQQAoArygAUECajYCvKABECchAkEAKAK8oAEhACACEC1FDQJBACgCvKABIQIQJ0E9Rw0CIAAgAkEAKAKcHxEAAA8LQQBBACgCvKABQQJqNgK8oAECQBAnIgJBJ0YNACACQSJHDQILQQAoArygASEAIAIQHEEAQQAoArygAUECaiICNgK8oAEQJ0HdAEcNAUEAQQAoArygAUECajYCvKABECdBPUcNASAAIAJBACgCnB8RAAAMAQsgAEUNAEEAKAKoHxEBAEEAQQAoArygAUECajYCvKABAkAQJyICQfIARg0AIAJB+wBHDQEQLg8LQQEQEBoLQQAgAUEMajYCvKABCzYBAn9BAEEAKAK8oAFBDGoiADYCvKABECchAQJAAkBBACgCvKABIABHDQAgARA/RQ0BCxAdCwtsAQF/QQBBACgCvKABIgBBDGo2ArygAQJAECdBLkcNAEEAQQAoArygAUECajYCvKABECdB5QBHDQBBACgCvKABQQJqQfgAQfAAQe8AQfIAQfQAQfMAECZFDQBBARAfDwtBACAAQQpqNgK8oAEL6QEBAX9BACEXAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRw0AIAAvAQ4gCEcNACAALwEQIAlHDQAgAC8BEiAKRw0AIAAvARQgC0cN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ACAALwEUIAtHDQAgAC8BFiAMRw0AIAAvARggDUYhDgsgDguoAQECf0EAIQFBACgCvKABIQICQAJAIABB7QBHDQAgAkECakHvAEHkAEH1AEHsAEHlABATRQ0BQQAgAkEMajYCvKABAkAQJ0EuRg0AQQAhAQwCC0EAQQAoArygAUECajYCvKABECchAAsgAEHlAEcNAEEAKAK8oAEiAEEOaiACIABBAmpB+ABB8ABB7wBB8gBB9ABB8wAQJiIBGyECC0EAIAI2ArygASABC2cBAX9BACEKAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRw0AIAAvAQ4gCEcNACAALwEQIAlGIQoLIAoLcQEBf0EAIQsCQCAALwEAIAFHDQAgAC8BAiACRw0AIAAvAQQgA0cNACAALwEGIARHDQAgAC8BCCAFRw0AIAAvAQogBkcNACAALwEMIAdHDQAgAC8BDiAIRw0AIAAvARAgCUcNACAALwESIApGIQsLIAsLgwQBAn9BACECAkAQJ0HPAEcNAEEAIQJBACgCvKABIgNBAmpB4gBB6gBB5QBB4wBB9AAQE0UNAEEAIQJBACADQQxqNgK8oAEQJ0EuRw0AQQBBACgCvKABQQJqNgK8oAECQBAnIgNB8ABHDQBBACECQQAoArygASIDQQJqQfIAQe8AQfQAQe8AQfQAQfkAQfAAQeUAED1FDQFBACECQQAgA0ESajYCvKABECdBLkcNAUEAQQAoArygAUECajYCvKABECchAwtBACECIANB6ABHDQBBACECQQAoArygASIDQQJqQeEAQfMAQc8AQfcAQe4AQdAAQfIAQe8AQfAAQeUAQfIAQfQAQfkAEC9FDQBBACECQQAgA0EcajYCvKABECdBLkcNAEEAIQJBAEEAKAK8oAFBAmo2ArygARAnQeMARw0AQQAhAkEAKAK8oAEiAy8BAkHhAEcNACADLwEEQewARw0AIAMvAQZB7ABHDQBBACECQQAgA0EIajYCvKABECdBKEcNAEEAIQJBAEEAKAK8oAFBAmo2ArygARAnEC1FDQAQJ0EsRw0AQQAhAkEAQQAoArygAUECajYCvKABECcaQQAoArygASIDIAAgAUEBdCIBEEENAEEAIQJBACAD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", "undefined" != typeof window && "function" == typeof atob ? Uint8Array.from(atob(B3), (A3) => A3.charCodeAt(0)) : Buffer.from(B3, "base64")));
    var B3;
    const { exports: E3 } = await WebAssembly.instantiate(Q3);
    A = E3;
  })());
}
var A, Q, g;
var init_lexer = __esm({
  "../../node_modules/cjs-module-lexer/dist/lexer.mjs"() {
    Q = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
  }
});

// ../../node_modules/es-module-lexer/dist/lexer.js
var lexer_exports2 = {};
__export(lexer_exports2, {
  init: () => init2,
  parse: () => parse3
});
function parse3(E3, g2 = "@") {
  if (!C2)
    return init2.then(() => parse3(E3));
  const I = E3.length + 1, k = (C2.__heap_base.value || C2.__heap_base) + 4 * I - C2.memory.buffer.byteLength;
  k > 0 && C2.memory.grow(Math.ceil(k / 65536));
  const K = C2.sa(I - 1);
  if ((A2 ? B2 : Q2)(E3, new Uint16Array(C2.memory.buffer, K, I)), !C2.parse())
    throw Object.assign(new Error(`Parse error ${g2}:${E3.slice(0, C2.e()).split("\n").length}:${C2.e() - E3.lastIndexOf("\n", C2.e() - 1)}`), { idx: C2.e() });
  const o = [], D = [];
  for (; C2.ri(); ) {
    const A3 = C2.is(), Q3 = C2.ie(), B3 = C2.ai(), g3 = C2.id(), I2 = C2.ss(), k2 = C2.se();
    let K2;
    C2.ip() && (K2 = w(E3.slice(-1 === g3 ? A3 - 1 : A3, -1 === g3 ? Q3 + 1 : Q3))), o.push({ n: K2, s: A3, e: Q3, ss: I2, se: k2, d: g3, a: B3 });
  }
  for (; C2.re(); ) {
    const A3 = C2.es(), Q3 = C2.ee(), B3 = C2.els(), g3 = C2.ele(), I2 = E3.slice(A3, Q3), k2 = I2[0], K2 = B3 < 0 ? void 0 : E3.slice(B3, g3), o2 = K2 ? K2[0] : "";
    D.push({ s: A3, e: Q3, ls: B3, le: g3, n: '"' === k2 || "'" === k2 ? w(I2) : I2, ln: '"' === o2 || "'" === o2 ? w(K2) : K2 });
  }
  function w(A3) {
    try {
      return (0, eval)(A3);
    } catch (A4) {
    }
  }
  return [o, D, !!C2.f(), !!C2.ms()];
}
function Q2(A3, Q3) {
  const B3 = A3.length;
  let C3 = 0;
  for (; C3 < B3; ) {
    const B4 = A3.charCodeAt(C3);
    Q3[C3++] = (255 & B4) << 8 | B4 >>> 8;
  }
}
function B2(A3, Q3) {
  const B3 = A3.length;
  let C3 = 0;
  for (; C3 < B3; )
    Q3[C3] = A3.charCodeAt(C3++);
}
var A2, C2, init2, E2;
var init_lexer2 = __esm({
  "../../node_modules/es-module-lexer/dist/lexer.js"() {
    A2 = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
    init2 = WebAssembly.compile((E2 = "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", "undefined" != typeof Buffer ? Buffer.from(E2, "base64") : Uint8Array.from(atob(E2), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
      C2 = A3;
    });
  }
});

// lib/types.js
var import_types = __toESM(require_types(), 1);

// ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function encode(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = "";
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}

// ../../node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa = /* @__PURE__ */ getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString = Object.prototype.toString;
function isObject(thing) {
  return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === "boundary") {
          if (wordRegex.test(original[originalCharIndex])) {
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last;
    if (!first.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// lib/parser.js
var import_HelperManager = __toESM(require_HelperManager(), 1);
var import_NameManager = __toESM(require_NameManager(), 1);
var import_parser = __toESM(require_parser(), 1);
var import_TokenProcessor = __toESM(require_TokenProcessor(), 1);

// lib/sourcemaps.js
import { Buffer as Buffer2 } from "buffer";
import { readFile } from "fs/promises";
import { createRequire } from "module";
import path from "path";
var require2 = createRequire(import.meta.url);
var SourceMapNode = require2("@parcel/source-map").default;
var SOURCEMAP_REGEX = /(?:(\/\*+\s*?sourceMappingURL\s*=)([\s\S]*?)(\*\/))|(?:(\/\/#?\s*?sourceMappingURL\s*=)(.*?)([\r\n]|$))/;
function parseSourcemap(map) {
  return JSON.parse(map);
}
function removeInlineSourcemap(code) {
  return code.split(SOURCEMAP_REGEX)[0];
}
async function loadSourcemap(code, filePath) {
  const match = code.match(SOURCEMAP_REGEX);
  if (match) {
    const mapUrl = match[2] || match[5];
    try {
      let content;
      if (mapUrl.startsWith("data:")) {
        const [mapHeader, mapContent] = mapUrl.split(",");
        if (mapHeader.includes(";base64")) {
          return parseSourcemap(Buffer2.from(mapContent, "base64").toString("ascii"));
        }
        return parseSourcemap(mapContent);
      }
      if (filePath) {
        content = await readFile(path.resolve(path.dirname(filePath), mapUrl), "utf-8");
        return parseSourcemap(content);
      }
    } catch {
    }
  }
  return null;
}
async function mergeSourcemaps(sourceMaps) {
  if (sourceMaps.length === 1) {
    return {
      version: 3,
      ...sourceMaps[0]
    };
  }
  const sourceMap = sourceMaps.reduce(
    /**
     * @param {InstanceType<SourceMapNode>|null} sourceMap
     * @param {SourceMap} map
     * @returns {InstanceType<SourceMapNode>}
     */
    (sourceMap2, map) => {
      const mergedMap = new SourceMapNode();
      mergedMap.addVLQMap(map);
      if (sourceMap2) {
        mergedMap.extends(sourceMap2.toBuffer());
      }
      return mergedMap;
    },
    null
  );
  if (!sourceMap) {
    return null;
  }
  return {
    version: 3,
    ...sourceMap.toVLQ()
  };
}
function inlineSourcemap(code, sourceMap) {
  const match = code.match(SOURCEMAP_REGEX);
  const url = `data:application/json;base64,${Buffer2.from(JSON.stringify(sourceMap)).toString("base64")}`;
  if (!match) {
    return `${code}
//# sourceMappingURL=${url}
`;
  }
  return code.replace(
    SOURCEMAP_REGEX,
    (full, arg1, arg2, arg3, arg4, arg5, arg6) => `${arg1 || arg4}${url}${arg3 || arg6}`
  );
}

// lib/parser.js
function interopImport(mod) {
  return typeof mod.default !== "undefined" ? mod.default : mod;
}
var NameManager = (
  /** @type {typeof import('sucrase/dist/NameManager.js').default} */
  interopImport(import_NameManager.default)
);
var TokenProcessor = (
  /** @type {typeof import('sucrase/dist/types/TokenProcessor').default} */
  interopImport(import_TokenProcessor.default)
);
async function walk(processor, callback) {
  if (processor.isAtEnd()) {
    processor.reset();
  }
  while (!processor.isAtEnd()) {
    const token = processor.currentToken();
    const index = processor.currentIndex();
    let result = callback(token, index, processor);
    if (result instanceof Promise) {
      result = await result;
    }
    if (result === false) {
      return;
    }
    if (processor.isAtEnd()) {
      return;
    }
    processor.nextToken();
  }
}
function parse(inputCode, filePath) {
  const code = removeInlineSourcemap(inputCode);
  const program = (0, import_parser.parse)(code, true, true, false);
  const nameManager = new NameManager(code, program.tokens);
  const helperManager = new import_HelperManager.HelperManager(nameManager);
  const processor = new TokenProcessor(code, program.tokens, false, true, helperManager);
  const magicCode = new MagicString(code);
  let changed = false;
  return {
    program,
    nameManager,
    helperManager,
    processor,
    helpers: {
      /**
       * @param {string} code
       * @param {number} [index]
       */
      prepend(code2, index) {
        changed = true;
        if (index != null) {
          magicCode.prependLeft(index, code2);
        } else {
          magicCode.prepend(code2);
        }
      },
      /**
       * @param {string} code
       * @param {number} [index]
       */
      append(code2, index) {
        changed = true;
        if (index != null) {
          magicCode.appendRight(index, code2);
        } else {
          magicCode.append(code2);
        }
      },
      /**
       * @param {number} start
       * @param {number} end
       * @param {string} code
       */
      overwrite(start, end, code2) {
        changed = true;
        magicCode.overwrite(start, end, code2);
      },
      isDirty() {
        return changed;
      },
      /**
       * @param {{ sourcemap?: boolean|'inline'; sourcesContent?: boolean }} options
       */
      async generate(options = {}) {
        const code2 = magicCode.toString();
        let map = null;
        if (options.sourcemap) {
          const inputSourcemap = await loadSourcemap(inputCode, filePath);
          const newSourcemap = (
            /** @type {import('./sourcemaps.js').SourceMap} */
            magicCode.generateMap({
              source: filePath,
              includeContent: options.sourcesContent,
              hires: true
            })
          );
          map = inputSourcemap ? await mergeSourcemaps([inputSourcemap, newSourcemap]) : newSourcemap;
        }
        if (options.sourcemap === "inline" && map) {
          return {
            code: inlineSourcemap(code2, map),
            map
          };
        }
        return { code: code2, map };
      }
    }
  };
}

// lib/modules.js
var initializeCjs;
async function parseCommonjs(code) {
  initializeCjs = initializeCjs || Promise.resolve().then(() => (init_lexer(), lexer_exports)).then(({ init: init3, parse: parse5 }) => init3().then(() => ({ init: init3, parse: parse5 })));
  const { parse: parse4 } = await initializeCjs;
  return parse4(code);
}
var initializeEsm;
async function parseEsm(code) {
  initializeEsm = initializeEsm || Promise.resolve().then(() => (init_lexer2(), lexer_exports2)).then(({ init: init3, parse: parse5 }) => init3.then(() => ({ init: init3, parse: parse5 })));
  const { parse: parse4 } = await initializeEsm;
  return parse4(code);
}

// lib/helpers.js
function createEmptySourcemapComment() {
  return "\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIiJdLCJtYXBwaW5ncyI6IkEifQ==";
}
function createEmptyModule() {
  return `export default {};${createEmptySourcemapComment()}`;
}
function getIdentifierValue(processor, id) {
  const { tokens } = processor;
  const name = processor.identifierNameForToken(id);
  let index = 0;
  let count = 0;
  let token = tokens[index++];
  while (index < tokens.length) {
    if (token.type === import_types.TokenType.braceL) {
      count++;
      token = tokens[index++];
      continue;
    }
    if (token.type === import_types.TokenType.braceR) {
      count--;
      token = tokens[index++];
      continue;
    }
    if (count) {
      token = tokens[index++];
      continue;
    }
    if (token.type !== import_types.TokenType._var && token.type !== import_types.TokenType._const && token.type !== import_types.TokenType._let) {
      token = tokens[index++];
      continue;
    }
    token = tokens[index++];
    if (token.type !== import_types.TokenType.name || processor.identifierNameForToken(token) !== name) {
      continue;
    }
    index++;
    token = tokens[index++];
    if (token.type !== import_types.TokenType.string) {
      continue;
    }
    return processor.stringValueForToken(token);
  }
}
function getLocation(code, index) {
  let it = 0;
  let line = 1;
  let column = -1;
  if (index > code.length) {
    throw new Error("Token index exceeds source code length");
  }
  while (it <= index) {
    const char = code[it];
    if (char === "\n") {
      line++;
      column = -1;
    } else {
      column++;
    }
    it++;
  }
  return { line, column };
}
function getBlock(processor, openingToken = import_types.TokenType.braceL, closingToken = import_types.TokenType.braceR) {
  let token = processor.currentToken();
  let count = 0;
  const block = [token];
  while (token && (token.type !== closingToken || count > 0)) {
    if (processor.isAtEnd() || token.type === import_types.TokenType.eof) {
      break;
    }
    token = getNextToken(processor);
    if (token) {
      block.push(token);
      if (token.type === openingToken) {
        count++;
      } else if (token.type === closingToken) {
        count--;
      }
    }
  }
  return block;
}
function getStatement(processor) {
  let token = processor.currentToken();
  let count = 0;
  const block = [token];
  while (token && (token.type !== import_types.TokenType.semi || count > 0)) {
    if (processor.isAtEnd() || token.type === import_types.TokenType.eof) {
      break;
    }
    token = getNextToken(processor);
    if (token) {
      block.push(token);
      if (token.type === import_types.TokenType.braceL || token.type === import_types.TokenType.parenL) {
        count++;
      } else if (token.type === import_types.TokenType.braceR || token.type === import_types.TokenType.parenR) {
        count--;
      }
    }
  }
  return block;
}
function splitArgs(tokens) {
  const args = [];
  let currentArg = [];
  let count = 0;
  let token = tokens.shift();
  while (token) {
    if (token.type === import_types.TokenType.braceL || token.type === import_types.TokenType.parenL) {
      count++;
    } else if (token.type === import_types.TokenType.braceR || token.type === import_types.TokenType.parenR) {
      count--;
    }
    if (!count && token.type === import_types.TokenType.comma) {
      args.push(currentArg);
      currentArg = [];
      token = tokens.shift();
      continue;
    }
    currentArg.push(token);
    token = tokens.shift();
  }
  if (currentArg.length) {
    args.push(currentArg);
  }
  return args;
}
function extractFunctionArguments(processor) {
  const args = [];
  let openParens = 0;
  let openBrackets = 0;
  let openBraces = 0;
  let token = processor.currentToken();
  let arg = [];
  while (token && token.type !== import_types.TokenType.parenR || openParens || openBrackets || openBraces) {
    arg.push({
      ...token,
      index: processor.currentIndex()
    });
    token = getNextToken(processor);
    if (!token) {
      break;
    }
    if (token.type === import_types.TokenType.parenL) {
      openParens++;
    }
    if (token.type === import_types.TokenType.parenR && openParens) {
      openParens--;
    }
    if (token.type === import_types.TokenType.bracketL) {
      openBrackets++;
    }
    if (token.type === import_types.TokenType.bracketR) {
      openBrackets--;
    }
    if (token.type === import_types.TokenType.braceL) {
      openBraces++;
    }
    if (token.type === import_types.TokenType.braceR) {
      openBraces--;
    }
    if (token.type === import_types.TokenType.comma && !openParens && !openBrackets && !openBraces) {
      args.push(arg);
      arg = [];
      token = getNextToken(processor);
    }
  }
  args.push(arg);
  return args;
}
function getNextToken(processor) {
  if (processor.isAtEnd()) {
    return null;
  }
  processor.nextToken();
  return processor.currentToken();
}
function nextBlock(processor) {
  let openParens = 0;
  let token = processor.currentToken();
  while (token && (token.type !== import_types.TokenType.parenR || openParens)) {
    if (token.type === import_types.TokenType.parenR) {
      openParens--;
    }
    token = getNextToken(processor);
    if (!token) {
      break;
    }
    if (token && token.type === import_types.TokenType.parenL) {
      openParens++;
    }
  }
}
function getNodeComments(code, start, end) {
  const chunk = code.substring(start, end);
  const matches = chunk.match(/\/\*[\s\S]*?\*\/|(?:[^\\:]|^)\/\/.*$/gm);
  if (!matches) {
    return [];
  }
  return matches.map(
    (comment) => (
      // remove comment delimiters
      comment.trim().replace(/^\/\*+\s*/, "").replace(/\s*\*+\/$/, "").replace(/^\/\/\s*/, "")
    )
  );
}
var export_TokenType = import_types.TokenType;
export {
  NameManager,
  TokenProcessor,
  export_TokenType as TokenType,
  createEmptyModule,
  createEmptySourcemapComment,
  extractFunctionArguments,
  getBlock,
  getIdentifierValue,
  getLocation,
  getNextToken,
  getNodeComments,
  getStatement,
  inlineSourcemap,
  loadSourcemap,
  mergeSourcemaps,
  nextBlock,
  parse,
  parseCommonjs,
  parseEsm,
  parseSourcemap,
  removeInlineSourcemap,
  splitArgs,
  walk
};
//# sourceMappingURL=index.js.map
