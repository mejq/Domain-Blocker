/// <reference types="node" />
/**
 * Create an empty metafile object.
 * @returns {import('esbuild').Metafile}
 */
export function createEmptyMetafile(): import('esbuild').Metafile;
/**
 * Create an hash for the given buffer.
 * @param {Buffer|Uint8Array|string} buffer The buffer input.
 * @returns A buffer hash.
 */
export function createFileHash(buffer: Buffer | Uint8Array | string): string;
/**
 * @param {string} path
 * @param {Buffer} contents
 * @returns {import('esbuild').OutputFile}
 */
export function createOutputFile(path: string, contents: Buffer): import('esbuild').OutputFile;
/**
 * @param {import('esbuild').OutputFile[]} [outputFiles]
 * @param {import('esbuild').Metafile} [metafile]
 * @returns {import('./Build.js').Result}
 */
export function createResult(outputFiles?: import("esbuild").OutputFile[] | undefined, metafile?: import("esbuild").Metafile | undefined): import('./Build.js').Result;
/**
 * Merge esbuild results into a single object
 * that collects all inputs and outputs references, errors and warnings.
 * This is useful when running multiple builds in separated process.
 * @param {import('./Build.js').Result} context
 * @param {import('esbuild').BuildResult & { dependencies?: Record<string, string[]> }} result
 */
export function assignToResult(context: import('./Build.js').Result, result: import("esbuild").BuildResult<import("esbuild").BuildOptions> & {
    dependencies?: Record<string, string[]> | undefined;
}): void;
/**
 * @param {import('./Build.js').Result} result
 * @param {string} from
 * @param {string} to
 * @returns {import('./Build.js').Result}
 */
export function remapResult(result: import('./Build.js').Result, from: string, to: string): import('./Build.js').Result;
/**
 * Check if a plugin is already part of the list.
 * @param {import('esbuild').Plugin[]} plugins The plugins list.
 * @param {string} name The of the plugin to check.
 */
export function hasPlugin(plugins: import('esbuild').Plugin[], name: string): boolean;
import { Buffer } from 'buffer';
