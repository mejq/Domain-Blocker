/// <reference types="node" />
/// <reference types="node" />
/**
 * @typedef {import('esbuild').Message} Message
 */
/**
 * @typedef {import('esbuild').Loader} Loader
 */
/**
 * @typedef {import('esbuild').Platform} Platform
 */
/**
 * @typedef {import('esbuild').Format} Format
 */
/**
 * @typedef {import('esbuild').Plugin} Plugin
 */
/**
 * @typedef {import('esbuild').PluginBuild} PluginBuild
 */
/**
 * @typedef {import('esbuild').BuildOptions} BuildOptions
 */
/**
 * @typedef {import('esbuild').TransformOptions} TransformOptions
 */
/**
 * @typedef {import('esbuild').OnStartResult} OnStartResult
 */
/**
 * @typedef {import('esbuild').ResolveOptions} ResolveOptions
 */
/**
 * @typedef {import('esbuild').ResolveResult} ResolveResult
 */
/**
 * @typedef {import('esbuild').OnResolveOptions} OnResolveOptions
 */
/**
 * @typedef {import('esbuild').OnResolveArgs} OnResolveArgs
 */
/**
 * @typedef {import('esbuild').OnResolveResult} OnResolveResult
 */
/**
 * @typedef {import('esbuild').OnLoadOptions} OnLoadOptions
 */
/**
 * @typedef {import('esbuild').OnLoadArgs} OnLoadArgs
 */
/**
 * @typedef {import('esbuild').OnLoadResult} OnLoadResult
 */
/**
 * @typedef {import('esbuild').BuildResult} BuildResult
 */
/**
 * @typedef {import('esbuild').Metafile} Metafile
 */
/**
 * @typedef {Object} VirtualEntry
 * @property {string} path
 * @property {string|Buffer|Uint8Array} contents
 * @property {Loader} [loader]
 * @property {string} [resolveDir]
 */
/**
 * @typedef {BuildOptions & { path: string; contents?: string | Buffer }} EmitChunkOptions
 */
/**
 * @typedef {Omit<BuildOptions, 'entryPoints'> & { entryPoints: (string | VirtualEntry)[] }} EmitBuildOptions
 */
/**
 * @typedef {(args: OnLoadArgs) => Promise<OnLoadResult | null | undefined> | OnLoadResult | null | undefined} LoadCallback
 */
/**
 * @typedef {BuildResult & { metafile: Metafile; dependencies: Record<string, string[]> }} Result
 */
/**
 * @typedef {Result & { id: string; path: string }} Chunk
 */
/**
 * @typedef {Result & { id: string; path: string }} File
 */
/**
 * @typedef {Object} OnLoadRule
 * @property {OnLoadOptions} options
 * @property {LoadCallback} callback
 */
/**
 * @typedef {Object} OnTransformOptions
 * @property {RegExp} [filter]
 * @property {Loader[]} [loaders]
 * @property {string[]} [extensions]
 * @property {string} [namespace]
 */
/**
 * @typedef {OnLoadArgs & { code?: string | Uint8Array, loader?: Loader, resolveDir?: string }} OnTransformArgs
 */
/**
 * @typedef {Object} OnTransformResult
 * @property {string} [code]
 * @property {import('@chialab/estransform').SourceMap|null} [map]
 * @property {string} [resolveDir]
 * @property {Message[]} [errors]
 * @property {Message[]} [warnings]
 * @property {string[]} [watchFiles]
 * @property {Metafile} [metafile]
 */
/**
 * @typedef {(args: OnLoadArgs & { code: string, loader: Loader, resolveDir?: string }) => Promise<OnTransformResult | null | undefined | void> | OnTransformResult | null | undefined | void} TransformCallback
 */
/**
 * @typedef {Object} OnTransformRule
 * @property {OnTransformOptions} options
 * @property {TransformCallback} callback
 */
/**
 * Esbuild build handler.
 */
export class Build {
    static ENTRY: number;
    static CHUNK: number;
    static ASSET: number;
    /**
     * Create a build instance and state.
     * @param {PluginBuild} build
     * @param {import('./BuildManager.js').BuildManager} manager
     */
    constructor(build: PluginBuild, manager: import('./BuildManager.js').BuildManager);
    /**
     * The current plugin instance.
     * @type {Plugin}
     */
    plugin: Plugin;
    /**
     * The current plugin name.
     * @type {string}
     */
    pluginName: string;
    /**
     * Manager instance.
     * @type {import('./BuildManager.js').BuildManager}
     * @readonly
     * @private
     */
    private readonly manager;
    /**
     * Esbuild plugin build.
     * @type {PluginBuild}
     * @readonly
     * @private
     */
    private readonly pluginBuild;
    /**
     * OnLoad rules.
     * @type {OnLoadRule[]}
     * @readonly
     * @private
     */
    private readonly onLoadRules;
    /**
     * OnTransform rules.
     * @type {OnTransformRule[]}
     * @readonly
     * @private
     */
    private readonly onTransformRules;
    /**
     * Build chunks.
     * @type {Map<string, Chunk>}
     * @readonly
     * @private
     */
    private readonly chunks;
    /**
     * Build files.
     * @type {Map<string, File>}
     * @readonly
     * @private
     */
    private readonly files;
    /**
     * Build sub-builds.
     * @type {Set<Result>}
     * @readonly
     * @private
     */
    private readonly builds;
    /**
     * Build dependencies map.
     * @type {Record<string, string[]>}
     * @readonly
     * @private
     */
    private readonly dependencies;
    initialOptions: {
        define: {
            [x: string]: string;
        };
        external: string[];
        bundle?: boolean | undefined;
        splitting?: boolean | undefined;
        preserveSymlinks?: boolean | undefined;
        outfile?: string | undefined;
        metafile?: boolean | undefined;
        outdir?: string | undefined;
        outbase?: string | undefined;
        packages?: "external" | undefined;
        alias?: Record<string, string> | undefined;
        loader?: {
            [ext: string]: import("esbuild").Loader;
        } | undefined;
        resolveExtensions?: string[] | undefined;
        mainFields?: string[] | undefined;
        conditions?: string[] | undefined;
        write?: boolean | undefined;
        allowOverwrite?: boolean | undefined;
        tsconfig?: string | undefined;
        outExtension?: {
            [ext: string]: string;
        } | undefined;
        publicPath?: string | undefined;
        entryNames?: string | undefined;
        chunkNames?: string | undefined;
        assetNames?: string | undefined;
        inject?: string[] | undefined;
        banner?: {
            [type: string]: string;
        } | undefined;
        footer?: {
            [type: string]: string;
        } | undefined;
        entryPoints?: string[] | Record<string, string> | {
            in: string;
            out: string;
        }[] | undefined;
        stdin?: import("esbuild").StdinOptions | undefined;
        plugins?: import("esbuild").Plugin[] | undefined;
        absWorkingDir?: string | undefined;
        nodePaths?: string[] | undefined;
        sourcemap?: boolean | "external" | "linked" | "inline" | "both" | undefined;
        legalComments?: "external" | "linked" | "inline" | "none" | "eof" | undefined;
        sourceRoot?: string | undefined;
        sourcesContent?: boolean | undefined;
        format?: import("esbuild").Format | undefined;
        globalName?: string | undefined;
        target?: string | string[] | undefined;
        /**
         * @typedef {import('esbuild').OnResolveResult} OnResolveResult
         */
        /**
         * @typedef {import('esbuild').OnLoadOptions} OnLoadOptions
         */
        /**
         * @typedef {import('esbuild').OnLoadArgs} OnLoadArgs
         */
        /**
         * @typedef {import('esbuild').OnLoadResult} OnLoadResult
         */
        /**
         * @typedef {import('esbuild').BuildResult} BuildResult
         */
        /**
         * @typedef {import('esbuild').Metafile} Metafile
         */
        /**
         * @typedef {Object} VirtualEntry
         * @property {string} path
         * @property {string|Buffer|Uint8Array} contents
         * @property {Loader} [loader]
         * @property {string} [resolveDir]
         */
        /**
         * @typedef {BuildOptions & { path: string; contents?: string | Buffer }} EmitChunkOptions
         */
        /**
         * @typedef {Omit<BuildOptions, 'entryPoints'> & { entryPoints: (string | VirtualEntry)[] }} EmitBuildOptions
         */
        /**
         * @typedef {(args: OnLoadArgs) => Promise<OnLoadResult | null | undefined> | OnLoadResult | null | undefined} LoadCallback
         */
        /**
         * @typedef {BuildResult & { metafile: Metafile; dependencies: Record<string, string[]> }} Result
         */
        /**
         * @typedef {Result & { id: string; path: string }} Chunk
         */
        /**
         * @typedef {Result & { id: string; path: string }} File
         */
        /**
         * @typedef {Object} OnLoadRule
         * @property {OnLoadOptions} options
         * @property {LoadCallback} callback
         */
        /**
         * @typedef {Object} OnTransformOptions
         * @property {RegExp} [filter]
         * @property {Loader[]} [loaders]
         * @property {string[]} [extensions]
         * @property {string} [namespace]
         */
        /**
         * @typedef {OnLoadArgs & { code?: string | Uint8Array, loader?: Loader, resolveDir?: string }} OnTransformArgs
         */
        /**
         * @typedef {Object} OnTransformResult
         * @property {string} [code]
         * @property {import('@chialab/estransform').SourceMap|null} [map]
         * @property {string} [resolveDir]
         * @property {Message[]} [errors]
         * @property {Message[]} [warnings]
         * @property {string[]} [watchFiles]
         * @property {Metafile} [metafile]
         */
        /**
         * @typedef {(args: OnLoadArgs & { code: string, loader: Loader, resolveDir?: string }) => Promise<OnTransformResult | null | undefined | void> | OnTransformResult | null | undefined | void} TransformCallback
         */
        /**
         * @typedef {Object} OnTransformRule
         * @property {OnTransformOptions} options
         * @property {TransformCallback} callback
         */
        /**
         * Esbuild build handler.
         */
        supported?: Record<string, boolean> | undefined;
        platform?: import("esbuild").Platform | undefined;
        mangleProps?: RegExp | undefined;
        reserveProps?: RegExp | undefined;
        mangleQuoted?: boolean | undefined;
        mangleCache?: Record<string, string | false> | undefined;
        /**
         * @typedef {BuildOptions & { path: string; contents?: string | Buffer }} EmitChunkOptions
         */
        /**
         * @typedef {Omit<BuildOptions, 'entryPoints'> & { entryPoints: (string | VirtualEntry)[] }} EmitBuildOptions
         */
        /**
         * @typedef {(args: OnLoadArgs) => Promise<OnLoadResult | null | undefined> | OnLoadResult | null | undefined} LoadCallback
         */
        /**
         * @typedef {BuildResult & { metafile: Metafile; dependencies: Record<string, string[]> }} Result
         */
        /**
         * @typedef {Result & { id: string; path: string }} Chunk
         */
        /**
         * @typedef {Result & { id: string; path: string }} File
         */
        /**
         * @typedef {Object} OnLoadRule
         * @property {OnLoadOptions} options
         * @property {LoadCallback} callback
         */
        /**
         * @typedef {Object} OnTransformOptions
         * @property {RegExp} [filter]
         * @property {Loader[]} [loaders]
         * @property {string[]} [extensions]
         * @property {string} [namespace]
         */
        /**
         * @typedef {OnLoadArgs & { code?: string | Uint8Array, loader?: Loader, resolveDir?: string }} OnTransformArgs
         */
        /**
         * @typedef {Object} OnTransformResult
         * @property {string} [code]
         * @property {import('@chialab/estransform').SourceMap|null} [map]
         * @property {string} [resolveDir]
         * @property {Message[]} [errors]
         * @property {Message[]} [warnings]
         * @property {string[]} [watchFiles]
         * @property {Metafile} [metafile]
         */
        /**
         * @typedef {(args: OnLoadArgs & { code: string, loader: Loader, resolveDir?: string }) => Promise<OnTransformResult | null | undefined | void> | OnTransformResult | null | undefined | void} TransformCallback
         */
        /**
         * @typedef {Object} OnTransformRule
         * @property {OnTransformOptions} options
         * @property {TransformCallback} callback
         */
        /**
         * Esbuild build handler.
         */
        drop?: import("esbuild").Drop[] | undefined;
        dropLabels?: string[] | undefined;
        minify?: boolean | undefined;
        minifyWhitespace?: boolean | undefined;
        minifyIdentifiers?: boolean | undefined;
        minifySyntax?: boolean | undefined;
        lineLimit?: number | undefined;
        charset?: import("esbuild").Charset | undefined;
        treeShaking?: boolean | undefined;
        ignoreAnnotations?: boolean | undefined;
        jsx?: "transform" | "preserve" | "automatic" | undefined;
        jsxFactory?: string | undefined;
        jsxFragment?: string | undefined;
        jsxImportSource?: string | undefined;
        jsxDev?: boolean | undefined;
        jsxSideEffects?: boolean | undefined;
        pure?: string[] | undefined;
        keepNames?: boolean | undefined;
        color?: boolean | undefined; /**
         * The current plugin instance.
         * @type {Plugin}
         */
        logLevel?: import("esbuild").LogLevel | undefined;
        logLimit?: number | undefined;
        logOverride?: Record<string, import("esbuild").LogLevel> | undefined;
        tsconfigRaw?: string | import("esbuild").TsconfigRaw | undefined;
    };
    /**
     * Get esbuild instance of the build.
     * @returns A esbuild instance.
     */
    getBuilder(): {
        context: typeof import("esbuild").context;
        build: typeof import("esbuild").build;
        buildSync: typeof import("esbuild").buildSync;
        transform: typeof import("esbuild").transform;
        transformSync: typeof import("esbuild").transformSync;
        formatMessages: typeof import("esbuild").formatMessages;
        formatMessagesSync: typeof import("esbuild").formatMessagesSync;
        analyzeMetafile: typeof import("esbuild").analyzeMetafile;
        analyzeMetafileSync: typeof import("esbuild").analyzeMetafileSync;
        initialize: typeof import("esbuild").initialize;
        version: string;
    };
    /**
     * Get initial build options.
     * @returns The initial options object.
     */
    getInitialOptions(): {
        define: {
            [x: string]: string;
        };
        external: string[];
        bundle?: boolean | undefined;
        splitting?: boolean | undefined;
        preserveSymlinks?: boolean | undefined;
        outfile?: string | undefined;
        metafile?: boolean | undefined;
        outdir?: string | undefined;
        outbase?: string | undefined;
        packages?: "external" | undefined;
        alias?: Record<string, string> | undefined;
        loader?: {
            [ext: string]: import("esbuild").Loader;
        } | undefined;
        resolveExtensions?: string[] | undefined;
        mainFields?: string[] | undefined;
        conditions?: string[] | undefined;
        write?: boolean | undefined;
        allowOverwrite?: boolean | undefined;
        tsconfig?: string | undefined;
        outExtension?: {
            [ext: string]: string;
        } | undefined;
        publicPath?: string | undefined;
        entryNames?: string | undefined;
        chunkNames?: string | undefined;
        assetNames?: string | undefined;
        inject?: string[] | undefined;
        banner?: {
            [type: string]: string;
        } | undefined;
        footer?: {
            [type: string]: string;
        } | undefined;
        entryPoints?: string[] | Record<string, string> | {
            in: string;
            out: string;
        }[] | undefined;
        stdin?: import("esbuild").StdinOptions | undefined;
        plugins?: import("esbuild").Plugin[] | undefined;
        absWorkingDir?: string | undefined;
        nodePaths?: string[] | undefined;
        sourcemap?: boolean | "external" | "linked" | "inline" | "both" | undefined;
        legalComments?: "external" | "linked" | "inline" | "none" | "eof" | undefined;
        sourceRoot?: string | undefined;
        sourcesContent?: boolean | undefined;
        format?: import("esbuild").Format | undefined;
        globalName?: string | undefined;
        target?: string | string[] | undefined;
        /**
         * @typedef {import('esbuild').OnResolveResult} OnResolveResult
         */
        /**
         * @typedef {import('esbuild').OnLoadOptions} OnLoadOptions
         */
        /**
         * @typedef {import('esbuild').OnLoadArgs} OnLoadArgs
         */
        /**
         * @typedef {import('esbuild').OnLoadResult} OnLoadResult
         */
        /**
         * @typedef {import('esbuild').BuildResult} BuildResult
         */
        /**
         * @typedef {import('esbuild').Metafile} Metafile
         */
        /**
         * @typedef {Object} VirtualEntry
         * @property {string} path
         * @property {string|Buffer|Uint8Array} contents
         * @property {Loader} [loader]
         * @property {string} [resolveDir]
         */
        /**
         * @typedef {BuildOptions & { path: string; contents?: string | Buffer }} EmitChunkOptions
         */
        /**
         * @typedef {Omit<BuildOptions, 'entryPoints'> & { entryPoints: (string | VirtualEntry)[] }} EmitBuildOptions
         */
        /**
         * @typedef {(args: OnLoadArgs) => Promise<OnLoadResult | null | undefined> | OnLoadResult | null | undefined} LoadCallback
         */
        /**
         * @typedef {BuildResult & { metafile: Metafile; dependencies: Record<string, string[]> }} Result
         */
        /**
         * @typedef {Result & { id: string; path: string }} Chunk
         */
        /**
         * @typedef {Result & { id: string; path: string }} File
         */
        /**
         * @typedef {Object} OnLoadRule
         * @property {OnLoadOptions} options
         * @property {LoadCallback} callback
         */
        /**
         * @typedef {Object} OnTransformOptions
         * @property {RegExp} [filter]
         * @property {Loader[]} [loaders]
         * @property {string[]} [extensions]
         * @property {string} [namespace]
         */
        /**
         * @typedef {OnLoadArgs & { code?: string | Uint8Array, loader?: Loader, resolveDir?: string }} OnTransformArgs
         */
        /**
         * @typedef {Object} OnTransformResult
         * @property {string} [code]
         * @property {import('@chialab/estransform').SourceMap|null} [map]
         * @property {string} [resolveDir]
         * @property {Message[]} [errors]
         * @property {Message[]} [warnings]
         * @property {string[]} [watchFiles]
         * @property {Metafile} [metafile]
         */
        /**
         * @typedef {(args: OnLoadArgs & { code: string, loader: Loader, resolveDir?: string }) => Promise<OnTransformResult | null | undefined | void> | OnTransformResult | null | undefined | void} TransformCallback
         */
        /**
         * @typedef {Object} OnTransformRule
         * @property {OnTransformOptions} options
         * @property {TransformCallback} callback
         */
        /**
         * Esbuild build handler.
         */
        supported?: Record<string, boolean> | undefined;
        platform?: import("esbuild").Platform | undefined;
        mangleProps?: RegExp | undefined;
        reserveProps?: RegExp | undefined;
        mangleQuoted?: boolean | undefined;
        mangleCache?: Record<string, string | false> | undefined;
        /**
         * @typedef {BuildOptions & { path: string; contents?: string | Buffer }} EmitChunkOptions
         */
        /**
         * @typedef {Omit<BuildOptions, 'entryPoints'> & { entryPoints: (string | VirtualEntry)[] }} EmitBuildOptions
         */
        /**
         * @typedef {(args: OnLoadArgs) => Promise<OnLoadResult | null | undefined> | OnLoadResult | null | undefined} LoadCallback
         */
        /**
         * @typedef {BuildResult & { metafile: Metafile; dependencies: Record<string, string[]> }} Result
         */
        /**
         * @typedef {Result & { id: string; path: string }} Chunk
         */
        /**
         * @typedef {Result & { id: string; path: string }} File
         */
        /**
         * @typedef {Object} OnLoadRule
         * @property {OnLoadOptions} options
         * @property {LoadCallback} callback
         */
        /**
         * @typedef {Object} OnTransformOptions
         * @property {RegExp} [filter]
         * @property {Loader[]} [loaders]
         * @property {string[]} [extensions]
         * @property {string} [namespace]
         */
        /**
         * @typedef {OnLoadArgs & { code?: string | Uint8Array, loader?: Loader, resolveDir?: string }} OnTransformArgs
         */
        /**
         * @typedef {Object} OnTransformResult
         * @property {string} [code]
         * @property {import('@chialab/estransform').SourceMap|null} [map]
         * @property {string} [resolveDir]
         * @property {Message[]} [errors]
         * @property {Message[]} [warnings]
         * @property {string[]} [watchFiles]
         * @property {Metafile} [metafile]
         */
        /**
         * @typedef {(args: OnLoadArgs & { code: string, loader: Loader, resolveDir?: string }) => Promise<OnTransformResult | null | undefined | void> | OnTransformResult | null | undefined | void} TransformCallback
         */
        /**
         * @typedef {Object} OnTransformRule
         * @property {OnTransformOptions} options
         * @property {TransformCallback} callback
         */
        /**
         * Esbuild build handler.
         */
        drop?: import("esbuild").Drop[] | undefined;
        dropLabels?: string[] | undefined;
        minify?: boolean | undefined;
        minifyWhitespace?: boolean | undefined;
        minifyIdentifiers?: boolean | undefined;
        minifySyntax?: boolean | undefined;
        lineLimit?: number | undefined;
        charset?: import("esbuild").Charset | undefined;
        treeShaking?: boolean | undefined;
        ignoreAnnotations?: boolean | undefined;
        jsx?: "transform" | "preserve" | "automatic" | undefined;
        jsxFactory?: string | undefined;
        jsxFragment?: string | undefined;
        jsxImportSource?: string | undefined;
        jsxDev?: boolean | undefined;
        jsxSideEffects?: boolean | undefined;
        pure?: string[] | undefined;
        keepNames?: boolean | undefined;
        color?: boolean | undefined; /**
         * The current plugin instance.
         * @type {Plugin}
         */
        logLevel?: import("esbuild").LogLevel | undefined;
        logLimit?: number | undefined;
        logOverride?: Record<string, import("esbuild").LogLevel> | undefined;
        tsconfigRaw?: string | import("esbuild").TsconfigRaw | undefined;
    };
    /**
     * Get build options.
     * @returns The options object.
     */
    getOptions(): import("esbuild").BuildOptions;
    /**
     * Get build option.
     * @template {keyof BuildOptions} K Option key.
     * @param {K} key The option key to get.
     * @returns {BuildOptions[K]} The option value.
     */
    getOption<K extends keyof import("esbuild").BuildOptions>(key: K): import("esbuild").BuildOptions[K];
    /**
     * Set build option.
     * @template {keyof BuildOptions} K Option key.
     * @param {K} key The option key to update.
     * @param {BuildOptions[K]} value The value to set.
     */
    setOption<K_1 extends keyof import("esbuild").BuildOptions>(key: K_1, value: import("esbuild").BuildOptions[K_1]): void;
    /**
     * Delete a build option.
     * @param {keyof BuildOptions} key The option key to remove.
     */
    deleteOption(key: keyof BuildOptions): void;
    /**
     * Compute the working dir of the build.
     * @returns {string} The working dir.
     */
    getWorkingDir(): string;
    /**
     * Compute the source root of the build.
     * @returns {string} The source root.
     */
    getSourceRoot(): string;
    /**
     * Compute the output base dir of the build.
     * @returns {string} The output base dir.
     */
    getOutBase(): string;
    /**
     * Compute the output dir of the build.
     * @returns {string|undefined} The output dir.
     */
    getOutDir(): string | undefined;
    /**
     * Compute the full output dir of the build.
     * @returns {string|undefined} The full output dir.
     */
    getFullOutDir(): string | undefined;
    /**
     * Get configured build loaders.
     * @returns {{ [ext: string]: Loader }}
     */
    getLoaders(): {
        [ext: string]: import("esbuild").Loader;
    };
    /**
     * Set a loader rule.
     * @param {string} ext The file extension.
     * @param {Loader} loader The loader name.
     */
    setLoader(ext: string, loader: Loader): void;
    /**
     * Get list of build plugins.
     * @returns {Plugin[]} A list of plugin.
     */
    getPlugins(): Plugin[];
    /**
     * Get the defined loader for given file path.
     * @param {string} filePath
     * @returns {Loader|null} The loader name.
     */
    getLoader(filePath: string): Loader | null;
    /**
     * Get the list of emitted chunks.
     * @returns {Map<string, Chunk>} A list of chunks.
     */
    getChunks(): Map<string, Chunk>;
    /**
     * Get the list of emitted files.
     * @returns {Map<string, File>} A list of files.
     */
    getFiles(): Map<string, File>;
    /**
     * Get the list of emitted builds.
     * @returns {Set<Result>} A list of builds.
     */
    getBuilds(): Set<Result>;
    /**
     * Get collected dependencies.
     * @returns {Record<string, string[]>} The dependencies map.
     */
    getDependencies(): Record<string, string[]>;
    /**
     * Check if the build is a chunk of another build.
     * @returns {boolean} True if the build is a chunk.
     */
    isChunk(): boolean;
    /**
     * Register a callback for start hook of the build.
     * @param {() => (OnStartResult | null | void | Promise<OnStartResult | null | void>)} callback The callback to register.
     */
    onStart(callback: () => (OnStartResult | null | void | Promise<OnStartResult | null | void>)): void;
    /**
     * Register a callback for end hook of the build.
     * @param {(result: BuildResult) => void | Promise<void>} callback The callback to register.
     */
    onEnd(callback: (result: BuildResult) => void | Promise<void>): void;
    /**
     * Add a resolution rule for the build.
     * @param {OnResolveOptions} options Resolve options.
     * @param {(args: OnResolveArgs) => OnResolveResult | null | undefined | Promise<OnResolveResult | null | undefined>} callback The callback to register.
     */
    onResolve(options: OnResolveOptions, callback: (args: OnResolveArgs) => OnResolveResult | null | undefined | Promise<OnResolveResult | null | undefined>): void;
    /**
     * Add a load rule for the build.
     * Wrap esbuild onLoad hook in order to use it in the transform pipeline.
     * @param {OnLoadOptions} options Load options.
     * @param {(args: OnLoadArgs) => OnLoadResult | null | undefined | Promise<OnLoadResult | null | undefined>} callback The callback to register.
     */
    onLoad(options: OnLoadOptions, callback: (args: OnLoadArgs) => OnLoadResult | null | undefined | Promise<OnLoadResult | null | undefined>): void;
    /**
     * Add a transform hook to the build.
     * Differently from onLoad, each onTransform callback matched by the resource is invoked.
     * @param {OnTransformOptions} options The filter for onTransform hook.
     * @param {TransformCallback} callback The function to invoke for transformation.
     */
    onTransform(options: OnTransformOptions, callback: TransformCallback): void;
    /**
     * Run esbuild build with given options.
     * @param {BuildOptions} options
     * @returns {Promise<Result>} Build result with manifest.
     */
    build(options: BuildOptions): Promise<Result>;
    /**
     * Use the build system to resolve a specifier.
     * @param {string} path The path to resolve.
     * @param {ResolveOptions} [options] Resolve options.
     * @returns {Promise<ResolveResult>} The resolved module.
     */
    resolve(path: string, options?: import("esbuild").ResolveOptions | undefined): Promise<ResolveResult>;
    /**
     * Iterate build.onLoad hooks in order to programmatically load file contents.
     * @param {OnLoadArgs} args The load arguments.
     * @returns {Promise<OnLoadResult|undefined>} A load result with file contents.
     */
    load(args: OnLoadArgs): Promise<OnLoadResult | undefined>;
    /**
     * Load file contents and exec compatible transformation rules collected by `onTransform`.
     * @param {OnTransformArgs} args The transform arguments.
     * @returns {Promise<OnLoadResult|undefined>} A load result with transform file contents.
     */
    transform(args: OnTransformArgs): Promise<OnLoadResult | undefined>;
    /**
     * Create an hash for the given buffer.
     * @param {Buffer|Uint8Array|string} buffer The buffer input.
     * @returns A buffer hash.
     */
    hash(buffer: Buffer | Uint8Array | string): string;
    /**
     * Create file path replacing esbuild patterns.
     * @see https://esbuild.github.io/api/#chunk-names
     * @param {string} pattern The esbuild pattern.
     * @param {string} filePath The full file path.
     * @param {Buffer|string} buffer The file contents.
     * @returns {string}
     */
    computeName(pattern: string, filePath: string, buffer: Buffer | string): string;
    /**
     * Add a virtual module to the build.
     * @param {VirtualEntry} entry The virtual module entry.
     */
    addVirtualModule(entry: VirtualEntry): void;
    /**
     * Resolve file path from build working dir.
     * @param {string} filePath The file path to resolve.
     * @returns {string} Resolved file path.
     */
    resolvePath(filePath: string): string;
    /**
     * Resolve file path from source root dir.
     * @param {string} filePath The file path to resolve.
     * @returns {string} Resolved file path.
     */
    resolveSourcePath(filePath: string): string;
    /**
     * Resolve file path of an output file.
     * @param {string} filePath The output file path.
     * @param {number} [type] The type of the file.
     * @returns {string} Resolved file path.
     */
    resolveOutputDir(filePath: string, type?: number | undefined): string;
    /**
     * Resolve file path of an output file.
     * @param {string} filePath The output file path.
     * @param {Buffer} buffer The output file buffer.
     * @param {number} [type] The type of the file.
     * @returns {string} Resolved file path.
     */
    resolveOutputFile(filePath: string, buffer: Buffer, type?: number | undefined): string;
    /**
     * Resolve relative file path.
     * @param {string} filePath The path of the imported file.
     * @param {string|null} [from] The path of the importing file.
     * @param {string} [prefix] The prefix to add to the relative path.
     * @returns {string} Relative file path.
     */
    resolveRelativePath(filePath: string, from?: string | null | undefined, prefix?: string | undefined): string;
    /**
     * Get the output name in manifest of a file.
     * @param {string} filePath The output file path.
     * @returns {string} Relative output name.
     */
    getOutputName(filePath: string): string;
    /**
     * Insert dependency plugins in the build plugins list.
     * @param {Plugin[]} plugins A list of required plugins .
     * @param {'before'|'after'} [mode] Where insert the missing plugin.
     * @returns {Promise<void>}
     */
    setupPlugin(plugins: Plugin[], mode?: "before" | "after" | undefined): Promise<void>;
    /**
     * Add dependencies to the build.
     * @param {string} importer The importer path.
     * @param {string[]} dependencies A list of loaded dependencies.
     * @returns {Record<string, string[]>} The updated dependencies map.
     */
    collectDependencies(importer: string, dependencies: string[]): Record<string, string[]>;
    /**
     * Check if path has been emitted by build.
     * @param {string} id The chunk id to check.
     * @returns {boolean} True if path has been emitted by the build.
     */
    isEmittedPath(id: string): boolean;
    /**
     * Programmatically emit file reference.
     * @param {string} source The path of the file.
     * @param {string|Buffer} [buffer] File contents.
     * @param {boolean} [collect] If true, the file will be added to the build.
     * @returns {Promise<File>} The output file reference.
     */
    emitFile(source: string, buffer?: string | Buffer | undefined, collect?: boolean | undefined): Promise<File>;
    /**
     * Programmatically emit a chunk reference.
     * @param {EmitChunkOptions} options Esbuild transform options.
     * @param {boolean} [collect] Collect the output chunk reference.
     * @returns {Promise<Chunk>} The output chunk reference.
     */
    emitChunk(options: EmitChunkOptions, collect?: boolean | undefined): Promise<Chunk>;
    /**
     * Programmatically emit a sub build.
     * @param {EmitBuildOptions} options Esbuild build options.
     * @param {boolean} [collect] Collect the output build reference.
     * @returns {Promise<Result>} The output build reference.
     */
    emitBuild(options: EmitBuildOptions, collect?: boolean | undefined): Promise<Result>;
}
export type Message = import('esbuild').Message;
export type Loader = import('esbuild').Loader;
export type Platform = import('esbuild').Platform;
export type Format = import('esbuild').Format;
export type Plugin = import('esbuild').Plugin;
export type PluginBuild = import('esbuild').PluginBuild;
export type BuildOptions = import('esbuild').BuildOptions;
export type TransformOptions = import('esbuild').TransformOptions;
export type OnStartResult = import('esbuild').OnStartResult;
export type ResolveOptions = import('esbuild').ResolveOptions;
export type ResolveResult = import('esbuild').ResolveResult;
export type OnResolveOptions = import('esbuild').OnResolveOptions;
export type OnResolveArgs = import('esbuild').OnResolveArgs;
export type OnResolveResult = import('esbuild').OnResolveResult;
export type OnLoadOptions = import('esbuild').OnLoadOptions;
export type OnLoadArgs = import('esbuild').OnLoadArgs;
export type OnLoadResult = import('esbuild').OnLoadResult;
export type BuildResult = import('esbuild').BuildResult;
export type Metafile = import('esbuild').Metafile;
export type VirtualEntry = {
    path: string;
    contents: string | Buffer | Uint8Array;
    loader?: import("esbuild").Loader | undefined;
    resolveDir?: string | undefined;
};
export type EmitChunkOptions = BuildOptions & {
    path: string;
    contents?: string | Buffer;
};
export type EmitBuildOptions = Omit<BuildOptions, 'entryPoints'> & {
    entryPoints: (string | VirtualEntry)[];
};
export type LoadCallback = (args: OnLoadArgs) => Promise<OnLoadResult | null | undefined> | OnLoadResult | null | undefined;
export type Result = BuildResult & {
    metafile: Metafile;
    dependencies: Record<string, string[]>;
};
export type Chunk = Result & {
    id: string;
    path: string;
};
export type File = Result & {
    id: string;
    path: string;
};
export type OnLoadRule = {
    options: OnLoadOptions;
    callback: LoadCallback;
};
export type OnTransformOptions = {
    filter?: RegExp | undefined;
    loaders?: import("esbuild").Loader[] | undefined;
    extensions?: string[] | undefined;
    namespace?: string | undefined;
};
export type OnTransformArgs = OnLoadArgs & {
    code?: string | Uint8Array;
    loader?: Loader;
    resolveDir?: string;
};
export type OnTransformResult = {
    code?: string | undefined;
    map?: import("@chialab/estransform").SourceMap | null | undefined;
    resolveDir?: string | undefined;
    errors?: import("esbuild").Message[] | undefined;
    warnings?: import("esbuild").Message[] | undefined;
    watchFiles?: string[] | undefined;
    metafile?: import("esbuild").Metafile | undefined;
};
export type TransformCallback = (args: OnLoadArgs & {
    code: string;
    loader: Loader;
    resolveDir?: string;
}) => Promise<OnTransformResult | null | undefined | void> | OnTransformResult | null | undefined | void;
export type OnTransformRule = {
    options: OnTransformOptions;
    callback: TransformCallback;
};
import { Buffer } from 'buffer';
import path from 'path';
