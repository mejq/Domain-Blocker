import { createRequire as __moduleCreateRequire } from 'module';

const require = __moduleCreateRequire(import.meta.url);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/graceful-fs/polyfills.js"(exports, module) {
    var constants = __require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path4, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path4, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path4, mode, callback) {
          fs3.open(
            path4,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs3.fchmod(fd, mode, function(err2) {
                fs3.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs3.lchmodSync = function(path4, mode) {
          var fd = fs3.openSync(path4, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path4, at, mt, cb) {
            fs3.open(path4, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path4, at, mt) {
            var fd = fs3.openSync(path4, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    var Stream = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path4, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path4, options);
        Stream.call(this);
        var self = this;
        this.path = path4;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path4, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path4, options);
        Stream.call(this);
        this.path = path4;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    var fs2 = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs2[gracefulQueue]);
          __require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module.exports = patch(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream;
      fs3.createWriteStream = createWriteStream;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile;
      function readFile(path4, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path4, options, cb);
        function go$readFile(path5, options2, cb2, startTime) {
          return fs$readFile(path5, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path5, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile;
      function writeFile(path4, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path4, data, options, cb);
        function go$writeFile(path5, data2, options2, cb2, startTime) {
          return fs$writeFile(path5, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path5, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile;
      function appendFile(path4, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path4, data, options, cb);
        function go$appendFile(path5, data2, options2, cb2, startTime) {
          return fs$appendFile(path5, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path5, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path4, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path5, options2, cb2, startTime) {
          return fs$readdir(path5, fs$readdirCallback(
            path5,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path5, options2, cb2, startTime) {
          return fs$readdir(path5, options2, fs$readdirCallback(
            path5,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path4, options, cb);
        function fs$readdirCallback(path5, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path5, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path4, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path4, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path4, options) {
        return new fs3.ReadStream(path4, options);
      }
      function createWriteStream(path4, options) {
        return new fs3.WriteStream(path4, options);
      }
      var fs$open = fs3.open;
      fs3.open = open;
      function open(path4, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path4, flags, mode, cb);
        function go$open(path5, flags2, mode2, cb2, startTime) {
          return fs$open(path5, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path5, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
        if (fs2[gracefulQueue][i].length > 2) {
          fs2[gracefulQueue][i][3] = now;
          fs2[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/enhanced-resolve/lib/CachedInputFileSystem.js
var require_CachedInputFileSystem = __commonJS({
  "../../node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"(exports, module) {
    "use strict";
    var nextTick = __require("process").nextTick;
    var dirname = (path4) => {
      let idx = path4.length - 1;
      while (idx >= 0) {
        const c = path4.charCodeAt(idx);
        if (c === 47 || c === 92)
          break;
        idx--;
      }
      if (idx < 0)
        return "";
      return path4.slice(0, idx);
    };
    var runCallbacks = (callbacks, err, result) => {
      if (callbacks.length === 1) {
        callbacks[0](err, result);
        callbacks.length = 0;
        return;
      }
      let error;
      for (const callback of callbacks) {
        try {
          callback(err, result);
        } catch (e) {
          if (!error)
            error = e;
        }
      }
      callbacks.length = 0;
      if (error)
        throw error;
    };
    var OperationMergerBackend = class {
      /**
       * @param {function} provider async method in filesystem
       * @param {function} syncProvider sync method in filesystem
       * @param {BaseFileSystem} providerContext call context for the provider methods
       */
      constructor(provider, syncProvider, providerContext) {
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = /* @__PURE__ */ new Map();
        this.provide = this._provider ? (
          /**
           * @param {string} path path
           * @param {any} options options
           * @param {function} callback callback
           * @returns {any} result
           */
          (path4, options, callback) => {
            if (typeof options === "function") {
              callback = options;
              options = void 0;
            }
            if (options) {
              return this._provider.call(
                this._providerContext,
                path4,
                options,
                callback
              );
            }
            if (typeof path4 !== "string") {
              callback(new TypeError("path must be a string"));
              return;
            }
            let callbacks = this._activeAsyncOperations.get(path4);
            if (callbacks) {
              callbacks.push(callback);
              return;
            }
            this._activeAsyncOperations.set(path4, callbacks = [callback]);
            provider(
              path4,
              /**
               * @param {Error} err error
               * @param {any} result result
               */
              (err, result) => {
                this._activeAsyncOperations.delete(path4);
                runCallbacks(callbacks, err, result);
              }
            );
          }
        ) : null;
        this.provideSync = this._syncProvider ? (
          /**
           * @param {string} path path
           * @param {any} options options
           * @returns {any} result
           */
          (path4, options) => {
            return this._syncProvider.call(this._providerContext, path4, options);
          }
        ) : null;
      }
      purge() {
      }
      purgeParent() {
      }
    };
    var STORAGE_MODE_IDLE = 0;
    var STORAGE_MODE_SYNC = 1;
    var STORAGE_MODE_ASYNC = 2;
    var CacheBackend = class {
      /**
       * @param {number} duration max cache duration of items
       * @param {function} provider async method
       * @param {function} syncProvider sync method
       * @param {BaseFileSystem} providerContext call context for the provider methods
       */
      constructor(duration, provider, syncProvider, providerContext) {
        this._duration = duration;
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = /* @__PURE__ */ new Map();
        this._data = /* @__PURE__ */ new Map();
        this._levels = [];
        for (let i = 0; i < 10; i++)
          this._levels.push(/* @__PURE__ */ new Set());
        for (let i = 5e3; i < duration; i += 500)
          this._levels.push(/* @__PURE__ */ new Set());
        this._currentLevel = 0;
        this._tickInterval = Math.floor(duration / this._levels.length);
        this._mode = STORAGE_MODE_IDLE;
        this._timeout = void 0;
        this._nextDecay = void 0;
        this.provide = provider ? this.provide.bind(this) : null;
        this.provideSync = syncProvider ? this.provideSync.bind(this) : null;
      }
      /**
       * @param {string} path path
       * @param {any} options options
       * @param {FileSystemCallback<any>} callback callback
       * @returns {void}
       */
      provide(path4, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof path4 !== "string") {
          callback(new TypeError("path must be a string"));
          return;
        }
        if (options) {
          return this._provider.call(
            this._providerContext,
            path4,
            options,
            callback
          );
        }
        if (this._mode === STORAGE_MODE_SYNC) {
          this._enterAsyncMode();
        }
        let cacheEntry = this._data.get(path4);
        if (cacheEntry !== void 0) {
          if (cacheEntry.err)
            return nextTick(callback, cacheEntry.err);
          return nextTick(callback, null, cacheEntry.result);
        }
        let callbacks = this._activeAsyncOperations.get(path4);
        if (callbacks !== void 0) {
          callbacks.push(callback);
          return;
        }
        this._activeAsyncOperations.set(path4, callbacks = [callback]);
        this._provider.call(
          this._providerContext,
          path4,
          /**
           * @param {Error} [err] error
           * @param {any} [result] result
           */
          (err, result) => {
            this._activeAsyncOperations.delete(path4);
            this._storeResult(path4, err, result);
            this._enterAsyncMode();
            runCallbacks(
              /** @type {FileSystemCallback<any>[]} */
              callbacks,
              err,
              result
            );
          }
        );
      }
      /**
       * @param {string} path path
       * @param {any} options options
       * @returns {any} result
       */
      provideSync(path4, options) {
        if (typeof path4 !== "string") {
          throw new TypeError("path must be a string");
        }
        if (options) {
          return this._syncProvider.call(this._providerContext, path4, options);
        }
        if (this._mode === STORAGE_MODE_SYNC) {
          this._runDecays();
        }
        let cacheEntry = this._data.get(path4);
        if (cacheEntry !== void 0) {
          if (cacheEntry.err)
            throw cacheEntry.err;
          return cacheEntry.result;
        }
        const callbacks = this._activeAsyncOperations.get(path4);
        this._activeAsyncOperations.delete(path4);
        let result;
        try {
          result = this._syncProvider.call(this._providerContext, path4);
        } catch (err) {
          this._storeResult(
            path4,
            /** @type {Error} */
            err,
            void 0
          );
          this._enterSyncModeWhenIdle();
          if (callbacks) {
            runCallbacks(
              callbacks,
              /** @type {Error} */
              err,
              void 0
            );
          }
          throw err;
        }
        this._storeResult(path4, void 0, result);
        this._enterSyncModeWhenIdle();
        if (callbacks) {
          runCallbacks(callbacks, void 0, result);
        }
        return result;
      }
      /**
       * @param {string|string[]|Set<string>} [what] what to purge
       */
      purge(what) {
        if (!what) {
          if (this._mode !== STORAGE_MODE_IDLE) {
            this._data.clear();
            for (const level of this._levels) {
              level.clear();
            }
            this._enterIdleMode();
          }
        } else if (typeof what === "string") {
          for (let [key, data] of this._data) {
            if (key.startsWith(what)) {
              this._data.delete(key);
              data.level.delete(key);
            }
          }
          if (this._data.size === 0) {
            this._enterIdleMode();
          }
        } else {
          for (let [key, data] of this._data) {
            for (const item of what) {
              if (key.startsWith(item)) {
                this._data.delete(key);
                data.level.delete(key);
                break;
              }
            }
          }
          if (this._data.size === 0) {
            this._enterIdleMode();
          }
        }
      }
      /**
       * @param {string|string[]|Set<string>} [what] what to purge
       */
      purgeParent(what) {
        if (!what) {
          this.purge();
        } else if (typeof what === "string") {
          this.purge(dirname(what));
        } else {
          const set = /* @__PURE__ */ new Set();
          for (const item of what) {
            set.add(dirname(item));
          }
          this.purge(set);
        }
      }
      /**
       * @param {string} path path
       * @param {undefined | Error} err error
       * @param {any} result result
       */
      _storeResult(path4, err, result) {
        if (this._data.has(path4))
          return;
        const level = this._levels[this._currentLevel];
        this._data.set(path4, { err, result, level });
        level.add(path4);
      }
      _decayLevel() {
        const nextLevel = (this._currentLevel + 1) % this._levels.length;
        const decay = this._levels[nextLevel];
        this._currentLevel = nextLevel;
        for (let item of decay) {
          this._data.delete(item);
        }
        decay.clear();
        if (this._data.size === 0) {
          this._enterIdleMode();
        } else {
          this._nextDecay += this._tickInterval;
        }
      }
      _runDecays() {
        while (
          /** @type {number} */
          this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE
        ) {
          this._decayLevel();
        }
      }
      _enterAsyncMode() {
        let timeout = 0;
        switch (this._mode) {
          case STORAGE_MODE_ASYNC:
            return;
          case STORAGE_MODE_IDLE:
            this._nextDecay = Date.now() + this._tickInterval;
            timeout = this._tickInterval;
            break;
          case STORAGE_MODE_SYNC:
            this._runDecays();
            if (
              /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC}*/
              this._mode === STORAGE_MODE_IDLE
            )
              return;
            timeout = Math.max(
              0,
              /** @type {number} */
              this._nextDecay - Date.now()
            );
            break;
        }
        this._mode = STORAGE_MODE_ASYNC;
        const ref = setTimeout(() => {
          this._mode = STORAGE_MODE_SYNC;
          this._runDecays();
        }, timeout);
        if (ref.unref)
          ref.unref();
        this._timeout = ref;
      }
      _enterSyncModeWhenIdle() {
        if (this._mode === STORAGE_MODE_IDLE) {
          this._mode = STORAGE_MODE_SYNC;
          this._nextDecay = Date.now() + this._tickInterval;
        }
      }
      _enterIdleMode() {
        this._mode = STORAGE_MODE_IDLE;
        this._nextDecay = void 0;
        if (this._timeout)
          clearTimeout(this._timeout);
      }
    };
    var createBackend = (duration, provider, syncProvider, providerContext) => {
      if (duration > 0) {
        return new CacheBackend(duration, provider, syncProvider, providerContext);
      }
      return new OperationMergerBackend(provider, syncProvider, providerContext);
    };
    module.exports = class CachedInputFileSystem {
      /**
       * @param {BaseFileSystem} fileSystem file system
       * @param {number} duration duration in ms files are cached
       */
      constructor(fileSystem, duration) {
        this.fileSystem = fileSystem;
        this._lstatBackend = createBackend(
          duration,
          this.fileSystem.lstat,
          this.fileSystem.lstatSync,
          this.fileSystem
        );
        const lstat = this._lstatBackend.provide;
        this.lstat = /** @type {FileSystem["lstat"]} */
        lstat;
        const lstatSync = this._lstatBackend.provideSync;
        this.lstatSync = /** @type {SyncFileSystem["lstatSync"]} */
        lstatSync;
        this._statBackend = createBackend(
          duration,
          this.fileSystem.stat,
          this.fileSystem.statSync,
          this.fileSystem
        );
        const stat = this._statBackend.provide;
        this.stat = /** @type {FileSystem["stat"]} */
        stat;
        const statSync = this._statBackend.provideSync;
        this.statSync = /** @type {SyncFileSystem["statSync"]} */
        statSync;
        this._readdirBackend = createBackend(
          duration,
          this.fileSystem.readdir,
          this.fileSystem.readdirSync,
          this.fileSystem
        );
        const readdir = this._readdirBackend.provide;
        this.readdir = /** @type {FileSystem["readdir"]} */
        readdir;
        const readdirSync = this._readdirBackend.provideSync;
        this.readdirSync = /** @type {SyncFileSystem["readdirSync"]} */
        readdirSync;
        this._readFileBackend = createBackend(
          duration,
          this.fileSystem.readFile,
          this.fileSystem.readFileSync,
          this.fileSystem
        );
        const readFile = this._readFileBackend.provide;
        this.readFile = /** @type {FileSystem["readFile"]} */
        readFile;
        const readFileSync = this._readFileBackend.provideSync;
        this.readFileSync = /** @type {SyncFileSystem["readFileSync"]} */
        readFileSync;
        this._readJsonBackend = createBackend(
          duration,
          // prettier-ignore
          this.fileSystem.readJson || this.readFile && /**
           * @param {string} path path
           * @param {FileSystemCallback<any>} callback
           */
          ((path4, callback) => {
            this.readFile(path4, (err, buffer) => {
              if (err)
                return callback(err);
              if (!buffer || buffer.length === 0)
                return callback(new Error("No file content"));
              let data;
              try {
                data = JSON.parse(buffer.toString("utf-8"));
              } catch (e) {
                return callback(
                  /** @type {Error} */
                  e
                );
              }
              callback(null, data);
            });
          }),
          // prettier-ignore
          this.fileSystem.readJsonSync || this.readFileSync && /**
           * @param {string} path path
           * @returns {any} result
           */
          ((path4) => {
            const buffer = this.readFileSync(path4);
            const data = JSON.parse(buffer.toString("utf-8"));
            return data;
          }),
          this.fileSystem
        );
        const readJson = this._readJsonBackend.provide;
        this.readJson = /** @type {FileSystem["readJson"]} */
        readJson;
        const readJsonSync = this._readJsonBackend.provideSync;
        this.readJsonSync = /** @type {SyncFileSystem["readJsonSync"]} */
        readJsonSync;
        this._readlinkBackend = createBackend(
          duration,
          this.fileSystem.readlink,
          this.fileSystem.readlinkSync,
          this.fileSystem
        );
        const readlink = this._readlinkBackend.provide;
        this.readlink = /** @type {FileSystem["readlink"]} */
        readlink;
        const readlinkSync = this._readlinkBackend.provideSync;
        this.readlinkSync = /** @type {SyncFileSystem["readlinkSync"]} */
        readlinkSync;
      }
      /**
       * @param {string|string[]|Set<string>} [what] what to purge
       */
      purge(what) {
        this._statBackend.purge(what);
        this._lstatBackend.purge(what);
        this._readdirBackend.purgeParent(what);
        this._readFileBackend.purge(what);
        this._readlinkBackend.purge(what);
        this._readJsonBackend.purge(what);
      }
    };
  }
});

// ../../node_modules/tapable/lib/Hook.js
var require_Hook = __commonJS({
  "../../node_modules/tapable/lib/Hook.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var deprecateContext = util.deprecate(
      () => {
      },
      "Hook.context is deprecated and will be removed"
    );
    var CALL_DELEGATE = function(...args) {
      this.call = this._createCall("sync");
      return this.call(...args);
    };
    var CALL_ASYNC_DELEGATE = function(...args) {
      this.callAsync = this._createCall("async");
      return this.callAsync(...args);
    };
    var PROMISE_DELEGATE = function(...args) {
      this.promise = this._createCall("promise");
      return this.promise(...args);
    };
    var Hook = class {
      constructor(args = [], name = void 0) {
        this._args = args;
        this.name = name;
        this.taps = [];
        this.interceptors = [];
        this._call = CALL_DELEGATE;
        this.call = CALL_DELEGATE;
        this._callAsync = CALL_ASYNC_DELEGATE;
        this.callAsync = CALL_ASYNC_DELEGATE;
        this._promise = PROMISE_DELEGATE;
        this.promise = PROMISE_DELEGATE;
        this._x = void 0;
        this.compile = this.compile;
        this.tap = this.tap;
        this.tapAsync = this.tapAsync;
        this.tapPromise = this.tapPromise;
      }
      compile(options) {
        throw new Error("Abstract: should be overridden");
      }
      _createCall(type) {
        return this.compile({
          taps: this.taps,
          interceptors: this.interceptors,
          args: this._args,
          type
        });
      }
      _tap(type, options, fn) {
        if (typeof options === "string") {
          options = {
            name: options.trim()
          };
        } else if (typeof options !== "object" || options === null) {
          throw new Error("Invalid tap options");
        }
        if (typeof options.name !== "string" || options.name === "") {
          throw new Error("Missing name for tap");
        }
        if (typeof options.context !== "undefined") {
          deprecateContext();
        }
        options = Object.assign({ type, fn }, options);
        options = this._runRegisterInterceptors(options);
        this._insert(options);
      }
      tap(options, fn) {
        this._tap("sync", options, fn);
      }
      tapAsync(options, fn) {
        this._tap("async", options, fn);
      }
      tapPromise(options, fn) {
        this._tap("promise", options, fn);
      }
      _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors) {
          if (interceptor.register) {
            const newOptions = interceptor.register(options);
            if (newOptions !== void 0) {
              options = newOptions;
            }
          }
        }
        return options;
      }
      withOptions(options) {
        const mergeOptions = (opt) => Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);
        return {
          name: this.name,
          tap: (opt, fn) => this.tap(mergeOptions(opt), fn),
          tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),
          tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),
          intercept: (interceptor) => this.intercept(interceptor),
          isUsed: () => this.isUsed(),
          withOptions: (opt) => this.withOptions(mergeOptions(opt))
        };
      }
      isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
      }
      intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
          for (let i = 0; i < this.taps.length; i++) {
            this.taps[i] = interceptor.register(this.taps[i]);
          }
        }
      }
      _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
      }
      _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string") {
          before = /* @__PURE__ */ new Set([item.before]);
        } else if (Array.isArray(item.before)) {
          before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number") {
          stage = item.stage;
        }
        let i = this.taps.length;
        while (i > 0) {
          i--;
          const x = this.taps[i];
          this.taps[i + 1] = x;
          const xStage = x.stage || 0;
          if (before) {
            if (before.has(x.name)) {
              before.delete(x.name);
              continue;
            }
            if (before.size > 0) {
              continue;
            }
          }
          if (xStage > stage) {
            continue;
          }
          i++;
          break;
        }
        this.taps[i] = item;
      }
    };
    Object.setPrototypeOf(Hook.prototype, null);
    module.exports = Hook;
  }
});

// ../../node_modules/tapable/lib/HookCodeFactory.js
var require_HookCodeFactory = __commonJS({
  "../../node_modules/tapable/lib/HookCodeFactory.js"(exports, module) {
    "use strict";
    var HookCodeFactory = class {
      constructor(config) {
        this.config = config;
        this.options = void 0;
        this._args = void 0;
      }
      create(options) {
        this.init(options);
        let fn;
        switch (this.options.type) {
          case "sync":
            fn = new Function(
              this.args(),
              '"use strict";\n' + this.header() + this.contentWithInterceptors({
                onError: (err) => `throw ${err};
`,
                onResult: (result) => `return ${result};
`,
                resultReturns: true,
                onDone: () => "",
                rethrowIfPossible: true
              })
            );
            break;
          case "async":
            fn = new Function(
              this.args({
                after: "_callback"
              }),
              '"use strict";\n' + this.header() + this.contentWithInterceptors({
                onError: (err) => `_callback(${err});
`,
                onResult: (result) => `_callback(null, ${result});
`,
                onDone: () => "_callback();\n"
              })
            );
            break;
          case "promise":
            let errorHelperUsed = false;
            const content = this.contentWithInterceptors({
              onError: (err) => {
                errorHelperUsed = true;
                return `_error(${err});
`;
              },
              onResult: (result) => `_resolve(${result});
`,
              onDone: () => "_resolve();\n"
            });
            let code = "";
            code += '"use strict";\n';
            code += this.header();
            code += "return new Promise((function(_resolve, _reject) {\n";
            if (errorHelperUsed) {
              code += "var _sync = true;\n";
              code += "function _error(_err) {\n";
              code += "if(_sync)\n";
              code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
              code += "else\n";
              code += "_reject(_err);\n";
              code += "};\n";
            }
            code += content;
            if (errorHelperUsed) {
              code += "_sync = false;\n";
            }
            code += "}));\n";
            fn = new Function(this.args(), code);
            break;
        }
        this.deinit();
        return fn;
      }
      setup(instance, options) {
        instance._x = options.taps.map((t) => t.fn);
      }
      /**
       * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
       */
      init(options) {
        this.options = options;
        this._args = options.args.slice();
      }
      deinit() {
        this.options = void 0;
        this._args = void 0;
      }
      contentWithInterceptors(options) {
        if (this.options.interceptors.length > 0) {
          const onError = options.onError;
          const onResult = options.onResult;
          const onDone = options.onDone;
          let code = "";
          for (let i = 0; i < this.options.interceptors.length; i++) {
            const interceptor = this.options.interceptors[i];
            if (interceptor.call) {
              code += `${this.getInterceptor(i)}.call(${this.args({
                before: interceptor.context ? "_context" : void 0
              })});
`;
            }
          }
          code += this.content(
            Object.assign(options, {
              onError: onError && ((err) => {
                let code2 = "";
                for (let i = 0; i < this.options.interceptors.length; i++) {
                  const interceptor = this.options.interceptors[i];
                  if (interceptor.error) {
                    code2 += `${this.getInterceptor(i)}.error(${err});
`;
                  }
                }
                code2 += onError(err);
                return code2;
              }),
              onResult: onResult && ((result) => {
                let code2 = "";
                for (let i = 0; i < this.options.interceptors.length; i++) {
                  const interceptor = this.options.interceptors[i];
                  if (interceptor.result) {
                    code2 += `${this.getInterceptor(i)}.result(${result});
`;
                  }
                }
                code2 += onResult(result);
                return code2;
              }),
              onDone: onDone && (() => {
                let code2 = "";
                for (let i = 0; i < this.options.interceptors.length; i++) {
                  const interceptor = this.options.interceptors[i];
                  if (interceptor.done) {
                    code2 += `${this.getInterceptor(i)}.done();
`;
                  }
                }
                code2 += onDone();
                return code2;
              })
            })
          );
          return code;
        } else {
          return this.content(options);
        }
      }
      header() {
        let code = "";
        if (this.needContext()) {
          code += "var _context = {};\n";
        } else {
          code += "var _context;\n";
        }
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
          code += "var _taps = this.taps;\n";
          code += "var _interceptors = this.interceptors;\n";
        }
        return code;
      }
      needContext() {
        for (const tap of this.options.taps)
          if (tap.context)
            return true;
        return false;
      }
      callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.tap) {
            if (!hasTapCached) {
              code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};
`;
              hasTapCached = true;
            }
            code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});
`;
          }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};
`;
        const tap = this.options.taps[tapIndex];
        switch (tap.type) {
          case "sync":
            if (!rethrowIfPossible) {
              code += `var _hasError${tapIndex} = false;
`;
              code += "try {\n";
            }
            if (onResult) {
              code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                before: tap.context ? "_context" : void 0
              })});
`;
            } else {
              code += `_fn${tapIndex}(${this.args({
                before: tap.context ? "_context" : void 0
              })});
`;
            }
            if (!rethrowIfPossible) {
              code += "} catch(_err) {\n";
              code += `_hasError${tapIndex} = true;
`;
              code += onError("_err");
              code += "}\n";
              code += `if(!_hasError${tapIndex}) {
`;
            }
            if (onResult) {
              code += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              code += onDone();
            }
            if (!rethrowIfPossible) {
              code += "}\n";
            }
            break;
          case "async":
            let cbCode = "";
            if (onResult)
              cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {
`;
            else
              cbCode += `(function(_err${tapIndex}) {
`;
            cbCode += `if(_err${tapIndex}) {
`;
            cbCode += onError(`_err${tapIndex}`);
            cbCode += "} else {\n";
            if (onResult) {
              cbCode += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              cbCode += onDone();
            }
            cbCode += "}\n";
            cbCode += "})";
            code += `_fn${tapIndex}(${this.args({
              before: tap.context ? "_context" : void 0,
              after: cbCode
            })});
`;
            break;
          case "promise":
            code += `var _hasResult${tapIndex} = false;
`;
            code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
              before: tap.context ? "_context" : void 0
            })});
`;
            code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)
`;
            code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');
`;
            code += `_promise${tapIndex}.then((function(_result${tapIndex}) {
`;
            code += `_hasResult${tapIndex} = true;
`;
            if (onResult) {
              code += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              code += onDone();
            }
            code += `}), function(_err${tapIndex}) {
`;
            code += `if(_hasResult${tapIndex}) throw _err${tapIndex};
`;
            code += onError(`_err${tapIndex}`);
            code += "});\n";
            break;
        }
        return code;
      }
      callTapsSeries({
        onError,
        onResult,
        resultReturns,
        onDone,
        doneReturns,
        rethrowIfPossible
      }) {
        if (this.options.taps.length === 0)
          return onDone();
        const firstAsync = this.options.taps.findIndex((t) => t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns;
        let code = "";
        let current = onDone;
        let unrollCounter = 0;
        for (let j = this.options.taps.length - 1; j >= 0; j--) {
          const i = j;
          const unroll = current !== onDone && (this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
          if (unroll) {
            unrollCounter = 0;
            code += `function _next${i}() {
`;
            code += current();
            code += `}
`;
            current = () => `${somethingReturns ? "return " : ""}_next${i}();
`;
          }
          const done = current;
          const doneBreak = (skipDone) => {
            if (skipDone)
              return "";
            return onDone();
          };
          const content = this.callTap(i, {
            onError: (error) => onError(i, error, done, doneBreak),
            onResult: onResult && ((result) => {
              return onResult(i, result, done, doneBreak);
            }),
            onDone: !onResult && done,
            rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
          });
          current = () => content;
        }
        code += current();
        return code;
      }
      callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0)
          return onDone();
        const syncOnly = this.options.taps.every((t) => t.type === "sync");
        let code = "";
        if (!syncOnly) {
          code += "var _looper = (function() {\n";
          code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.loop) {
            code += `${this.getInterceptor(i)}.loop(${this.args({
              before: interceptor.context ? "_context" : void 0
            })});
`;
          }
        }
        code += this.callTapsSeries({
          onError,
          onResult: (i, result, next, doneBreak) => {
            let code2 = "";
            code2 += `if(${result} !== undefined) {
`;
            code2 += "_loop = true;\n";
            if (!syncOnly)
              code2 += "if(_loopAsync) _looper();\n";
            code2 += doneBreak(true);
            code2 += `} else {
`;
            code2 += next();
            code2 += `}
`;
            return code2;
          },
          onDone: onDone && (() => {
            let code2 = "";
            code2 += "if(!_loop) {\n";
            code2 += onDone();
            code2 += "}\n";
            return code2;
          }),
          rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
          code += "_loopAsync = true;\n";
          code += "});\n";
          code += "_looper();\n";
        }
        return code;
      }
      callTapsParallel({
        onError,
        onResult,
        onDone,
        rethrowIfPossible,
        onTap = (i, run) => run()
      }) {
        if (this.options.taps.length <= 1) {
          return this.callTapsSeries({
            onError,
            onResult,
            onDone,
            rethrowIfPossible
          });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};
`;
        if (onDone) {
          code += "var _done = (function() {\n";
          code += onDone();
          code += "});\n";
        }
        for (let i = 0; i < this.options.taps.length; i++) {
          const done = () => {
            if (onDone)
              return "if(--_counter === 0) _done();\n";
            else
              return "--_counter;";
          };
          const doneBreak = (skipDone) => {
            if (skipDone || !onDone)
              return "_counter = 0;\n";
            else
              return "_counter = 0;\n_done();\n";
          };
          code += "if(_counter <= 0) break;\n";
          code += onTap(
            i,
            () => this.callTap(i, {
              onError: (error) => {
                let code2 = "";
                code2 += "if(_counter > 0) {\n";
                code2 += onError(i, error, done, doneBreak);
                code2 += "}\n";
                return code2;
              },
              onResult: onResult && ((result) => {
                let code2 = "";
                code2 += "if(_counter > 0) {\n";
                code2 += onResult(i, result, done, doneBreak);
                code2 += "}\n";
                return code2;
              }),
              onDone: !onResult && (() => {
                return done();
              }),
              rethrowIfPossible
            }),
            done,
            doneBreak
          );
        }
        code += "} while(false);\n";
        return code;
      }
      args({ before, after } = {}) {
        let allArgs = this._args;
        if (before)
          allArgs = [before].concat(allArgs);
        if (after)
          allArgs = allArgs.concat(after);
        if (allArgs.length === 0) {
          return "";
        } else {
          return allArgs.join(", ");
        }
      }
      getTapFn(idx) {
        return `_x[${idx}]`;
      }
      getTap(idx) {
        return `_taps[${idx}]`;
      }
      getInterceptor(idx) {
        return `_interceptors[${idx}]`;
      }
    };
    module.exports = HookCodeFactory;
  }
});

// ../../node_modules/tapable/lib/SyncHook.js
var require_SyncHook = __commonJS({
  "../../node_modules/tapable/lib/SyncHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = SyncHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncHook.prototype = null;
    module.exports = SyncHook;
  }
});

// ../../node_modules/tapable/lib/SyncBailHook.js
var require_SyncBailHook = __commonJS({
  "../../node_modules/tapable/lib/SyncBailHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onResult: (i, result, next) => `if(${result} !== undefined) {
${onResult(
            result
          )};
} else {
${next()}}
`,
          resultReturns,
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncBailHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncBailHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncBailHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncBailHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = SyncBailHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncBailHook.prototype = null;
    module.exports = SyncBailHook;
  }
});

// ../../node_modules/tapable/lib/SyncWaterfallHook.js
var require_SyncWaterfallHook = __commonJS({
  "../../node_modules/tapable/lib/SyncWaterfallHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncWaterfallHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onResult: (i, result, next) => {
            let code = "";
            code += `if(${result} !== undefined) {
`;
            code += `${this._args[0]} = ${result};
`;
            code += `}
`;
            code += next();
            return code;
          },
          onDone: () => onResult(this._args[0]),
          doneReturns: resultReturns,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncWaterfallHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncWaterfallHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncWaterfallHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncWaterfallHook(args = [], name = void 0) {
      if (args.length < 1)
        throw new Error("Waterfall hooks must have at least one argument");
      const hook = new Hook(args, name);
      hook.constructor = SyncWaterfallHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncWaterfallHook.prototype = null;
    module.exports = SyncWaterfallHook;
  }
});

// ../../node_modules/tapable/lib/SyncLoopHook.js
var require_SyncLoopHook = __commonJS({
  "../../node_modules/tapable/lib/SyncLoopHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncLoopHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsLooping({
          onError: (i, err) => onError(err),
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncLoopHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncLoopHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncLoopHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncLoopHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = SyncLoopHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncLoopHook.prototype = null;
    module.exports = SyncLoopHook;
  }
});

// ../../node_modules/tapable/lib/AsyncParallelHook.js
var require_AsyncParallelHook = __commonJS({
  "../../node_modules/tapable/lib/AsyncParallelHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncParallelHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsParallel({
          onError: (i, err, done, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncParallelHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncParallelHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncParallelHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncParallelHook.prototype = null;
    module.exports = AsyncParallelHook;
  }
});

// ../../node_modules/tapable/lib/AsyncParallelBailHook.js
var require_AsyncParallelBailHook = __commonJS({
  "../../node_modules/tapable/lib/AsyncParallelBailHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncParallelBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, onDone }) {
        let code = "";
        code += `var _results = new Array(${this.options.taps.length});
`;
        code += "var _checkDone = function() {\n";
        code += "for(var i = 0; i < _results.length; i++) {\n";
        code += "var item = _results[i];\n";
        code += "if(item === undefined) return false;\n";
        code += "if(item.result !== undefined) {\n";
        code += onResult("item.result");
        code += "return true;\n";
        code += "}\n";
        code += "if(item.error) {\n";
        code += onError("item.error");
        code += "return true;\n";
        code += "}\n";
        code += "}\n";
        code += "return false;\n";
        code += "}\n";
        code += this.callTapsParallel({
          onError: (i, err, done, doneBreak) => {
            let code2 = "";
            code2 += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {
`;
            code2 += doneBreak(true);
            code2 += "} else {\n";
            code2 += done();
            code2 += "}\n";
            return code2;
          },
          onResult: (i, result, done, doneBreak) => {
            let code2 = "";
            code2 += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {
`;
            code2 += doneBreak(true);
            code2 += "} else {\n";
            code2 += done();
            code2 += "}\n";
            return code2;
          },
          onTap: (i, run, done, doneBreak) => {
            let code2 = "";
            if (i > 0) {
              code2 += `if(${i} >= _results.length) {
`;
              code2 += done();
              code2 += "} else {\n";
            }
            code2 += run();
            if (i > 0)
              code2 += "}\n";
            return code2;
          },
          onDone
        });
        return code;
      }
    };
    var factory = new AsyncParallelBailHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncParallelBailHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncParallelBailHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncParallelBailHook.prototype = null;
    module.exports = AsyncParallelBailHook;
  }
});

// ../../node_modules/tapable/lib/AsyncSeriesHook.js
var require_AsyncSeriesHook = __commonJS({
  "../../node_modules/tapable/lib/AsyncSeriesHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncSeriesHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesHook.prototype = null;
    module.exports = AsyncSeriesHook;
  }
});

// ../../node_modules/tapable/lib/AsyncSeriesBailHook.js
var require_AsyncSeriesBailHook = __commonJS({
  "../../node_modules/tapable/lib/AsyncSeriesBailHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onResult: (i, result, next) => `if(${result} !== undefined) {
${onResult(
            result
          )}
} else {
${next()}}
`,
          resultReturns,
          onDone
        });
      }
    };
    var factory = new AsyncSeriesBailHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesBailHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesBailHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesBailHook.prototype = null;
    module.exports = AsyncSeriesBailHook;
  }
});

// ../../node_modules/tapable/lib/AsyncSeriesLoopHook.js
var require_AsyncSeriesLoopHook = __commonJS({
  "../../node_modules/tapable/lib/AsyncSeriesLoopHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesLoopHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsLooping({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncSeriesLoopHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesLoopHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesLoopHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesLoopHook.prototype = null;
    module.exports = AsyncSeriesLoopHook;
  }
});

// ../../node_modules/tapable/lib/AsyncSeriesWaterfallHook.js
var require_AsyncSeriesWaterfallHook = __commonJS({
  "../../node_modules/tapable/lib/AsyncSeriesWaterfallHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesWaterfallHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onResult: (i, result, next) => {
            let code = "";
            code += `if(${result} !== undefined) {
`;
            code += `${this._args[0]} = ${result};
`;
            code += `}
`;
            code += next();
            return code;
          },
          onDone: () => onResult(this._args[0])
        });
      }
    };
    var factory = new AsyncSeriesWaterfallHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesWaterfallHook(args = [], name = void 0) {
      if (args.length < 1)
        throw new Error("Waterfall hooks must have at least one argument");
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesWaterfallHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesWaterfallHook.prototype = null;
    module.exports = AsyncSeriesWaterfallHook;
  }
});

// ../../node_modules/tapable/lib/HookMap.js
var require_HookMap = __commonJS({
  "../../node_modules/tapable/lib/HookMap.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var defaultFactory = (key, hook) => hook;
    var HookMap = class {
      constructor(factory, name = void 0) {
        this._map = /* @__PURE__ */ new Map();
        this.name = name;
        this._factory = factory;
        this._interceptors = [];
      }
      get(key) {
        return this._map.get(key);
      }
      for(key) {
        const hook = this.get(key);
        if (hook !== void 0) {
          return hook;
        }
        let newHook = this._factory(key);
        const interceptors = this._interceptors;
        for (let i = 0; i < interceptors.length; i++) {
          newHook = interceptors[i].factory(key, newHook);
        }
        this._map.set(key, newHook);
        return newHook;
      }
      intercept(interceptor) {
        this._interceptors.push(
          Object.assign(
            {
              factory: defaultFactory
            },
            interceptor
          )
        );
      }
    };
    HookMap.prototype.tap = util.deprecate(function(key, options, fn) {
      return this.for(key).tap(options, fn);
    }, "HookMap#tap(key,\u2026) is deprecated. Use HookMap#for(key).tap(\u2026) instead.");
    HookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {
      return this.for(key).tapAsync(options, fn);
    }, "HookMap#tapAsync(key,\u2026) is deprecated. Use HookMap#for(key).tapAsync(\u2026) instead.");
    HookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {
      return this.for(key).tapPromise(options, fn);
    }, "HookMap#tapPromise(key,\u2026) is deprecated. Use HookMap#for(key).tapPromise(\u2026) instead.");
    module.exports = HookMap;
  }
});

// ../../node_modules/tapable/lib/MultiHook.js
var require_MultiHook = __commonJS({
  "../../node_modules/tapable/lib/MultiHook.js"(exports, module) {
    "use strict";
    var Hook = require_Hook();
    var MultiHook = class _MultiHook {
      constructor(hooks, name = void 0) {
        this.hooks = hooks;
        this.name = name;
      }
      tap(options, fn) {
        for (const hook of this.hooks) {
          hook.tap(options, fn);
        }
      }
      tapAsync(options, fn) {
        for (const hook of this.hooks) {
          hook.tapAsync(options, fn);
        }
      }
      tapPromise(options, fn) {
        for (const hook of this.hooks) {
          hook.tapPromise(options, fn);
        }
      }
      isUsed() {
        for (const hook of this.hooks) {
          if (hook.isUsed())
            return true;
        }
        return false;
      }
      intercept(interceptor) {
        for (const hook of this.hooks) {
          hook.intercept(interceptor);
        }
      }
      withOptions(options) {
        return new _MultiHook(
          this.hooks.map((h) => h.withOptions(options)),
          this.name
        );
      }
    };
    module.exports = MultiHook;
  }
});

// ../../node_modules/tapable/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/tapable/lib/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.SyncHook = require_SyncHook();
    exports.SyncBailHook = require_SyncBailHook();
    exports.SyncWaterfallHook = require_SyncWaterfallHook();
    exports.SyncLoopHook = require_SyncLoopHook();
    exports.AsyncParallelHook = require_AsyncParallelHook();
    exports.AsyncParallelBailHook = require_AsyncParallelBailHook();
    exports.AsyncSeriesHook = require_AsyncSeriesHook();
    exports.AsyncSeriesBailHook = require_AsyncSeriesBailHook();
    exports.AsyncSeriesLoopHook = require_AsyncSeriesLoopHook();
    exports.AsyncSeriesWaterfallHook = require_AsyncSeriesWaterfallHook();
    exports.HookMap = require_HookMap();
    exports.MultiHook = require_MultiHook();
  }
});

// ../../node_modules/enhanced-resolve/lib/createInnerContext.js
var require_createInnerContext = __commonJS({
  "../../node_modules/enhanced-resolve/lib/createInnerContext.js"(exports, module) {
    "use strict";
    module.exports = function createInnerContext(options, message) {
      let messageReported = false;
      let innerLog = void 0;
      if (options.log) {
        if (message) {
          innerLog = (msg) => {
            if (!messageReported) {
              options.log(message);
              messageReported = true;
            }
            options.log("  " + msg);
          };
        } else {
          innerLog = options.log;
        }
      }
      return {
        log: innerLog,
        yield: options.yield,
        fileDependencies: options.fileDependencies,
        contextDependencies: options.contextDependencies,
        missingDependencies: options.missingDependencies,
        stack: options.stack
      };
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/util/identifier.js
var require_identifier = __commonJS({
  "../../node_modules/enhanced-resolve/lib/util/identifier.js"(exports, module) {
    "use strict";
    var PATH_QUERY_FRAGMENT_REGEXP = /^(#?(?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
    function parseIdentifier(identifier) {
      const match = PATH_QUERY_FRAGMENT_REGEXP.exec(identifier);
      if (!match)
        return null;
      return [
        match[1].replace(/\0(.)/g, "$1"),
        match[2] ? match[2].replace(/\0(.)/g, "$1") : "",
        match[3] || ""
      ];
    }
    module.exports.parseIdentifier = parseIdentifier;
  }
});

// ../../node_modules/enhanced-resolve/lib/util/path.js
var require_path = __commonJS({
  "../../node_modules/enhanced-resolve/lib/util/path.js"(exports) {
    "use strict";
    var path4 = __require("path");
    var CHAR_HASH = "#".charCodeAt(0);
    var CHAR_SLASH = "/".charCodeAt(0);
    var CHAR_BACKSLASH = "\\".charCodeAt(0);
    var CHAR_A = "A".charCodeAt(0);
    var CHAR_Z = "Z".charCodeAt(0);
    var CHAR_LOWER_A = "a".charCodeAt(0);
    var CHAR_LOWER_Z = "z".charCodeAt(0);
    var CHAR_DOT = ".".charCodeAt(0);
    var CHAR_COLON = ":".charCodeAt(0);
    var posixNormalize = path4.posix.normalize;
    var winNormalize = path4.win32.normalize;
    var PathType = Object.freeze({
      Empty: 0,
      Normal: 1,
      Relative: 2,
      AbsoluteWin: 3,
      AbsolutePosix: 4,
      Internal: 5
    });
    exports.PathType = PathType;
    var getType = (p) => {
      switch (p.length) {
        case 0:
          return PathType.Empty;
        case 1: {
          const c02 = p.charCodeAt(0);
          switch (c02) {
            case CHAR_DOT:
              return PathType.Relative;
            case CHAR_SLASH:
              return PathType.AbsolutePosix;
            case CHAR_HASH:
              return PathType.Internal;
          }
          return PathType.Normal;
        }
        case 2: {
          const c02 = p.charCodeAt(0);
          switch (c02) {
            case CHAR_DOT: {
              const c13 = p.charCodeAt(1);
              switch (c13) {
                case CHAR_DOT:
                case CHAR_SLASH:
                  return PathType.Relative;
              }
              return PathType.Normal;
            }
            case CHAR_SLASH:
              return PathType.AbsolutePosix;
            case CHAR_HASH:
              return PathType.Internal;
          }
          const c12 = p.charCodeAt(1);
          if (c12 === CHAR_COLON) {
            if (c02 >= CHAR_A && c02 <= CHAR_Z || c02 >= CHAR_LOWER_A && c02 <= CHAR_LOWER_Z) {
              return PathType.AbsoluteWin;
            }
          }
          return PathType.Normal;
        }
      }
      const c0 = p.charCodeAt(0);
      switch (c0) {
        case CHAR_DOT: {
          const c12 = p.charCodeAt(1);
          switch (c12) {
            case CHAR_SLASH:
              return PathType.Relative;
            case CHAR_DOT: {
              const c2 = p.charCodeAt(2);
              if (c2 === CHAR_SLASH)
                return PathType.Relative;
              return PathType.Normal;
            }
          }
          return PathType.Normal;
        }
        case CHAR_SLASH:
          return PathType.AbsolutePosix;
        case CHAR_HASH:
          return PathType.Internal;
      }
      const c1 = p.charCodeAt(1);
      if (c1 === CHAR_COLON) {
        const c2 = p.charCodeAt(2);
        if ((c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {
          return PathType.AbsoluteWin;
        }
      }
      return PathType.Normal;
    };
    exports.getType = getType;
    var normalize = (p) => {
      switch (getType(p)) {
        case PathType.Empty:
          return p;
        case PathType.AbsoluteWin:
          return winNormalize(p);
        case PathType.Relative: {
          const r = posixNormalize(p);
          return getType(r) === PathType.Relative ? r : `./${r}`;
        }
      }
      return posixNormalize(p);
    };
    exports.normalize = normalize;
    var join = (rootPath, request) => {
      if (!request)
        return normalize(rootPath);
      const requestType = getType(request);
      switch (requestType) {
        case PathType.AbsolutePosix:
          return posixNormalize(request);
        case PathType.AbsoluteWin:
          return winNormalize(request);
      }
      switch (getType(rootPath)) {
        case PathType.Normal:
        case PathType.Relative:
        case PathType.AbsolutePosix:
          return posixNormalize(`${rootPath}/${request}`);
        case PathType.AbsoluteWin:
          return winNormalize(`${rootPath}\\${request}`);
      }
      switch (requestType) {
        case PathType.Empty:
          return rootPath;
        case PathType.Relative: {
          const r = posixNormalize(rootPath);
          return getType(r) === PathType.Relative ? r : `./${r}`;
        }
      }
      return posixNormalize(rootPath);
    };
    exports.join = join;
    var joinCache = /* @__PURE__ */ new Map();
    var cachedJoin = (rootPath, request) => {
      let cacheEntry;
      let cache = joinCache.get(rootPath);
      if (cache === void 0) {
        joinCache.set(rootPath, cache = /* @__PURE__ */ new Map());
      } else {
        cacheEntry = cache.get(request);
        if (cacheEntry !== void 0)
          return cacheEntry;
      }
      cacheEntry = join(rootPath, request);
      cache.set(request, cacheEntry);
      return cacheEntry;
    };
    exports.cachedJoin = cachedJoin;
    var checkImportsExportsFieldTarget = (relativePath) => {
      let lastNonSlashIndex = 0;
      let slashIndex = relativePath.indexOf("/", 1);
      let cd = 0;
      while (slashIndex !== -1) {
        const folder = relativePath.slice(lastNonSlashIndex, slashIndex);
        switch (folder) {
          case "..": {
            cd--;
            if (cd < 0)
              return new Error(
                `Trying to access out of package scope. Requesting ${relativePath}`
              );
            break;
          }
          case ".":
            break;
          default:
            cd++;
            break;
        }
        lastNonSlashIndex = slashIndex + 1;
        slashIndex = relativePath.indexOf("/", lastNonSlashIndex);
      }
    };
    exports.checkImportsExportsFieldTarget = checkImportsExportsFieldTarget;
  }
});

// ../../node_modules/enhanced-resolve/lib/Resolver.js
var require_Resolver = __commonJS({
  "../../node_modules/enhanced-resolve/lib/Resolver.js"(exports, module) {
    "use strict";
    var { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require_lib();
    var createInnerContext = require_createInnerContext();
    var { parseIdentifier } = require_identifier();
    var {
      normalize,
      cachedJoin: join,
      getType,
      PathType
    } = require_path();
    function toCamelCase(str) {
      return str.replace(/-([a-z])/g, (str2) => str2.slice(1).toUpperCase());
    }
    var Resolver = class _Resolver {
      /**
       * @param {ResolveStepHook} hook hook
       * @param {ResolveRequest} request request
       * @returns {StackEntry} stack entry
       */
      static createStackEntry(hook, request) {
        return hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.fragment || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
      }
      /**
       * @param {FileSystem} fileSystem a filesystem
       * @param {ResolveOptions} options options
       */
      constructor(fileSystem, options) {
        this.fileSystem = fileSystem;
        this.options = options;
        this.hooks = {
          resolveStep: new SyncHook(["hook", "request"], "resolveStep"),
          noResolve: new SyncHook(["request", "error"], "noResolve"),
          resolve: new AsyncSeriesBailHook(
            ["request", "resolveContext"],
            "resolve"
          ),
          result: new AsyncSeriesHook(["result", "resolveContext"], "result")
        };
      }
      /**
       * @param {string | ResolveStepHook} name hook name or hook itself
       * @returns {ResolveStepHook} the hook
       */
      ensureHook(name) {
        if (typeof name !== "string") {
          return name;
        }
        name = toCamelCase(name);
        if (/^before/.test(name)) {
          return (
            /** @type {ResolveStepHook} */
            this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({
              stage: -10
            })
          );
        }
        if (/^after/.test(name)) {
          return (
            /** @type {ResolveStepHook} */
            this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({
              stage: 10
            })
          );
        }
        const hook = (
          /** @type {KnownHooks & EnsuredHooks} */
          this.hooks[name]
        );
        if (!hook) {
          this.hooks[name] = new AsyncSeriesBailHook(
            ["request", "resolveContext"],
            name
          );
          return (
            /** @type {KnownHooks & EnsuredHooks} */
            this.hooks[name]
          );
        }
        return hook;
      }
      /**
       * @param {string | ResolveStepHook} name hook name or hook itself
       * @returns {ResolveStepHook} the hook
       */
      getHook(name) {
        if (typeof name !== "string") {
          return name;
        }
        name = toCamelCase(name);
        if (/^before/.test(name)) {
          return (
            /** @type {ResolveStepHook} */
            this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({
              stage: -10
            })
          );
        }
        if (/^after/.test(name)) {
          return (
            /** @type {ResolveStepHook} */
            this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({
              stage: 10
            })
          );
        }
        const hook = (
          /** @type {KnownHooks & EnsuredHooks} */
          this.hooks[name]
        );
        if (!hook) {
          throw new Error(`Hook ${name} doesn't exist`);
        }
        return hook;
      }
      /**
       * @param {object} context context information object
       * @param {string} path context path
       * @param {string} request request string
       * @returns {string | false} result
       */
      resolveSync(context, path4, request) {
        let err = void 0;
        let result = void 0;
        let sync = false;
        this.resolve(context, path4, request, {}, (e, r) => {
          err = e;
          result = r;
          sync = true;
        });
        if (!sync) {
          throw new Error(
            "Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!"
          );
        }
        if (err)
          throw err;
        if (result === void 0)
          throw new Error("No result");
        return result;
      }
      /**
       * @param {object} context context information object
       * @param {string} path context path
       * @param {string} request request string
       * @param {ResolveContext} resolveContext resolve context
       * @param {ResolveCallback} callback callback function
       * @returns {void}
       */
      resolve(context, path4, request, resolveContext, callback) {
        if (!context || typeof context !== "object")
          return callback(new Error("context argument is not an object"));
        if (typeof path4 !== "string")
          return callback(new Error("path argument is not a string"));
        if (typeof request !== "string")
          return callback(new Error("request argument is not a string"));
        if (!resolveContext)
          return callback(new Error("resolveContext argument is not set"));
        const obj = {
          context,
          path: path4,
          request
        };
        let yield_;
        let yieldCalled = false;
        let finishYield;
        if (typeof resolveContext.yield === "function") {
          const old = resolveContext.yield;
          yield_ = (obj2) => {
            old(obj2);
            yieldCalled = true;
          };
          finishYield = (result) => {
            if (result) {
              yield_(result);
            }
            callback(null);
          };
        }
        const message = `resolve '${request}' in '${path4}'`;
        const finishResolved = (result) => {
          return callback(
            null,
            result.path === false ? false : `${result.path.replace(/#/g, "\0#")}${result.query ? result.query.replace(/#/g, "\0#") : ""}${result.fragment || ""}`,
            result
          );
        };
        const finishWithoutResolve = (log) => {
          const error = new Error("Can't " + message);
          error.details = log.join("\n");
          this.hooks.noResolve.call(obj, error);
          return callback(error);
        };
        if (resolveContext.log) {
          const parentLog = resolveContext.log;
          const log = [];
          return this.doResolve(
            this.hooks.resolve,
            obj,
            message,
            {
              log: (msg) => {
                parentLog(msg);
                log.push(msg);
              },
              yield: yield_,
              fileDependencies: resolveContext.fileDependencies,
              contextDependencies: resolveContext.contextDependencies,
              missingDependencies: resolveContext.missingDependencies,
              stack: resolveContext.stack
            },
            (err, result) => {
              if (err)
                return callback(err);
              if (yieldCalled || result && yield_) {
                return (
                  /** @type {ResolveContextYield} */
                  finishYield(
                    /** @type {ResolveRequest} */
                    result
                  )
                );
              }
              if (result)
                return finishResolved(result);
              return finishWithoutResolve(log);
            }
          );
        } else {
          return this.doResolve(
            this.hooks.resolve,
            obj,
            message,
            {
              log: void 0,
              yield: yield_,
              fileDependencies: resolveContext.fileDependencies,
              contextDependencies: resolveContext.contextDependencies,
              missingDependencies: resolveContext.missingDependencies,
              stack: resolveContext.stack
            },
            (err, result) => {
              if (err)
                return callback(err);
              if (yieldCalled || result && yield_) {
                return (
                  /** @type {ResolveContextYield} */
                  finishYield(
                    /** @type {ResolveRequest} */
                    result
                  )
                );
              }
              if (result)
                return finishResolved(result);
              const log = [];
              return this.doResolve(
                this.hooks.resolve,
                obj,
                message,
                {
                  log: (msg) => log.push(msg),
                  yield: yield_,
                  stack: resolveContext.stack
                },
                (err2, result2) => {
                  if (err2)
                    return callback(err2);
                  if (yieldCalled || result2 && yield_) {
                    return (
                      /** @type {ResolveContextYield} */
                      finishYield(
                        /** @type {ResolveRequest} */
                        result2
                      )
                    );
                  }
                  return finishWithoutResolve(log);
                }
              );
            }
          );
        }
      }
      /**
       * @param {ResolveStepHook} hook hook
       * @param {ResolveRequest} request request
       * @param {null|string} message string
       * @param {ResolveContext} resolveContext resolver context
       * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback
       * @returns {void}
       */
      doResolve(hook, request, message, resolveContext, callback) {
        const stackEntry = _Resolver.createStackEntry(hook, request);
        let newStack;
        if (resolveContext.stack) {
          newStack = new Set(resolveContext.stack);
          if (resolveContext.stack.has(stackEntry)) {
            const recursionError = new Error(
              "Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  ")
            );
            recursionError.recursion = true;
            if (resolveContext.log)
              resolveContext.log("abort resolving because of recursion");
            return callback(recursionError);
          }
          newStack.add(stackEntry);
        } else {
          newStack = /* @__PURE__ */ new Set([stackEntry]);
        }
        this.hooks.resolveStep.call(hook, request);
        if (hook.isUsed()) {
          const innerContext = createInnerContext(
            {
              log: resolveContext.log,
              yield: resolveContext.yield,
              fileDependencies: resolveContext.fileDependencies,
              contextDependencies: resolveContext.contextDependencies,
              missingDependencies: resolveContext.missingDependencies,
              stack: newStack
            },
            message
          );
          return hook.callAsync(request, innerContext, (err, result) => {
            if (err)
              return callback(err);
            if (result)
              return callback(null, result);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * @param {string} identifier identifier
       * @returns {ParsedIdentifier} parsed identifier
       */
      parse(identifier) {
        const part = {
          request: "",
          query: "",
          fragment: "",
          module: false,
          directory: false,
          file: false,
          internal: false
        };
        const parsedIdentifier = parseIdentifier(identifier);
        if (!parsedIdentifier)
          return part;
        [part.request, part.query, part.fragment] = parsedIdentifier;
        if (part.request.length > 0) {
          part.internal = this.isPrivate(identifier);
          part.module = this.isModule(part.request);
          part.directory = this.isDirectory(part.request);
          if (part.directory) {
            part.request = part.request.slice(0, -1);
          }
        }
        return part;
      }
      /**
       * @param {string} path path
       * @returns {boolean} true, if the path is a module
       */
      isModule(path4) {
        return getType(path4) === PathType.Normal;
      }
      /**
       * @param {string} path path
       * @returns {boolean} true, if the path is private
       */
      isPrivate(path4) {
        return getType(path4) === PathType.Internal;
      }
      /**
       * @param {string} path a path
       * @returns {boolean} true, if the path is a directory path
       */
      isDirectory(path4) {
        return path4.endsWith("/");
      }
      /**
       * @param {string} path path
       * @param {string} request request
       * @returns {string} joined path
       */
      join(path4, request) {
        return join(path4, request);
      }
      /**
       * @param {string} path path
       * @returns {string} normalized path
       */
      normalize(path4) {
        return normalize(path4);
      }
    };
    module.exports = Resolver;
  }
});

// ../../node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js
var require_SyncAsyncFileSystemDecorator = __commonJS({
  "../../node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js"(exports, module) {
    "use strict";
    function SyncAsyncFileSystemDecorator(fs2) {
      this.fs = fs2;
      this.lstat = void 0;
      this.lstatSync = void 0;
      const lstatSync = fs2.lstatSync;
      if (lstatSync) {
        this.lstat = (arg, options, callback) => {
          let result;
          try {
            result = lstatSync.call(fs2, arg);
          } catch (e) {
            return (callback || options)(e);
          }
          (callback || options)(null, result);
        };
        this.lstatSync = (arg, options) => lstatSync.call(fs2, arg, options);
      }
      this.stat = (arg, options, callback) => {
        let result;
        try {
          result = callback ? fs2.statSync(arg, options) : fs2.statSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.statSync = (arg, options) => fs2.statSync(arg, options);
      this.readdir = (arg, options, callback) => {
        let result;
        try {
          result = fs2.readdirSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.readdirSync = (arg, options) => fs2.readdirSync(arg, options);
      this.readFile = (arg, options, callback) => {
        let result;
        try {
          result = fs2.readFileSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.readFileSync = (arg, options) => fs2.readFileSync(arg, options);
      this.readlink = (arg, options, callback) => {
        let result;
        try {
          result = fs2.readlinkSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.readlinkSync = (arg, options) => fs2.readlinkSync(arg, options);
      this.readJson = void 0;
      this.readJsonSync = void 0;
      const readJsonSync = fs2.readJsonSync;
      if (readJsonSync) {
        this.readJson = (arg, options, callback) => {
          let result;
          try {
            result = readJsonSync.call(fs2, arg);
          } catch (e) {
            return (callback || options)(e);
          }
          (callback || options)(null, result);
        };
        this.readJsonSync = (arg, options) => readJsonSync.call(fs2, arg, options);
      }
    }
    module.exports = SyncAsyncFileSystemDecorator;
  }
});

// ../../node_modules/enhanced-resolve/lib/forEachBail.js
var require_forEachBail = __commonJS({
  "../../node_modules/enhanced-resolve/lib/forEachBail.js"(exports, module) {
    "use strict";
    module.exports = function forEachBail(array, iterator, callback) {
      if (array.length === 0)
        return callback();
      let i = 0;
      const next = () => {
        let loop = void 0;
        iterator(
          array[i++],
          (err, result) => {
            if (err || result !== void 0 || i >= array.length) {
              return callback(err, result);
            }
            if (loop === false)
              while (next())
                ;
            loop = true;
          },
          i
        );
        if (!loop)
          loop = false;
        return loop;
      };
      while (next())
        ;
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/DescriptionFileUtils.js
var require_DescriptionFileUtils = __commonJS({
  "../../node_modules/enhanced-resolve/lib/DescriptionFileUtils.js"(exports) {
    "use strict";
    var forEachBail = require_forEachBail();
    function loadDescriptionFile(resolver, directory, filenames, oldInfo, resolveContext, callback) {
      (function findDescriptionFile() {
        if (oldInfo && oldInfo.directory === directory) {
          return callback(null, oldInfo);
        }
        forEachBail(
          filenames,
          /**
           * @param {string} filename filename
           * @param {(err?: null|Error, result?: null|Result) => void} callback callback
           * @returns {void}
           */
          (filename, callback2) => {
            const descriptionFilePath = resolver.join(directory, filename);
            if (resolver.fileSystem.readJson) {
              resolver.fileSystem.readJson(descriptionFilePath, (err, content) => {
                if (err) {
                  if (typeof err.code !== "undefined") {
                    if (resolveContext.missingDependencies) {
                      resolveContext.missingDependencies.add(descriptionFilePath);
                    }
                    return callback2();
                  }
                  if (resolveContext.fileDependencies) {
                    resolveContext.fileDependencies.add(descriptionFilePath);
                  }
                  return onJson(err);
                }
                if (resolveContext.fileDependencies) {
                  resolveContext.fileDependencies.add(descriptionFilePath);
                }
                onJson(
                  null,
                  /** @type {JsonObject} */
                  content
                );
              });
            } else {
              resolver.fileSystem.readFile(descriptionFilePath, (err, content) => {
                if (err) {
                  if (resolveContext.missingDependencies) {
                    resolveContext.missingDependencies.add(descriptionFilePath);
                  }
                  return callback2();
                }
                if (resolveContext.fileDependencies) {
                  resolveContext.fileDependencies.add(descriptionFilePath);
                }
                let json;
                if (content) {
                  try {
                    json = JSON.parse(content.toString());
                  } catch (e) {
                    return onJson(
                      /** @type {Error} */
                      e
                    );
                  }
                } else {
                  return onJson(new Error("No content in file"));
                }
                onJson(null, json);
              });
            }
            function onJson(err, content) {
              if (err) {
                if (resolveContext.log)
                  resolveContext.log(
                    descriptionFilePath + " (directory description file): " + err
                  );
                else
                  err.message = descriptionFilePath + " (directory description file): " + err;
                return callback2(err);
              }
              callback2(null, {
                content: (
                  /** @type {JsonObject} */
                  content
                ),
                directory,
                path: descriptionFilePath
              });
            }
          },
          /**
           * @param {null|Error} [err] error
           * @param {null|Result} [result] result
           * @returns {void}
           */
          (err, result) => {
            if (err)
              return callback(err);
            if (result) {
              return callback(null, result);
            } else {
              const dir = cdUp(directory);
              if (!dir) {
                return callback();
              } else {
                directory = dir;
                return findDescriptionFile();
              }
            }
          }
        );
      })();
    }
    function getField(content, field) {
      if (!content)
        return void 0;
      if (Array.isArray(field)) {
        let current = content;
        for (let j = 0; j < field.length; j++) {
          if (current === null || typeof current !== "object") {
            current = null;
            break;
          }
          current = /** @type {JsonObject} */
          current[field[j]];
        }
        return current;
      } else {
        return content[field];
      }
    }
    function cdUp(directory) {
      if (directory === "/")
        return null;
      const i = directory.lastIndexOf("/"), j = directory.lastIndexOf("\\");
      const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
      if (p < 0)
        return null;
      return directory.slice(0, p || 1);
    }
    exports.loadDescriptionFile = loadDescriptionFile;
    exports.getField = getField;
    exports.cdUp = cdUp;
  }
});

// ../../node_modules/enhanced-resolve/lib/getInnerRequest.js
var require_getInnerRequest = __commonJS({
  "../../node_modules/enhanced-resolve/lib/getInnerRequest.js"(exports, module) {
    "use strict";
    module.exports = function getInnerRequest(resolver, request) {
      if (typeof request.__innerRequest === "string" && request.__innerRequest_request === request.request && request.__innerRequest_relativePath === request.relativePath)
        return request.__innerRequest;
      let innerRequest;
      if (request.request) {
        innerRequest = request.request;
        if (/^\.\.?(?:\/|$)/.test(innerRequest) && request.relativePath) {
          innerRequest = resolver.join(request.relativePath, innerRequest);
        }
      } else {
        innerRequest = request.relativePath;
      }
      request.__innerRequest_request = request.request;
      request.__innerRequest_relativePath = request.relativePath;
      return request.__innerRequest = /** @type {string} */
      innerRequest;
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/AliasFieldPlugin.js
var require_AliasFieldPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/AliasFieldPlugin.js"(exports, module) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var getInnerRequest = require_getInnerRequest();
    module.exports = class AliasFieldPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | Array<string>} field field
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, field, target) {
        this.source = source;
        this.field = field;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AliasFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFileData)
            return callback();
          const innerRequest = getInnerRequest(resolver, request);
          if (!innerRequest)
            return callback();
          const fieldData = DescriptionFileUtils.getField(
            request.descriptionFileData,
            this.field
          );
          if (fieldData === null || typeof fieldData !== "object") {
            if (resolveContext.log)
              resolveContext.log(
                "Field '" + this.field + "' doesn't contain a valid alias configuration"
              );
            return callback();
          }
          const data = Object.prototype.hasOwnProperty.call(
            fieldData,
            innerRequest
          ) ? (
            /** @type {{[Key in string]: JsonPrimitive}} */
            fieldData[innerRequest]
          ) : innerRequest.startsWith("./") ? (
            /** @type {{[Key in string]: JsonPrimitive}} */
            fieldData[innerRequest.slice(2)]
          ) : void 0;
          if (data === innerRequest)
            return callback();
          if (data === void 0)
            return callback();
          if (data === false) {
            const ignoreObj = {
              ...request,
              path: false
            };
            if (typeof resolveContext.yield === "function") {
              resolveContext.yield(ignoreObj);
              return callback(null, null);
            }
            return callback(null, ignoreObj);
          }
          const obj = {
            ...request,
            path: (
              /** @type {string} */
              request.descriptionFileRoot
            ),
            request: (
              /** @type {string} */
              data
            ),
            fullySpecified: false
          };
          resolver.doResolve(
            target,
            obj,
            "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + /** @type {string} */
            data + "'",
            resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (result === void 0)
                return callback(null, null);
              callback(null, result);
            }
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/AliasPlugin.js
var require_AliasPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/AliasPlugin.js"(exports, module) {
    "use strict";
    var forEachBail = require_forEachBail();
    var { PathType, getType } = require_path();
    module.exports = class AliasPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {AliasOption | Array<AliasOption>} options options
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, options, target) {
        this.source = source;
        this.options = Array.isArray(options) ? options : [options];
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const getAbsolutePathWithSlashEnding = (maybeAbsolutePath) => {
          const type = getType(maybeAbsolutePath);
          if (type === PathType.AbsolutePosix || type === PathType.AbsoluteWin) {
            return resolver.join(maybeAbsolutePath, "_").slice(0, -1);
          }
          return null;
        };
        const isSubPath = (path4, maybeSubPath) => {
          const absolutePath = getAbsolutePathWithSlashEnding(maybeSubPath);
          if (!absolutePath)
            return false;
          return path4.startsWith(absolutePath);
        };
        resolver.getHook(this.source).tapAsync("AliasPlugin", (request, resolveContext, callback) => {
          const innerRequest = request.request || request.path;
          if (!innerRequest)
            return callback();
          forEachBail(
            this.options,
            (item, callback2) => {
              let shouldStop = false;
              if (innerRequest === item.name || !item.onlyModule && (request.request ? innerRequest.startsWith(`${item.name}/`) : isSubPath(innerRequest, item.name))) {
                const remainingRequest = innerRequest.slice(item.name.length);
                const resolveWithAlias = (alias, callback3) => {
                  if (alias === false) {
                    const ignoreObj = {
                      ...request,
                      path: false
                    };
                    if (typeof resolveContext.yield === "function") {
                      resolveContext.yield(ignoreObj);
                      return callback3(null, null);
                    }
                    return callback3(null, ignoreObj);
                  }
                  if (innerRequest !== alias && !innerRequest.startsWith(alias + "/")) {
                    shouldStop = true;
                    const newRequestStr = alias + remainingRequest;
                    const obj = {
                      ...request,
                      request: newRequestStr,
                      fullySpecified: false
                    };
                    return resolver.doResolve(
                      target,
                      obj,
                      "aliased with mapping '" + item.name + "': '" + alias + "' to '" + newRequestStr + "'",
                      resolveContext,
                      (err, result) => {
                        if (err)
                          return callback3(err);
                        if (result)
                          return callback3(null, result);
                        return callback3();
                      }
                    );
                  }
                  return callback3();
                };
                const stoppingCallback = (err, result) => {
                  if (err)
                    return callback2(err);
                  if (result)
                    return callback2(null, result);
                  if (shouldStop)
                    return callback2(null, null);
                  return callback2();
                };
                if (Array.isArray(item.alias)) {
                  return forEachBail(
                    item.alias,
                    resolveWithAlias,
                    stoppingCallback
                  );
                } else {
                  return resolveWithAlias(item.alias, stoppingCallback);
                }
              }
              return callback2();
            },
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/AppendPlugin.js
var require_AppendPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/AppendPlugin.js"(exports, module) {
    "use strict";
    module.exports = class AppendPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string} appending appending
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, appending, target) {
        this.source = source;
        this.appending = appending;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AppendPlugin", (request, resolveContext, callback) => {
          const obj = {
            ...request,
            path: request.path + this.appending,
            relativePath: request.relativePath && request.relativePath + this.appending
          };
          resolver.doResolve(
            target,
            obj,
            this.appending,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ConditionalPlugin.js
var require_ConditionalPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ConditionalPlugin.js"(exports, module) {
    "use strict";
    module.exports = class ConditionalPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {Partial<ResolveRequest>} test compare object
       * @param {string | null} message log message
       * @param {boolean} allowAlternatives when false, do not continue with the current step when "test" matches
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, test, message, allowAlternatives, target) {
        this.source = source;
        this.test = test;
        this.message = message;
        this.allowAlternatives = allowAlternatives;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const { test, message, allowAlternatives } = this;
        const keys = (
          /** @type {(keyof ResolveRequest)[]} */
          Object.keys(test)
        );
        resolver.getHook(this.source).tapAsync("ConditionalPlugin", (request, resolveContext, callback) => {
          for (const prop of keys) {
            if (request[prop] !== test[prop])
              return callback();
          }
          resolver.doResolve(
            target,
            request,
            message,
            resolveContext,
            allowAlternatives ? callback : (err, result) => {
              if (err)
                return callback(err);
              if (result === void 0)
                return callback(null, null);
              callback(null, result);
            }
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js
var require_DescriptionFilePlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js"(exports, module) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    module.exports = class DescriptionFilePlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string[]} filenames filenames
       * @param {boolean} pathIsFile pathIsFile
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, filenames, pathIsFile, target) {
        this.source = source;
        this.filenames = filenames;
        this.pathIsFile = pathIsFile;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "DescriptionFilePlugin",
          (request, resolveContext, callback) => {
            const path4 = request.path;
            if (!path4)
              return callback();
            const directory = this.pathIsFile ? DescriptionFileUtils.cdUp(path4) : path4;
            if (!directory)
              return callback();
            DescriptionFileUtils.loadDescriptionFile(
              resolver,
              directory,
              this.filenames,
              request.descriptionFilePath ? {
                path: request.descriptionFilePath,
                content: request.descriptionFileData,
                directory: (
                  /** @type {string} */
                  request.descriptionFileRoot
                )
              } : void 0,
              resolveContext,
              (err, result) => {
                if (err)
                  return callback(err);
                if (!result) {
                  if (resolveContext.log)
                    resolveContext.log(
                      `No description file found in ${directory} or above`
                    );
                  return callback();
                }
                const relativePath = "." + path4.slice(result.directory.length).replace(/\\/g, "/");
                const obj = {
                  ...request,
                  descriptionFilePath: result.path,
                  descriptionFileData: result.content,
                  descriptionFileRoot: result.directory,
                  relativePath
                };
                resolver.doResolve(
                  target,
                  obj,
                  "using description file: " + result.path + " (relative path: " + relativePath + ")",
                  resolveContext,
                  (err2, result2) => {
                    if (err2)
                      return callback(err2);
                    if (result2 === void 0)
                      return callback(null, null);
                    callback(null, result2);
                  }
                );
              }
            );
          }
        );
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js
var require_DirectoryExistsPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js"(exports, module) {
    "use strict";
    module.exports = class DirectoryExistsPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "DirectoryExistsPlugin",
          (request, resolveContext, callback) => {
            const fs2 = resolver.fileSystem;
            const directory = request.path;
            if (!directory)
              return callback();
            fs2.stat(directory, (err, stat) => {
              if (err || !stat) {
                if (resolveContext.missingDependencies)
                  resolveContext.missingDependencies.add(directory);
                if (resolveContext.log)
                  resolveContext.log(directory + " doesn't exist");
                return callback();
              }
              if (!stat.isDirectory()) {
                if (resolveContext.missingDependencies)
                  resolveContext.missingDependencies.add(directory);
                if (resolveContext.log)
                  resolveContext.log(directory + " is not a directory");
                return callback();
              }
              if (resolveContext.fileDependencies)
                resolveContext.fileDependencies.add(directory);
              resolver.doResolve(
                target,
                request,
                `existing directory ${directory}`,
                resolveContext,
                callback
              );
            });
          }
        );
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/util/entrypoints.js
var require_entrypoints = __commonJS({
  "../../node_modules/enhanced-resolve/lib/util/entrypoints.js"(exports, module) {
    "use strict";
    var slashCode = "/".charCodeAt(0);
    var dotCode = ".".charCodeAt(0);
    var hashCode = "#".charCodeAt(0);
    var patternRegEx = /\*/g;
    module.exports.processExportsField = function processExportsField(exportsField) {
      return createFieldProcessor(
        buildExportsField(exportsField),
        (request) => request.length === 0 ? "." : "./" + request,
        assertExportsFieldRequest,
        assertExportTarget
      );
    };
    module.exports.processImportsField = function processImportsField(importsField) {
      return createFieldProcessor(
        buildImportsField(importsField),
        (request) => "#" + request,
        assertImportsFieldRequest,
        assertImportTarget
      );
    };
    function createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {
      return function fieldProcessor(request, conditionNames) {
        request = assertRequest(request);
        const match = findMatch(normalizeRequest(request), field);
        if (match === null)
          return [];
        const [mapping, remainingRequest, isSubpathMapping, isPattern] = match;
        let direct = null;
        if (isConditionalMapping(mapping)) {
          direct = conditionalMapping(
            /** @type {ConditionalMapping} */
            mapping,
            conditionNames
          );
          if (direct === null)
            return [];
        } else {
          direct = /** @type {DirectMapping} */
          mapping;
        }
        return directMapping(
          remainingRequest,
          isPattern,
          isSubpathMapping,
          direct,
          conditionNames,
          assertTarget
        );
      };
    }
    function assertExportsFieldRequest(request) {
      if (request.charCodeAt(0) !== dotCode) {
        throw new Error('Request should be relative path and start with "."');
      }
      if (request.length === 1)
        return "";
      if (request.charCodeAt(1) !== slashCode) {
        throw new Error('Request should be relative path and start with "./"');
      }
      if (request.charCodeAt(request.length - 1) === slashCode) {
        throw new Error("Only requesting file allowed");
      }
      return request.slice(2);
    }
    function assertImportsFieldRequest(request) {
      if (request.charCodeAt(0) !== hashCode) {
        throw new Error('Request should start with "#"');
      }
      if (request.length === 1) {
        throw new Error("Request should have at least 2 characters");
      }
      if (request.charCodeAt(1) === slashCode) {
        throw new Error('Request should not start with "#/"');
      }
      if (request.charCodeAt(request.length - 1) === slashCode) {
        throw new Error("Only requesting file allowed");
      }
      return request.slice(1);
    }
    function assertExportTarget(exp, expectFolder) {
      if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {
        throw new Error(
          `Export should be relative path and start with "./", got ${JSON.stringify(
            exp
          )}.`
        );
      }
      const isFolder = exp.charCodeAt(exp.length - 1) === slashCode;
      if (isFolder !== expectFolder) {
        throw new Error(
          expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(
            exp
          )} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(
            exp
          )} should not end with "/"`
        );
      }
    }
    function assertImportTarget(imp, expectFolder) {
      const isFolder = imp.charCodeAt(imp.length - 1) === slashCode;
      if (isFolder !== expectFolder) {
        throw new Error(
          expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(
            imp
          )} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(
            imp
          )} should not end with "/"`
        );
      }
    }
    function patternKeyCompare(a, b) {
      const aPatternIndex = a.indexOf("*");
      const bPatternIndex = b.indexOf("*");
      const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
      const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
      if (baseLenA > baseLenB)
        return -1;
      if (baseLenB > baseLenA)
        return 1;
      if (aPatternIndex === -1)
        return 1;
      if (bPatternIndex === -1)
        return -1;
      if (a.length > b.length)
        return -1;
      if (b.length > a.length)
        return 1;
      return 0;
    }
    function findMatch(request, field) {
      if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes("*") && !request.endsWith("/")) {
        const target2 = (
          /** @type {{[k: string]: MappingValue}} */
          field[request]
        );
        return [target2, "", false, false];
      }
      let bestMatch = "";
      let bestMatchSubpath;
      const keys = Object.getOwnPropertyNames(field);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {
          const patternTrailer = key.slice(patternIndex + 1);
          if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
            bestMatch = key;
            bestMatchSubpath = request.slice(
              patternIndex,
              request.length - patternTrailer.length
            );
          }
        } else if (key[key.length - 1] === "/" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {
          bestMatch = key;
          bestMatchSubpath = request.slice(key.length);
        }
      }
      if (bestMatch === "")
        return null;
      const target = (
        /** @type {{[k: string]: MappingValue}} */
        field[bestMatch]
      );
      const isSubpathMapping = bestMatch.endsWith("/");
      const isPattern = bestMatch.includes("*");
      return [
        target,
        /** @type {string} */
        bestMatchSubpath,
        isSubpathMapping,
        isPattern
      ];
    }
    function isConditionalMapping(mapping) {
      return mapping !== null && typeof mapping === "object" && !Array.isArray(mapping);
    }
    function directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {
      if (mappingTarget === null)
        return [];
      if (typeof mappingTarget === "string") {
        return [
          targetMapping(
            remainingRequest,
            isPattern,
            isSubpathMapping,
            mappingTarget,
            assert
          )
        ];
      }
      const targets = [];
      for (const exp of mappingTarget) {
        if (typeof exp === "string") {
          targets.push(
            targetMapping(
              remainingRequest,
              isPattern,
              isSubpathMapping,
              exp,
              assert
            )
          );
          continue;
        }
        const mapping = conditionalMapping(exp, conditionNames);
        if (!mapping)
          continue;
        const innerExports = directMapping(
          remainingRequest,
          isPattern,
          isSubpathMapping,
          mapping,
          conditionNames,
          assert
        );
        for (const innerExport of innerExports) {
          targets.push(innerExport);
        }
      }
      return targets;
    }
    function targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {
      if (remainingRequest === void 0) {
        assert(mappingTarget, false);
        return mappingTarget;
      }
      if (isSubpathMapping) {
        assert(mappingTarget, true);
        return mappingTarget + remainingRequest;
      }
      assert(mappingTarget, false);
      let result = mappingTarget;
      if (isPattern) {
        result = result.replace(
          patternRegEx,
          remainingRequest.replace(/\$/g, "$$")
        );
      }
      return result;
    }
    function conditionalMapping(conditionalMapping_, conditionNames) {
      let lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];
      loop:
        while (lookup.length > 0) {
          const [mapping, conditions, j] = lookup[lookup.length - 1];
          const last = conditions.length - 1;
          for (let i = j; i < conditions.length; i++) {
            const condition = conditions[i];
            if (i !== last) {
              if (condition === "default") {
                throw new Error("Default condition should be last one");
              }
            } else if (condition === "default") {
              const innerMapping = mapping[condition];
              if (isConditionalMapping(innerMapping)) {
                const conditionalMapping2 = (
                  /** @type {ConditionalMapping} */
                  innerMapping
                );
                lookup[lookup.length - 1][2] = i + 1;
                lookup.push([conditionalMapping2, Object.keys(conditionalMapping2), 0]);
                continue loop;
              }
              return (
                /** @type {DirectMapping} */
                innerMapping
              );
            }
            if (conditionNames.has(condition)) {
              const innerMapping = mapping[condition];
              if (isConditionalMapping(innerMapping)) {
                const conditionalMapping2 = (
                  /** @type {ConditionalMapping} */
                  innerMapping
                );
                lookup[lookup.length - 1][2] = i + 1;
                lookup.push([conditionalMapping2, Object.keys(conditionalMapping2), 0]);
                continue loop;
              }
              return (
                /** @type {DirectMapping} */
                innerMapping
              );
            }
          }
          lookup.pop();
        }
      return null;
    }
    function buildExportsField(field) {
      if (typeof field === "string" || Array.isArray(field)) {
        return { ".": field };
      }
      const keys = Object.keys(field);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key.charCodeAt(0) !== dotCode) {
          if (i === 0) {
            while (i < keys.length) {
              const charCode = keys[i].charCodeAt(0);
              if (charCode === dotCode || charCode === slashCode) {
                throw new Error(
                  `Exports field key should be relative path and start with "." (key: ${JSON.stringify(
                    key
                  )})`
                );
              }
              i++;
            }
            return { ".": field };
          }
          throw new Error(
            `Exports field key should be relative path and start with "." (key: ${JSON.stringify(
              key
            )})`
          );
        }
        if (key.length === 1) {
          continue;
        }
        if (key.charCodeAt(1) !== slashCode) {
          throw new Error(
            `Exports field key should be relative path and start with "./" (key: ${JSON.stringify(
              key
            )})`
          );
        }
      }
      return field;
    }
    function buildImportsField(field) {
      const keys = Object.keys(field);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key.charCodeAt(0) !== hashCode) {
          throw new Error(
            `Imports field key should start with "#" (key: ${JSON.stringify(key)})`
          );
        }
        if (key.length === 1) {
          throw new Error(
            `Imports field key should have at least 2 characters (key: ${JSON.stringify(
              key
            )})`
          );
        }
        if (key.charCodeAt(1) === slashCode) {
          throw new Error(
            `Imports field key should not start with "#/" (key: ${JSON.stringify(
              key
            )})`
          );
        }
      }
      return field;
    }
  }
});

// ../../node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js
var require_ExportsFieldPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var forEachBail = require_forEachBail();
    var { processExportsField } = require_entrypoints();
    var { parseIdentifier } = require_identifier();
    var { checkImportsExportsFieldTarget } = require_path();
    module.exports = class ExportsFieldPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {Set<string>} conditionNames condition names
       * @param {string | string[]} fieldNamePath name path
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, conditionNames, fieldNamePath, target) {
        this.source = source;
        this.target = target;
        this.conditionNames = conditionNames;
        this.fieldName = fieldNamePath;
        this.fieldProcessorCache = /* @__PURE__ */ new WeakMap();
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ExportsFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFilePath)
            return callback();
          if (
            // When the description file is inherited from parent, abort
            // (There is no description file inside of this package)
            request.relativePath !== "." || request.request === void 0
          )
            return callback();
          const remainingRequest = request.query || request.fragment ? (request.request === "." ? "./" : request.request) + request.query + request.fragment : request.request;
          const exportsField = (
            /** @type {ExportsField|null|undefined} */
            DescriptionFileUtils.getField(
              /** @type {JsonObject} */
              request.descriptionFileData,
              this.fieldName
            )
          );
          if (!exportsField)
            return callback();
          if (request.directory) {
            return callback(
              new Error(
                `Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`
              )
            );
          }
          let paths;
          try {
            let fieldProcessor = this.fieldProcessorCache.get(
              /** @type {JsonObject} */
              request.descriptionFileData
            );
            if (fieldProcessor === void 0) {
              fieldProcessor = processExportsField(exportsField);
              this.fieldProcessorCache.set(
                /** @type {JsonObject} */
                request.descriptionFileData,
                fieldProcessor
              );
            }
            paths = fieldProcessor(remainingRequest, this.conditionNames);
          } catch (err) {
            if (resolveContext.log) {
              resolveContext.log(
                `Exports field in ${request.descriptionFilePath} can't be processed: ${err}`
              );
            }
            return callback(
              /** @type {Error} */
              err
            );
          }
          if (paths.length === 0) {
            return callback(
              new Error(
                `Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`
              )
            );
          }
          forEachBail(
            paths,
            /**
             * @param {string} p path
             * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
             * @returns {void}
             */
            (p, callback2) => {
              const parsedIdentifier = parseIdentifier(p);
              if (!parsedIdentifier)
                return callback2();
              const [relativePath, query, fragment] = parsedIdentifier;
              const error = checkImportsExportsFieldTarget(relativePath);
              if (error) {
                return callback2(error);
              }
              const obj = {
                ...request,
                request: void 0,
                path: path4.join(
                  /** @type {string} */
                  request.descriptionFileRoot,
                  relativePath
                ),
                relativePath,
                query,
                fragment
              };
              resolver.doResolve(
                target,
                obj,
                "using exports field: " + p,
                resolveContext,
                callback2
              );
            },
            /**
             * @param {null|Error} [err] error
             * @param {null|ResolveRequest} [result] result
             * @returns {void}
             */
            (err, result) => callback(err, result || null)
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js
var require_ExtensionAliasPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js"(exports, module) {
    "use strict";
    var forEachBail = require_forEachBail();
    module.exports = class ExtensionAliasPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {ExtensionAliasOption} options options
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const { extension, alias } = this.options;
        resolver.getHook(this.source).tapAsync("ExtensionAliasPlugin", (request, resolveContext, callback) => {
          const requestPath = request.request;
          if (!requestPath || !requestPath.endsWith(extension))
            return callback();
          const isAliasString = typeof alias === "string";
          const resolve2 = (alias2, callback2, index) => {
            const newRequest = `${requestPath.slice(
              0,
              -extension.length
            )}${alias2}`;
            return resolver.doResolve(
              target,
              {
                ...request,
                request: newRequest,
                fullySpecified: true
              },
              `aliased from extension alias with mapping '${extension}' to '${alias2}'`,
              resolveContext,
              (err, result) => {
                if (!isAliasString && index) {
                  if (index !== this.options.alias.length) {
                    if (resolveContext.log) {
                      resolveContext.log(
                        `Failed to alias from extension alias with mapping '${extension}' to '${alias2}' for '${newRequest}': ${err}`
                      );
                    }
                    return callback2(null, result);
                  }
                  return callback2(err, result);
                } else {
                  callback2(err, result);
                }
              }
            );
          };
          const stoppingCallback = (err, result) => {
            if (err)
              return callback(err);
            if (result)
              return callback(null, result);
            return callback(null, null);
          };
          if (isAliasString) {
            resolve2(alias, stoppingCallback);
          } else if (alias.length > 1) {
            forEachBail(alias, resolve2, stoppingCallback);
          } else {
            resolve2(alias[0], stoppingCallback);
          }
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/FileExistsPlugin.js
var require_FileExistsPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/FileExistsPlugin.js"(exports, module) {
    "use strict";
    module.exports = class FileExistsPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs2 = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("FileExistsPlugin", (request, resolveContext, callback) => {
          const file = request.path;
          if (!file)
            return callback();
          fs2.stat(file, (err, stat) => {
            if (err || !stat) {
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(file);
              if (resolveContext.log)
                resolveContext.log(file + " doesn't exist");
              return callback();
            }
            if (!stat.isFile()) {
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(file);
              if (resolveContext.log)
                resolveContext.log(file + " is not a file");
              return callback();
            }
            if (resolveContext.fileDependencies)
              resolveContext.fileDependencies.add(file);
            resolver.doResolve(
              target,
              request,
              "existing file: " + file,
              resolveContext,
              callback
            );
          });
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js
var require_ImportsFieldPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var forEachBail = require_forEachBail();
    var { processImportsField } = require_entrypoints();
    var { parseIdentifier } = require_identifier();
    var { checkImportsExportsFieldTarget } = require_path();
    var dotCode = ".".charCodeAt(0);
    module.exports = class ImportsFieldPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {Set<string>} conditionNames condition names
       * @param {string | string[]} fieldNamePath name path
       * @param {string | ResolveStepHook} targetFile target file
       * @param {string | ResolveStepHook} targetPackage target package
       */
      constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage) {
        this.source = source;
        this.targetFile = targetFile;
        this.targetPackage = targetPackage;
        this.conditionNames = conditionNames;
        this.fieldName = fieldNamePath;
        this.fieldProcessorCache = /* @__PURE__ */ new WeakMap();
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const targetFile = resolver.ensureHook(this.targetFile);
        const targetPackage = resolver.ensureHook(this.targetPackage);
        resolver.getHook(this.source).tapAsync("ImportsFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFilePath || request.request === void 0) {
            return callback();
          }
          const remainingRequest = request.request + request.query + request.fragment;
          const importsField = (
            /** @type {ImportsField|null|undefined} */
            DescriptionFileUtils.getField(
              /** @type {JsonObject} */
              request.descriptionFileData,
              this.fieldName
            )
          );
          if (!importsField)
            return callback();
          if (request.directory) {
            return callback(
              new Error(
                `Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`
              )
            );
          }
          let paths;
          try {
            let fieldProcessor = this.fieldProcessorCache.get(
              /** @type {JsonObject} */
              request.descriptionFileData
            );
            if (fieldProcessor === void 0) {
              fieldProcessor = processImportsField(importsField);
              this.fieldProcessorCache.set(
                /** @type {JsonObject} */
                request.descriptionFileData,
                fieldProcessor
              );
            }
            paths = fieldProcessor(remainingRequest, this.conditionNames);
          } catch (err) {
            if (resolveContext.log) {
              resolveContext.log(
                `Imports field in ${request.descriptionFilePath} can't be processed: ${err}`
              );
            }
            return callback(
              /** @type {Error} */
              err
            );
          }
          if (paths.length === 0) {
            return callback(
              new Error(
                `Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`
              )
            );
          }
          forEachBail(
            paths,
            /**
             * @param {string} p path
             * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
             * @returns {void}
             */
            (p, callback2) => {
              const parsedIdentifier = parseIdentifier(p);
              if (!parsedIdentifier)
                return callback2();
              const [path_, query, fragment] = parsedIdentifier;
              const error = checkImportsExportsFieldTarget(path_);
              if (error) {
                return callback2(error);
              }
              switch (path_.charCodeAt(0)) {
                case dotCode: {
                  const obj = {
                    ...request,
                    request: void 0,
                    path: path4.join(
                      /** @type {string} */
                      request.descriptionFileRoot,
                      path_
                    ),
                    relativePath: path_,
                    query,
                    fragment
                  };
                  resolver.doResolve(
                    targetFile,
                    obj,
                    "using imports field: " + p,
                    resolveContext,
                    callback2
                  );
                  break;
                }
                default: {
                  const obj = {
                    ...request,
                    request: path_,
                    relativePath: path_,
                    fullySpecified: true,
                    query,
                    fragment
                  };
                  resolver.doResolve(
                    targetPackage,
                    obj,
                    "using imports field: " + p,
                    resolveContext,
                    callback2
                  );
                }
              }
            },
            /**
             * @param {null|Error} [err] error
             * @param {null|ResolveRequest} [result] result
             * @returns {void}
             */
            (err, result) => callback(err, result || null)
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/JoinRequestPartPlugin.js
var require_JoinRequestPartPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/JoinRequestPartPlugin.js"(exports, module) {
    "use strict";
    var namespaceStartCharCode = "@".charCodeAt(0);
    module.exports = class JoinRequestPartPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "JoinRequestPartPlugin",
          (request, resolveContext, callback) => {
            const req = request.request || "";
            let i = req.indexOf("/", 3);
            if (i >= 0 && req.charCodeAt(2) === namespaceStartCharCode) {
              i = req.indexOf("/", i + 1);
            }
            let moduleName;
            let remainingRequest;
            let fullySpecified;
            if (i < 0) {
              moduleName = req;
              remainingRequest = ".";
              fullySpecified = false;
            } else {
              moduleName = req.slice(0, i);
              remainingRequest = "." + req.slice(i);
              fullySpecified = /** @type {boolean} */
              request.fullySpecified;
            }
            const obj = {
              ...request,
              path: resolver.join(
                /** @type {string} */
                request.path,
                moduleName
              ),
              relativePath: request.relativePath && resolver.join(request.relativePath, moduleName),
              request: remainingRequest,
              fullySpecified
            };
            resolver.doResolve(target, obj, null, resolveContext, callback);
          }
        );
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/JoinRequestPlugin.js
var require_JoinRequestPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/JoinRequestPlugin.js"(exports, module) {
    "use strict";
    module.exports = class JoinRequestPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("JoinRequestPlugin", (request, resolveContext, callback) => {
          const requestPath = (
            /** @type {string} */
            request.path
          );
          const requestRequest = (
            /** @type {string} */
            request.request
          );
          const obj = {
            ...request,
            path: resolver.join(requestPath, requestRequest),
            relativePath: request.relativePath && resolver.join(request.relativePath, requestRequest),
            request: void 0
          };
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/MainFieldPlugin.js
var require_MainFieldPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/MainFieldPlugin.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var alreadyTriedMainField = Symbol("alreadyTriedMainField");
    module.exports = class MainFieldPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {MainFieldOptions} options options
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("MainFieldPlugin", (request, resolveContext, callback) => {
          if (request.path !== request.descriptionFileRoot || /** @type {ResolveRequest & { [alreadyTriedMainField]?: string }} */
          request[alreadyTriedMainField] === request.descriptionFilePath || !request.descriptionFilePath)
            return callback();
          const filename = path4.basename(request.descriptionFilePath);
          let mainModule = (
            /** @type {string|null|undefined} */
            DescriptionFileUtils.getField(
              /** @type {JsonObject} */
              request.descriptionFileData,
              this.options.name
            )
          );
          if (!mainModule || typeof mainModule !== "string" || mainModule === "." || mainModule === "./") {
            return callback();
          }
          if (this.options.forceRelative && !/^\.\.?\//.test(mainModule))
            mainModule = "./" + mainModule;
          const obj = {
            ...request,
            request: mainModule,
            module: false,
            directory: mainModule.endsWith("/"),
            [alreadyTriedMainField]: request.descriptionFilePath
          };
          return resolver.doResolve(
            target,
            obj,
            "use " + mainModule + " from " + this.options.name + " in " + filename,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/getPaths.js
var require_getPaths = __commonJS({
  "../../node_modules/enhanced-resolve/lib/getPaths.js"(exports, module) {
    "use strict";
    module.exports = function getPaths(path4) {
      if (path4 === "/")
        return { paths: ["/"], segments: [""] };
      const parts = path4.split(/(.*?[\\/]+)/);
      const paths = [path4];
      const segments = [parts[parts.length - 1]];
      let part = parts[parts.length - 1];
      path4 = path4.substring(0, path4.length - part.length - 1);
      for (let i = parts.length - 2; i > 2; i -= 2) {
        paths.push(path4);
        part = parts[i];
        path4 = path4.substring(0, path4.length - part.length) || "/";
        segments.push(part.slice(0, -1));
      }
      part = parts[1];
      segments.push(part);
      paths.push(part);
      return {
        paths,
        segments
      };
    };
    module.exports.basename = function basename(path4) {
      const i = path4.lastIndexOf("/"), j = path4.lastIndexOf("\\");
      const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
      if (p < 0)
        return null;
      const s = path4.slice(p + 1);
      return s;
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ModulesInHierarchicalDirectoriesPlugin.js
var require_ModulesInHierarchicalDirectoriesPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ModulesInHierarchicalDirectoriesPlugin.js"(exports, module) {
    "use strict";
    var forEachBail = require_forEachBail();
    var getPaths = require_getPaths();
    module.exports = class ModulesInHierarchicalDirectoriesPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | Array<string>} directories directories
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, directories, target) {
        this.source = source;
        this.directories = /** @type {Array<string>} */
        [].concat(directories);
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "ModulesInHierarchicalDirectoriesPlugin",
          (request, resolveContext, callback) => {
            const fs2 = resolver.fileSystem;
            const addrs = getPaths(
              /** @type {string} */
              request.path
            ).paths.map((p) => {
              return this.directories.map((d) => resolver.join(p, d));
            }).reduce((array, p) => {
              array.push.apply(array, p);
              return array;
            }, []);
            forEachBail(
              addrs,
              /**
               * @param {string} addr addr
               * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
               * @returns {void}
               */
              (addr, callback2) => {
                fs2.stat(addr, (err, stat) => {
                  if (!err && stat && stat.isDirectory()) {
                    const obj = {
                      ...request,
                      path: addr,
                      request: "./" + request.request,
                      module: false
                    };
                    const message = "looking for modules in " + addr;
                    return resolver.doResolve(
                      target,
                      obj,
                      message,
                      resolveContext,
                      callback2
                    );
                  }
                  if (resolveContext.log)
                    resolveContext.log(
                      addr + " doesn't exist or is not a directory"
                    );
                  if (resolveContext.missingDependencies)
                    resolveContext.missingDependencies.add(addr);
                  return callback2();
                });
              },
              callback
            );
          }
        );
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js
var require_ModulesInRootPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js"(exports, module) {
    "use strict";
    module.exports = class ModulesInRootPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string} path path
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, path4, target) {
        this.source = source;
        this.path = path4;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModulesInRootPlugin", (request, resolveContext, callback) => {
          const obj = {
            ...request,
            path: this.path,
            request: "./" + request.request,
            module: false
          };
          resolver.doResolve(
            target,
            obj,
            "looking for modules in " + this.path,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/NextPlugin.js
var require_NextPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/NextPlugin.js"(exports, module) {
    "use strict";
    module.exports = class NextPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("NextPlugin", (request, resolveContext, callback) => {
          resolver.doResolve(target, request, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ParsePlugin.js
var require_ParsePlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ParsePlugin.js"(exports, module) {
    "use strict";
    module.exports = class ParsePlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {Partial<ResolveRequest>} requestOptions request options
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, requestOptions, target) {
        this.source = source;
        this.requestOptions = requestOptions;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ParsePlugin", (request, resolveContext, callback) => {
          const parsed = resolver.parse(
            /** @type {string} */
            request.request
          );
          const obj = { ...request, ...parsed, ...this.requestOptions };
          if (request.query && !parsed.query) {
            obj.query = request.query;
          }
          if (request.fragment && !parsed.fragment) {
            obj.fragment = request.fragment;
          }
          if (parsed && resolveContext.log) {
            if (parsed.module)
              resolveContext.log("Parsed request is a module");
            if (parsed.directory)
              resolveContext.log("Parsed request is a directory");
          }
          if (obj.request && !obj.query && obj.fragment) {
            const directory = obj.fragment.endsWith("/");
            const alternative = {
              ...obj,
              directory,
              request: obj.request + (obj.directory ? "/" : "") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),
              fragment: ""
            };
            resolver.doResolve(
              target,
              alternative,
              null,
              resolveContext,
              (err, result) => {
                if (err)
                  return callback(err);
                if (result)
                  return callback(null, result);
                resolver.doResolve(target, obj, null, resolveContext, callback);
              }
            );
            return;
          }
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/PnpPlugin.js
var require_PnpPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/PnpPlugin.js"(exports, module) {
    "use strict";
    module.exports = class PnpPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {PnpApiImpl} pnpApi pnpApi
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, pnpApi, target) {
        this.source = source;
        this.pnpApi = pnpApi;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("PnpPlugin", (request, resolveContext, callback) => {
          const req = request.request;
          if (!req)
            return callback();
          const issuer = `${request.path}/`;
          const packageMatch = /^(@[^/]+\/)?[^/]+/.exec(req);
          if (!packageMatch)
            return callback();
          const packageName = packageMatch[0];
          const innerRequest = `.${req.slice(packageName.length)}`;
          let resolution;
          let apiResolution;
          try {
            resolution = this.pnpApi.resolveToUnqualified(packageName, issuer, {
              considerBuiltins: false
            });
            if (resolveContext.fileDependencies) {
              apiResolution = this.pnpApi.resolveToUnqualified("pnpapi", issuer, {
                considerBuiltins: false
              });
            }
          } catch (error) {
            if (
              /** @type {Error & { code: string }} */
              error.code === "MODULE_NOT_FOUND" && /** @type {Error & { pnpCode: string }} */
              error.pnpCode === "UNDECLARED_DEPENDENCY"
            ) {
              if (resolveContext.log) {
                resolveContext.log(`request is not managed by the pnpapi`);
                for (
                  const line of
                  /** @type {Error} */
                  error.message.split("\n").filter(Boolean)
                )
                  resolveContext.log(`  ${line}`);
              }
              return callback();
            }
            return callback(
              /** @type {Error} */
              error
            );
          }
          if (resolution === packageName)
            return callback();
          if (apiResolution && resolveContext.fileDependencies) {
            resolveContext.fileDependencies.add(apiResolution);
          }
          const obj = {
            ...request,
            path: resolution,
            request: innerRequest,
            ignoreSymlinks: true,
            fullySpecified: request.fullySpecified && innerRequest !== "."
          };
          resolver.doResolve(
            target,
            obj,
            `resolved by pnp to ${resolution}`,
            resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (result)
                return callback(null, result);
              return callback(null, null);
            }
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/RestrictionsPlugin.js
var require_RestrictionsPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/RestrictionsPlugin.js"(exports, module) {
    "use strict";
    var slashCode = "/".charCodeAt(0);
    var backslashCode = "\\".charCodeAt(0);
    var isInside = (path4, parent) => {
      if (!path4.startsWith(parent))
        return false;
      if (path4.length === parent.length)
        return true;
      const charCode = path4.charCodeAt(parent.length);
      return charCode === slashCode || charCode === backslashCode;
    };
    module.exports = class RestrictionsPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {Set<string | RegExp>} restrictions restrictions
       */
      constructor(source, restrictions) {
        this.source = source;
        this.restrictions = restrictions;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        resolver.getHook(this.source).tapAsync("RestrictionsPlugin", (request, resolveContext, callback) => {
          if (typeof request.path === "string") {
            const path4 = request.path;
            for (const rule of this.restrictions) {
              if (typeof rule === "string") {
                if (!isInside(path4, rule)) {
                  if (resolveContext.log) {
                    resolveContext.log(
                      `${path4} is not inside of the restriction ${rule}`
                    );
                  }
                  return callback(null, null);
                }
              } else if (!rule.test(path4)) {
                if (resolveContext.log) {
                  resolveContext.log(
                    `${path4} doesn't match the restriction ${rule}`
                  );
                }
                return callback(null, null);
              }
            }
          }
          callback();
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ResultPlugin.js
var require_ResultPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ResultPlugin.js"(exports, module) {
    "use strict";
    module.exports = class ResultPlugin {
      /**
       * @param {ResolveStepHook} source source
       */
      constructor(source) {
        this.source = source;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        this.source.tapAsync(
          "ResultPlugin",
          (request, resolverContext, callback) => {
            const obj = { ...request };
            if (resolverContext.log)
              resolverContext.log("reporting result " + obj.path);
            resolver.hooks.result.callAsync(obj, resolverContext, (err) => {
              if (err)
                return callback(err);
              if (typeof resolverContext.yield === "function") {
                resolverContext.yield(obj);
                callback(null, null);
              } else {
                callback(null, obj);
              }
            });
          }
        );
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/RootsPlugin.js
var require_RootsPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/RootsPlugin.js"(exports, module) {
    "use strict";
    var forEachBail = require_forEachBail();
    var RootsPlugin = class {
      /**
       * @param {string | ResolveStepHook} source source hook
       * @param {Set<string>} roots roots
       * @param {string | ResolveStepHook} target target hook
       */
      constructor(source, roots, target) {
        this.roots = Array.from(roots);
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("RootsPlugin", (request, resolveContext, callback) => {
          const req = request.request;
          if (!req)
            return callback();
          if (!req.startsWith("/"))
            return callback();
          forEachBail(
            this.roots,
            /**
             * @param {string} root root
             * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
             * @returns {void}
             */
            (root, callback2) => {
              const path4 = resolver.join(root, req.slice(1));
              const obj = {
                ...request,
                path: path4,
                relativePath: request.relativePath && path4
              };
              resolver.doResolve(
                target,
                obj,
                `root path ${root}`,
                resolveContext,
                callback2
              );
            },
            callback
          );
        });
      }
    };
    module.exports = RootsPlugin;
  }
});

// ../../node_modules/enhanced-resolve/lib/SelfReferencePlugin.js
var require_SelfReferencePlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/SelfReferencePlugin.js"(exports, module) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var slashCode = "/".charCodeAt(0);
    module.exports = class SelfReferencePlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | string[]} fieldNamePath name path
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, fieldNamePath, target) {
        this.source = source;
        this.target = target;
        this.fieldName = fieldNamePath;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("SelfReferencePlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFilePath)
            return callback();
          const req = request.request;
          if (!req)
            return callback();
          const exportsField = DescriptionFileUtils.getField(
            /** @type {JsonObject} */
            request.descriptionFileData,
            this.fieldName
          );
          if (!exportsField)
            return callback();
          const name = DescriptionFileUtils.getField(
            /** @type {JsonObject} */
            request.descriptionFileData,
            "name"
          );
          if (typeof name !== "string")
            return callback();
          if (req.startsWith(name) && (req.length === name.length || req.charCodeAt(name.length) === slashCode)) {
            const remainingRequest = `.${req.slice(name.length)}`;
            const obj = {
              ...request,
              request: remainingRequest,
              path: (
                /** @type {string} */
                request.descriptionFileRoot
              ),
              relativePath: "."
            };
            resolver.doResolve(
              target,
              obj,
              "self reference",
              resolveContext,
              callback
            );
          } else {
            return callback();
          }
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/SymlinkPlugin.js
var require_SymlinkPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/SymlinkPlugin.js"(exports, module) {
    "use strict";
    var forEachBail = require_forEachBail();
    var getPaths = require_getPaths();
    var { getType, PathType } = require_path();
    module.exports = class SymlinkPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs2 = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("SymlinkPlugin", (request, resolveContext, callback) => {
          if (request.ignoreSymlinks)
            return callback();
          const pathsResult = getPaths(
            /** @type {string} */
            request.path
          );
          const pathSegments = pathsResult.segments;
          const paths = pathsResult.paths;
          let containsSymlink = false;
          let idx = -1;
          forEachBail(
            paths,
            /**
             * @param {string} path path
             * @param {(err?: null|Error, result?: null|number) => void} callback callback
             * @returns {void}
             */
            (path4, callback2) => {
              idx++;
              if (resolveContext.fileDependencies)
                resolveContext.fileDependencies.add(path4);
              fs2.readlink(path4, (err, result) => {
                if (!err && result) {
                  pathSegments[idx] = /** @type {string} */
                  result;
                  containsSymlink = true;
                  const resultType = getType(result.toString());
                  if (resultType === PathType.AbsoluteWin || resultType === PathType.AbsolutePosix) {
                    return callback2(null, idx);
                  }
                }
                callback2();
              });
            },
            /**
             * @param {null|Error} [err] error
             * @param {null|number} [idx] result
             * @returns {void}
             */
            (err, idx2) => {
              if (!containsSymlink)
                return callback();
              const resultSegments = typeof idx2 === "number" ? pathSegments.slice(0, idx2 + 1) : pathSegments.slice();
              const result = resultSegments.reduceRight((a, b) => {
                return resolver.join(a, b);
              });
              const obj = {
                ...request,
                path: result
              };
              resolver.doResolve(
                target,
                obj,
                "resolved symlink to " + result,
                resolveContext,
                callback
              );
            }
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/TryNextPlugin.js
var require_TryNextPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/TryNextPlugin.js"(exports, module) {
    "use strict";
    module.exports = class TryNextPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string} message message
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, message, target) {
        this.source = source;
        this.message = message;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("TryNextPlugin", (request, resolveContext, callback) => {
          resolver.doResolve(
            target,
            request,
            this.message,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js
var require_UnsafeCachePlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js"(exports, module) {
    "use strict";
    function getCacheId(type, request, withContext) {
      return JSON.stringify({
        type,
        context: withContext ? request.context : "",
        path: request.path,
        query: request.query,
        fragment: request.fragment,
        request: request.request
      });
    }
    module.exports = class UnsafeCachePlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {function(ResolveRequest): boolean} filterPredicate filterPredicate
       * @param {Cache} cache cache
       * @param {boolean} withContext withContext
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, filterPredicate, cache, withContext, target) {
        this.source = source;
        this.filterPredicate = filterPredicate;
        this.withContext = withContext;
        this.cache = cache;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UnsafeCachePlugin", (request, resolveContext, callback) => {
          if (!this.filterPredicate(request))
            return callback();
          const isYield = typeof resolveContext.yield === "function";
          const cacheId = getCacheId(
            isYield ? "yield" : "default",
            request,
            this.withContext
          );
          const cacheEntry = this.cache[cacheId];
          if (cacheEntry) {
            if (isYield) {
              const yield_2 = (
                /** @type {Function} */
                resolveContext.yield
              );
              if (Array.isArray(cacheEntry)) {
                for (const result of cacheEntry)
                  yield_2(result);
              } else {
                yield_2(cacheEntry);
              }
              return callback(null, null);
            }
            return callback(
              null,
              /** @type {ResolveRequest} */
              cacheEntry
            );
          }
          let yieldFn;
          let yield_;
          const yieldResult = [];
          if (isYield) {
            yieldFn = resolveContext.yield;
            yield_ = (result) => {
              yieldResult.push(result);
            };
          }
          resolver.doResolve(
            target,
            request,
            null,
            yield_ ? { ...resolveContext, yield: yield_ } : resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (isYield) {
                if (result)
                  yieldResult.push(result);
                for (const result2 of yieldResult) {
                  yieldFn(result2);
                }
                this.cache[cacheId] = yieldResult;
                return callback(null, null);
              }
              if (result)
                return callback(null, this.cache[cacheId] = result);
              callback();
            }
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/UseFilePlugin.js
var require_UseFilePlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/UseFilePlugin.js"(exports, module) {
    "use strict";
    module.exports = class UseFilePlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string} filename filename
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, filename, target) {
        this.source = source;
        this.filename = filename;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UseFilePlugin", (request, resolveContext, callback) => {
          const filePath = resolver.join(
            /** @type {string} */
            request.path,
            this.filename
          );
          const obj = {
            ...request,
            path: filePath,
            relativePath: request.relativePath && resolver.join(request.relativePath, this.filename)
          };
          resolver.doResolve(
            target,
            obj,
            "using path: " + filePath,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/ResolverFactory.js
var require_ResolverFactory = __commonJS({
  "../../node_modules/enhanced-resolve/lib/ResolverFactory.js"(exports) {
    "use strict";
    var versions = __require("process").versions;
    var Resolver = require_Resolver();
    var { getType, PathType } = require_path();
    var SyncAsyncFileSystemDecorator = require_SyncAsyncFileSystemDecorator();
    var AliasFieldPlugin = require_AliasFieldPlugin();
    var AliasPlugin = require_AliasPlugin();
    var AppendPlugin = require_AppendPlugin();
    var ConditionalPlugin = require_ConditionalPlugin();
    var DescriptionFilePlugin = require_DescriptionFilePlugin();
    var DirectoryExistsPlugin = require_DirectoryExistsPlugin();
    var ExportsFieldPlugin = require_ExportsFieldPlugin();
    var ExtensionAliasPlugin = require_ExtensionAliasPlugin();
    var FileExistsPlugin = require_FileExistsPlugin();
    var ImportsFieldPlugin = require_ImportsFieldPlugin();
    var JoinRequestPartPlugin = require_JoinRequestPartPlugin();
    var JoinRequestPlugin = require_JoinRequestPlugin();
    var MainFieldPlugin = require_MainFieldPlugin();
    var ModulesInHierarchicalDirectoriesPlugin = require_ModulesInHierarchicalDirectoriesPlugin();
    var ModulesInRootPlugin = require_ModulesInRootPlugin();
    var NextPlugin = require_NextPlugin();
    var ParsePlugin = require_ParsePlugin();
    var PnpPlugin = require_PnpPlugin();
    var RestrictionsPlugin = require_RestrictionsPlugin();
    var ResultPlugin = require_ResultPlugin();
    var RootsPlugin = require_RootsPlugin();
    var SelfReferencePlugin = require_SelfReferencePlugin();
    var SymlinkPlugin = require_SymlinkPlugin();
    var TryNextPlugin = require_TryNextPlugin();
    var UnsafeCachePlugin = require_UnsafeCachePlugin();
    var UseFilePlugin = require_UseFilePlugin();
    function processPnpApiOption(option) {
      if (option === void 0 && /** @type {NodeJS.ProcessVersions & {pnp: string}} */
      versions.pnp) {
        return __require("pnpapi");
      }
      return option || null;
    }
    function normalizeAlias(alias) {
      return typeof alias === "object" && !Array.isArray(alias) && alias !== null ? Object.keys(alias).map((key) => {
        const obj = { name: key, onlyModule: false, alias: alias[key] };
        if (/\$$/.test(key)) {
          obj.onlyModule = true;
          obj.name = key.slice(0, -1);
        }
        return obj;
      }) : (
        /** @type {Array<AliasOptionEntry>} */
        alias || []
      );
    }
    function createOptions(options) {
      const mainFieldsSet = new Set(options.mainFields || ["main"]);
      const mainFields = [];
      for (const item of mainFieldsSet) {
        if (typeof item === "string") {
          mainFields.push({
            name: [item],
            forceRelative: true
          });
        } else if (Array.isArray(item)) {
          mainFields.push({
            name: item,
            forceRelative: true
          });
        } else {
          mainFields.push({
            name: Array.isArray(item.name) ? item.name : [item.name],
            forceRelative: item.forceRelative
          });
        }
      }
      return {
        alias: normalizeAlias(options.alias),
        fallback: normalizeAlias(options.fallback),
        aliasFields: new Set(options.aliasFields),
        cachePredicate: options.cachePredicate || function() {
          return true;
        },
        cacheWithContext: typeof options.cacheWithContext !== "undefined" ? options.cacheWithContext : true,
        exportsFields: new Set(options.exportsFields || ["exports"]),
        importsFields: new Set(options.importsFields || ["imports"]),
        conditionNames: new Set(options.conditionNames),
        descriptionFiles: Array.from(
          new Set(options.descriptionFiles || ["package.json"])
        ),
        enforceExtension: options.enforceExtension === void 0 ? options.extensions && options.extensions.includes("") ? true : false : options.enforceExtension,
        extensions: new Set(options.extensions || [".js", ".json", ".node"]),
        extensionAlias: options.extensionAlias ? Object.keys(options.extensionAlias).map((k) => ({
          extension: k,
          alias: (
            /** @type {ExtensionAliasOptions} */
            options.extensionAlias[k]
          )
        })) : [],
        fileSystem: options.useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(
          /** @type {SyncFileSystem} */
          /** @type {unknown} */
          options.fileSystem
        ) : options.fileSystem,
        unsafeCache: options.unsafeCache && typeof options.unsafeCache !== "object" ? {} : options.unsafeCache || false,
        symlinks: typeof options.symlinks !== "undefined" ? options.symlinks : true,
        resolver: options.resolver,
        modules: mergeFilteredToArray(
          Array.isArray(options.modules) ? options.modules : options.modules ? [options.modules] : ["node_modules"],
          (item) => {
            const type = getType(item);
            return type === PathType.Normal || type === PathType.Relative;
          }
        ),
        mainFields,
        mainFiles: new Set(options.mainFiles || ["index"]),
        plugins: options.plugins || [],
        pnpApi: processPnpApiOption(options.pnpApi),
        roots: new Set(options.roots || void 0),
        fullySpecified: options.fullySpecified || false,
        resolveToContext: options.resolveToContext || false,
        preferRelative: options.preferRelative || false,
        preferAbsolute: options.preferAbsolute || false,
        restrictions: new Set(options.restrictions)
      };
    }
    exports.createResolver = function(options) {
      const normalizedOptions = createOptions(options);
      const {
        alias,
        fallback,
        aliasFields,
        cachePredicate,
        cacheWithContext,
        conditionNames,
        descriptionFiles,
        enforceExtension,
        exportsFields,
        extensionAlias,
        importsFields,
        extensions,
        fileSystem,
        fullySpecified,
        mainFields,
        mainFiles,
        modules,
        plugins: userPlugins,
        pnpApi,
        resolveToContext,
        preferRelative,
        preferAbsolute,
        symlinks,
        unsafeCache,
        resolver: customResolver,
        restrictions,
        roots
      } = normalizedOptions;
      const plugins = userPlugins.slice();
      const resolver = customResolver ? customResolver : new Resolver(fileSystem, normalizedOptions);
      resolver.ensureHook("resolve");
      resolver.ensureHook("internalResolve");
      resolver.ensureHook("newInternalResolve");
      resolver.ensureHook("parsedResolve");
      resolver.ensureHook("describedResolve");
      resolver.ensureHook("rawResolve");
      resolver.ensureHook("normalResolve");
      resolver.ensureHook("internal");
      resolver.ensureHook("rawModule");
      resolver.ensureHook("module");
      resolver.ensureHook("resolveAsModule");
      resolver.ensureHook("undescribedResolveInPackage");
      resolver.ensureHook("resolveInPackage");
      resolver.ensureHook("resolveInExistingDirectory");
      resolver.ensureHook("relative");
      resolver.ensureHook("describedRelative");
      resolver.ensureHook("directory");
      resolver.ensureHook("undescribedExistingDirectory");
      resolver.ensureHook("existingDirectory");
      resolver.ensureHook("undescribedRawFile");
      resolver.ensureHook("rawFile");
      resolver.ensureHook("file");
      resolver.ensureHook("finalFile");
      resolver.ensureHook("existingFile");
      resolver.ensureHook("resolved");
      resolver.hooks.newInteralResolve = resolver.hooks.newInternalResolve;
      for (const { source, resolveOptions } of [
        { source: "resolve", resolveOptions: { fullySpecified } },
        { source: "internal-resolve", resolveOptions: { fullySpecified: false } }
      ]) {
        if (unsafeCache) {
          plugins.push(
            new UnsafeCachePlugin(
              source,
              cachePredicate,
              /** @type {import("./UnsafeCachePlugin").Cache} */
              unsafeCache,
              cacheWithContext,
              `new-${source}`
            )
          );
          plugins.push(
            new ParsePlugin(`new-${source}`, resolveOptions, "parsed-resolve")
          );
        } else {
          plugins.push(new ParsePlugin(source, resolveOptions, "parsed-resolve"));
        }
      }
      plugins.push(
        new DescriptionFilePlugin(
          "parsed-resolve",
          descriptionFiles,
          false,
          "described-resolve"
        )
      );
      plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve"));
      plugins.push(new NextPlugin("described-resolve", "raw-resolve"));
      if (fallback.length > 0) {
        plugins.push(
          new AliasPlugin("described-resolve", fallback, "internal-resolve")
        );
      }
      if (alias.length > 0) {
        plugins.push(new AliasPlugin("raw-resolve", alias, "internal-resolve"));
      }
      aliasFields.forEach((item) => {
        plugins.push(new AliasFieldPlugin("raw-resolve", item, "internal-resolve"));
      });
      extensionAlias.forEach(
        (item) => plugins.push(
          new ExtensionAliasPlugin("raw-resolve", item, "normal-resolve")
        )
      );
      plugins.push(new NextPlugin("raw-resolve", "normal-resolve"));
      if (preferRelative) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
      }
      plugins.push(
        new ConditionalPlugin(
          "after-normal-resolve",
          { module: true },
          "resolve as module",
          false,
          "raw-module"
        )
      );
      plugins.push(
        new ConditionalPlugin(
          "after-normal-resolve",
          { internal: true },
          "resolve as internal import",
          false,
          "internal"
        )
      );
      if (preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
      }
      if (roots.size > 0) {
        plugins.push(new RootsPlugin("after-normal-resolve", roots, "relative"));
      }
      if (!preferRelative && !preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
      }
      importsFields.forEach((importsField) => {
        plugins.push(
          new ImportsFieldPlugin(
            "internal",
            conditionNames,
            importsField,
            "relative",
            "internal-resolve"
          )
        );
      });
      exportsFields.forEach((exportsField) => {
        plugins.push(
          new SelfReferencePlugin("raw-module", exportsField, "resolve-as-module")
        );
      });
      modules.forEach((item) => {
        if (Array.isArray(item)) {
          if (item.includes("node_modules") && pnpApi) {
            plugins.push(
              new ModulesInHierarchicalDirectoriesPlugin(
                "raw-module",
                item.filter((i) => i !== "node_modules"),
                "module"
              )
            );
            plugins.push(
              new PnpPlugin("raw-module", pnpApi, "undescribed-resolve-in-package")
            );
          } else {
            plugins.push(
              new ModulesInHierarchicalDirectoriesPlugin(
                "raw-module",
                item,
                "module"
              )
            );
          }
        } else {
          plugins.push(new ModulesInRootPlugin("raw-module", item, "module"));
        }
      });
      plugins.push(new JoinRequestPartPlugin("module", "resolve-as-module"));
      if (!resolveToContext) {
        plugins.push(
          new ConditionalPlugin(
            "resolve-as-module",
            { directory: false, request: "." },
            "single file module",
            true,
            "undescribed-raw-file"
          )
        );
      }
      plugins.push(
        new DirectoryExistsPlugin(
          "resolve-as-module",
          "undescribed-resolve-in-package"
        )
      );
      plugins.push(
        new DescriptionFilePlugin(
          "undescribed-resolve-in-package",
          descriptionFiles,
          false,
          "resolve-in-package"
        )
      );
      plugins.push(
        new NextPlugin("after-undescribed-resolve-in-package", "resolve-in-package")
      );
      exportsFields.forEach((exportsField) => {
        plugins.push(
          new ExportsFieldPlugin(
            "resolve-in-package",
            conditionNames,
            exportsField,
            "relative"
          )
        );
      });
      plugins.push(
        new NextPlugin("resolve-in-package", "resolve-in-existing-directory")
      );
      plugins.push(
        new JoinRequestPlugin("resolve-in-existing-directory", "relative")
      );
      plugins.push(
        new DescriptionFilePlugin(
          "relative",
          descriptionFiles,
          true,
          "described-relative"
        )
      );
      plugins.push(new NextPlugin("after-relative", "described-relative"));
      if (resolveToContext) {
        plugins.push(new NextPlugin("described-relative", "directory"));
      } else {
        plugins.push(
          new ConditionalPlugin(
            "described-relative",
            { directory: false },
            null,
            true,
            "raw-file"
          )
        );
        plugins.push(
          new ConditionalPlugin(
            "described-relative",
            { fullySpecified: false },
            "as directory",
            true,
            "directory"
          )
        );
      }
      plugins.push(
        new DirectoryExistsPlugin("directory", "undescribed-existing-directory")
      );
      if (resolveToContext) {
        plugins.push(new NextPlugin("undescribed-existing-directory", "resolved"));
      } else {
        plugins.push(
          new DescriptionFilePlugin(
            "undescribed-existing-directory",
            descriptionFiles,
            false,
            "existing-directory"
          )
        );
        mainFiles.forEach((item) => {
          plugins.push(
            new UseFilePlugin(
              "undescribed-existing-directory",
              item,
              "undescribed-raw-file"
            )
          );
        });
        mainFields.forEach((item) => {
          plugins.push(
            new MainFieldPlugin(
              "existing-directory",
              item,
              "resolve-in-existing-directory"
            )
          );
        });
        mainFiles.forEach((item) => {
          plugins.push(
            new UseFilePlugin("existing-directory", item, "undescribed-raw-file")
          );
        });
        plugins.push(
          new DescriptionFilePlugin(
            "undescribed-raw-file",
            descriptionFiles,
            true,
            "raw-file"
          )
        );
        plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file"));
        plugins.push(
          new ConditionalPlugin(
            "raw-file",
            { fullySpecified: true },
            null,
            false,
            "file"
          )
        );
        if (!enforceExtension) {
          plugins.push(new TryNextPlugin("raw-file", "no extension", "file"));
        }
        extensions.forEach((item) => {
          plugins.push(new AppendPlugin("raw-file", item, "file"));
        });
        if (alias.length > 0)
          plugins.push(new AliasPlugin("file", alias, "internal-resolve"));
        aliasFields.forEach((item) => {
          plugins.push(new AliasFieldPlugin("file", item, "internal-resolve"));
        });
        plugins.push(new NextPlugin("file", "final-file"));
        plugins.push(new FileExistsPlugin("final-file", "existing-file"));
        if (symlinks)
          plugins.push(new SymlinkPlugin("existing-file", "existing-file"));
        plugins.push(new NextPlugin("existing-file", "resolved"));
      }
      const resolved = (
        /** @type {KnownHooks & EnsuredHooks} */
        resolver.hooks.resolved
      );
      if (restrictions.size > 0) {
        plugins.push(new RestrictionsPlugin(resolved, restrictions));
      }
      plugins.push(new ResultPlugin(resolved));
      for (const plugin of plugins) {
        if (typeof plugin === "function") {
          plugin.call(resolver, resolver);
        } else if (plugin) {
          plugin.apply(resolver);
        }
      }
      return resolver;
    };
    function mergeFilteredToArray(array, filter) {
      const result = [];
      const set = new Set(array);
      for (const item of set) {
        if (filter(item)) {
          const lastElement = result.length > 0 ? result[result.length - 1] : void 0;
          if (Array.isArray(lastElement)) {
            lastElement.push(item);
          } else {
            result.push([item]);
          }
        } else {
          result.push(item);
        }
      }
      return result;
    }
  }
});

// ../../node_modules/enhanced-resolve/lib/CloneBasenamePlugin.js
var require_CloneBasenamePlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/CloneBasenamePlugin.js"(exports, module) {
    "use strict";
    var basename = require_getPaths().basename;
    module.exports = class CloneBasenamePlugin {
      /**
       * @param {string | ResolveStepHook} source source
       * @param {string | ResolveStepHook} target target
       */
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("CloneBasenamePlugin", (request, resolveContext, callback) => {
          const requestPath = (
            /** @type {string} */
            request.path
          );
          const filename = (
            /** @type {string} */
            basename(requestPath)
          );
          const filePath = resolver.join(requestPath, filename);
          const obj = {
            ...request,
            path: filePath,
            relativePath: request.relativePath && resolver.join(request.relativePath, filename)
          };
          resolver.doResolve(
            target,
            obj,
            "using path: " + filePath,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/LogInfoPlugin.js
var require_LogInfoPlugin = __commonJS({
  "../../node_modules/enhanced-resolve/lib/LogInfoPlugin.js"(exports, module) {
    "use strict";
    module.exports = class LogInfoPlugin {
      /**
       * @param {string | ResolveStepHook} source source
       */
      constructor(source) {
        this.source = source;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const source = this.source;
        resolver.getHook(this.source).tapAsync("LogInfoPlugin", (request, resolveContext, callback) => {
          if (!resolveContext.log)
            return callback();
          const log = resolveContext.log;
          const prefix = "[" + source + "] ";
          if (request.path)
            log(prefix + "Resolving in directory: " + request.path);
          if (request.request)
            log(prefix + "Resolving request: " + request.request);
          if (request.module)
            log(prefix + "Request is an module request.");
          if (request.directory)
            log(prefix + "Request is a directory request.");
          if (request.query)
            log(prefix + "Resolving request query: " + request.query);
          if (request.fragment)
            log(prefix + "Resolving request fragment: " + request.fragment);
          if (request.descriptionFilePath)
            log(
              prefix + "Has description data from " + request.descriptionFilePath
            );
          if (request.relativePath)
            log(
              prefix + "Relative path from description file is: " + request.relativePath
            );
          callback();
        });
      }
    };
  }
});

// ../../node_modules/enhanced-resolve/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/enhanced-resolve/lib/index.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var CachedInputFileSystem = require_CachedInputFileSystem();
    var ResolverFactory = require_ResolverFactory();
    var nodeFileSystem = new CachedInputFileSystem(fs2, 4e3);
    var nodeContext = {
      environments: ["node+es3+es5+process+native"]
    };
    var asyncResolver = ResolverFactory.createResolver({
      conditionNames: ["node"],
      extensions: [".js", ".json", ".node"],
      fileSystem: nodeFileSystem
    });
    var resolve2 = (
      /**
       * @param {object|string} context
       * @param {string} path
       * @param {string|ResolveContext|ResolveCallback} request
       * @param {ResolveContext|ResolveCallback=} resolveContext
       * @param {ResolveCallback=} callback
       */
      (context, path4, request, resolveContext, callback) => {
        if (typeof context === "string") {
          callback = /** @type {ResolveCallback} */
          resolveContext;
          resolveContext = /** @type {ResolveContext} */
          request;
          request = path4;
          path4 = context;
          context = nodeContext;
        }
        if (typeof callback !== "function") {
          callback = /** @type {ResolveCallback} */
          resolveContext;
        }
        asyncResolver.resolve(
          context,
          path4,
          /** @type {string} */
          request,
          /** @type {ResolveContext} */
          resolveContext,
          /** @type {ResolveCallback} */
          callback
        );
      }
    );
    var syncResolver = ResolverFactory.createResolver({
      conditionNames: ["node"],
      extensions: [".js", ".json", ".node"],
      useSyncFileSystemCalls: true,
      fileSystem: nodeFileSystem
    });
    var resolveSync = (
      /**
       * @param {object|string} context
       * @param {string} path
       * @param {string=} request
       */
      (context, path4, request) => {
        if (typeof context === "string") {
          request = path4;
          path4 = context;
          context = nodeContext;
        }
        return syncResolver.resolveSync(
          context,
          path4,
          /** @type {string} */
          request
        );
      }
    );
    function create(options) {
      const resolver = ResolverFactory.createResolver({
        fileSystem: nodeFileSystem,
        ...options
      });
      return function(context, path4, request, resolveContext, callback) {
        if (typeof context === "string") {
          callback = /** @type {ResolveCallback} */
          resolveContext;
          resolveContext = /** @type {ResolveContext} */
          request;
          request = path4;
          path4 = context;
          context = nodeContext;
        }
        if (typeof callback !== "function") {
          callback = /** @type {ResolveCallback} */
          resolveContext;
        }
        resolver.resolve(
          context,
          path4,
          /** @type {string} */
          request,
          /** @type {ResolveContext} */
          resolveContext,
          callback
        );
      };
    }
    function createSync(options) {
      const resolver = ResolverFactory.createResolver({
        useSyncFileSystemCalls: true,
        fileSystem: nodeFileSystem,
        ...options
      });
      return function(context, path4, request) {
        if (typeof context === "string") {
          request = path4;
          path4 = context;
          context = nodeContext;
        }
        return resolver.resolveSync(
          context,
          path4,
          /** @type {string} */
          request
        );
      };
    }
    var mergeExports = (obj, exports2) => {
      const descriptors = Object.getOwnPropertyDescriptors(exports2);
      Object.defineProperties(obj, descriptors);
      return (
        /** @type {A & B} */
        Object.freeze(obj)
      );
    };
    module.exports = mergeExports(resolve2, {
      get sync() {
        return resolveSync;
      },
      create: mergeExports(create, {
        get sync() {
          return createSync;
        }
      }),
      ResolverFactory,
      CachedInputFileSystem,
      get CloneBasenamePlugin() {
        return require_CloneBasenamePlugin();
      },
      get LogInfoPlugin() {
        return require_LogInfoPlugin();
      },
      get forEachBail() {
        return require_forEachBail();
      }
    });
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/is-core-module/core.json
var require_core = __commonJS({
  "../../node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "../../node_modules/is-core-module/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore2(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// ../../node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "../../node_modules/fast-glob/out/utils/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// ../../node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "../../node_modules/fast-glob/out/utils/errno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// ../../node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "../../node_modules/fast-glob/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/fast-glob/out/utils/path.js
var require_path2 = __commonJS({
  "../../node_modules/fast-glob/out/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
    var os = __require("os");
    var path4 = __require("path");
    var IS_WINDOWS_PLATFORM = os.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path4.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
    exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapePosixPath = escapePosixPath;
    exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "../../node_modules/is-extglob/index.js"(exports, module) {
    module.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "../../node_modules/is-glob/index.js"(exports, module) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// ../../node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "../../node_modules/glob-parent/index.js"(exports, module) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = __require("path").posix.dirname;
    var isWin32 = __require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// ../../node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// ../../node_modules/is-number/index.js
var require_is_number = __commonJS({
  "../../node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "../../node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "../../node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill;
  }
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "../../node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "../../node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// ../../node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// ../../node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module.exports = parse;
  }
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS({
  "../../node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module.exports = braces;
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path4.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path4 = __require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path4.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob2 = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils.removeBackslashes(glob2);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var scan = require_scan();
    var parse = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob2, options, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob: glob2, posix });
        const result = { glob: glob2, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob: glob2, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob2;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob2;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob2, options, posix = utils.isWindows(options)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
      return regex.test(path4.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// ../../node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "../../node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob2, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob2), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module.exports = micromatch;
  }
});

// ../../node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/fast-glob/out/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path4 = __require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path4.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });
      patterns.sort((a, b) => a.length - b.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// ../../node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "../../node_modules/merge2/index.js"(exports, module) {
    "use strict";
    var Stream = __require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// ../../node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "../../node_modules/fast-glob/out/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// ../../node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "../../node_modules/fast-glob/out/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty;
  }
});

// ../../node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "../../node_modules/fast-glob/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array = require_array();
    exports.array = array;
    var errno = require_errno();
    exports.errno = errno;
    var fs2 = require_fs();
    exports.fs = fs2;
    var path4 = require_path2();
    exports.path = path4;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream = require_stream();
    exports.stream = stream;
    var string = require_string();
    exports.string = string;
  }
});

// ../../node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "../../node_modules/fast-glob/out/managers/tasks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils = require_utils3();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path4, settings, callback) {
      settings.fs.lstat(path4, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path4, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path4, settings) {
      const lstat = settings.fs.lstatSync(path4);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path4);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports.read = read;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs2 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat(path4, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path4, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path4, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat;
    function statSync(path4, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path4, settings);
    }
    exports.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "../../node_modules/queue-microtask/index.js"(exports, module) {
    var promise;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// ../../node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "../../node_modules/run-parallel/index.js"(exports, module) {
    module.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs2 = require_fs3();
    exports.fs = fs2;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path4 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path4, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path: path4,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path4 = __require("path");
    var fsStat = require_out();
    var fs2 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path4.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path4, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path4, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path4, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path4, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path4, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "../../node_modules/reusify/reusify.js"(exports, module) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module.exports = reusify;
  }
});

// ../../node_modules/fastq/queue.js
var require_queue = __commonJS({
  "../../node_modules/fastq/queue.js"(exports, module) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self.paused)
          return;
        self.paused = false;
        for (var i = 0; i < self.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self.concurrency || self.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self.concurrency || self.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self.drain();
        self.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self = this;
      this.worked = function worked(err, result) {
        var callback = self.callback;
        var errorHandler = self.errorHandler;
        var val = self.value;
        self.value = null;
        self.callback = noop;
        if (self.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self.context, err, result);
        self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve2, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve2, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve2) {
            resolve2();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve2) {
          queue.drain = function() {
            previousDrain();
            resolve2();
          };
        });
        return p;
      }
    }
    module.exports = fastqueue;
    module.exports.promise = queueAsPromised;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path4 = __require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path4.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "../../node_modules/fast-glob/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path4 = __require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path4.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// ../../node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "../../node_modules/fast-glob/out/readers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve2, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve2(stats) : reject(error);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// ../../node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "../../node_modules/fast-glob/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve2, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve2(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve2, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve2(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// ../../node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "../../node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// ../../node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "../../node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "../../node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// ../../node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "../../node_modules/fast-glob/out/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path4 = __require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path4.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// ../../node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "../../node_modules/fast-glob/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderAsync;
  }
});

// ../../node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "../../node_modules/fast-glob/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderStream;
  }
});

// ../../node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "../../node_modules/fast-glob/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// ../../node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "../../node_modules/fast-glob/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderSync;
  }
});

// ../../node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "../../node_modules/fast-glob/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = __require("fs");
    var os = __require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      lstatSync: fs2.lstatSync,
      stat: fs2.stat,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
        this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// ../../node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "../../node_modules/fast-glob/out/index.js"(exports, module) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync;
      FastGlob2.globStream = stream;
      FastGlob2.async = FastGlob2;
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module.exports = FastGlob;
  }
});

// lib/index.js
var import_enhanced_resolve = __toESM(require_lib2(), 1);
var import_is_core_module = __toESM(require_is_core_module(), 1);
var import_fast_glob = __toESM(require_out4(), 1);
import path3 from "path";

// ../../node_modules/pkg-up/node_modules/find-up/index.js
import path2 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";

// ../../node_modules/pkg-up/node_modules/locate-path/index.js
import process2 from "node:process";
import path from "node:path";
import fs, { promises as fsPromises } from "node:fs";
import { fileURLToPath } from "node:url";

// ../../node_modules/pkg-up/node_modules/yocto-queue/index.js
var Node = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
};
var Queue = class {
  #head;
  #tail;
  #size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (this.#head) {
      this.#tail.next = node;
      this.#tail = node;
    } else {
      this.#head = node;
      this.#tail = node;
    }
    this.#size++;
  }
  dequeue() {
    const current = this.#head;
    if (!current) {
      return;
    }
    this.#head = this.#head.next;
    this.#size--;
    return current.value;
  }
  clear() {
    this.#head = void 0;
    this.#tail = void 0;
    this.#size = 0;
  }
  get size() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    let current = this.#head;
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};

// ../../node_modules/pkg-up/node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve2, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve2(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve2, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve2, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve2) => {
    enqueue(fn, resolve2, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// ../../node_modules/pkg-up/node_modules/p-locate/index.js
var EndError = class extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
};
var testElement = async (element, tester) => tester(await element);
var finder = async (element) => {
  const values = await Promise.all(element);
  if (values[1] === true) {
    throw new EndError(values[0]);
  }
  return false;
};
async function pLocate(iterable, tester, {
  concurrency = Number.POSITIVE_INFINITY,
  preserveOrder = true
} = {}) {
  const limit = pLimit(concurrency);
  const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
  const checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);
  try {
    await Promise.all(items.map((element) => checkLimit(finder, element)));
  } catch (error) {
    if (error instanceof EndError) {
      return error.value;
    }
    throw error;
  }
}

// ../../node_modules/pkg-up/node_modules/locate-path/index.js
var typeMappings = {
  directory: "isDirectory",
  file: "isFile"
};
function checkType(type) {
  if (Object.hasOwnProperty.call(typeMappings, type)) {
    return;
  }
  throw new Error(`Invalid type specified: ${type}`);
}
var matchType = (type, stat) => stat[typeMappings[type]]();
var toPath = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
async function locatePath(paths, {
  cwd = process2.cwd(),
  type = "file",
  allowSymlinks = true,
  concurrency,
  preserveOrder
} = {}) {
  checkType(type);
  cwd = toPath(cwd);
  const statFunction = allowSymlinks ? fsPromises.stat : fsPromises.lstat;
  return pLocate(paths, async (path_) => {
    try {
      const stat = await statFunction(path.resolve(cwd, path_));
      return matchType(type, stat);
    } catch {
      return false;
    }
  }, { concurrency, preserveOrder });
}

// ../../node_modules/pkg-up/node_modules/find-up/index.js
var toPath2 = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath2(urlOrPath) : urlOrPath;
var findUpStop = Symbol("findUpStop");
async function findUpMultiple(name, options = {}) {
  let directory = path2.resolve(toPath2(options.cwd) || "");
  const { root } = path2.parse(directory);
  const stopAt = path2.resolve(directory, options.stopAt || root);
  const limit = options.limit || Number.POSITIVE_INFINITY;
  const paths = [name].flat();
  const runMatcher = async (locateOptions) => {
    if (typeof name !== "function") {
      return locatePath(paths, locateOptions);
    }
    const foundPath = await name(locateOptions.cwd);
    if (typeof foundPath === "string") {
      return locatePath([foundPath], locateOptions);
    }
    return foundPath;
  };
  const matches = [];
  while (true) {
    const foundPath = await runMatcher({ ...options, cwd: directory });
    if (foundPath === findUpStop) {
      break;
    }
    if (foundPath) {
      matches.push(path2.resolve(directory, foundPath));
    }
    if (directory === stopAt || matches.length >= limit) {
      break;
    }
    directory = path2.dirname(directory);
  }
  return matches;
}
async function findUp(name, options = {}) {
  const matches = await findUpMultiple(name, { ...options, limit: 1 });
  return matches[0];
}

// ../../node_modules/pkg-up/index.js
async function pkgUp({ cwd } = {}) {
  return findUp("package.json", { cwd });
}

// lib/index.js
function createResolver(options = {}) {
  const resolver = import_enhanced_resolve.default.create({
    symlinks: false,
    ...options
  });
  const resolve2 = async function(specifier, importer) {
    const { path: path4, searchParams } = getSearchParams(specifier);
    importer = getBasePath(importer);
    const resolved = await new Promise(
      (resolve3, reject) => resolver(
        {},
        importer,
        path4,
        {},
        /**
         * @param {Error|null} err
         * @param {string|false} [data]
         */
        (err, data) => err ? reject(err) : resolve3(data)
      )
    );
    if (!resolved) {
      return resolved;
    }
    return `${resolved}${searchParams.toString() ? `?${searchParams.toString()}` : ""}`;
  };
  return resolve2;
}
var JS_EXTENSIONS = [".cjs", ".mjs", ".js", ".jsx", ".ts", ".tsx"];
var JSON_EXTENSIONS = [".json", ".geojson"];
var CSS_EXTENSIONS = [".css", ".scss", ".sass", ".less"];
var HTML_EXTENSIONS = [".html", ".htm"];
function isJs(filePath) {
  return JS_EXTENSIONS.includes(path3.posix.extname(getFileName(filePath)));
}
function isJson(filePath) {
  return JSON_EXTENSIONS.includes(path3.posix.extname(getFileName(filePath)));
}
function isCss(filePath) {
  return CSS_EXTENSIONS.includes(path3.posix.extname(getFileName(filePath)));
}
function isHtml(filePath) {
  return HTML_EXTENSIONS.includes(path3.posix.extname(getFileName(filePath)));
}
var resolve = createResolver();
var styleResolve = createResolver({
  extensions: [".css"],
  mainFields: ["style"],
  preferRelative: true
});
var browserResolve = createResolver({
  extensions: JS_EXTENSIONS,
  conditionNames: ["default", "module", "import", "browser"],
  mainFields: ["module", "esnext", "jsnext", "jsnext:main", "browser", "main"],
  aliasFields: ["browser"]
});
async function fsResolve(specifier, importer) {
  return path3.resolve(getBasePath(importer), specifier);
}
function getFileName(filePath) {
  filePath = filePath.replace("file://", "");
  return getSearchParams(filePath).path;
}
function getBasePath(filePath) {
  filePath = getFileName(filePath);
  if (path3.extname(filePath)) {
    return path3.dirname(filePath);
  }
  return filePath;
}
function isUrl(url) {
  try {
    return !!new URL(url);
  } catch (err) {
  }
  return false;
}
function isRelativeUrl(url) {
  return !!url && !isUrl(url) && !path3.isAbsolute(url);
}
function getSearchParams(source) {
  const [path4, ...chunks] = source.split("?");
  const searchParams = new URLSearchParams(chunks.join("?"));
  return {
    path: path4,
    searchParams
  };
}
function appendSearchParam(source, param, value) {
  const { path: path4, searchParams } = getSearchParams(source);
  if (searchParams.has(param)) {
    searchParams.delete(param);
  }
  searchParams.append(param, value);
  return `${path4}?${searchParams.toString()}`;
}
function hasSearchParam(source, param) {
  const { searchParams } = getSearchParams(source);
  return searchParams.has(param);
}
function removeSearchParam(source, param) {
  const { path: path4, searchParams } = getSearchParams(source);
  if (searchParams.has(param)) {
    searchParams.delete(param);
  }
  searchParams.delete(param);
  const newSearch = searchParams.toString();
  return `${path4}${newSearch ? `?${newSearch}` : ""}`;
}
function getSearchParam(source, param) {
  const { searchParams } = getSearchParams(source);
  return searchParams.get(param) || null;
}
var export_glob = import_fast_glob.default;
var export_isCore = import_is_core_module.default;
export {
  CSS_EXTENSIONS,
  HTML_EXTENSIONS,
  JSON_EXTENSIONS,
  JS_EXTENSIONS,
  appendSearchParam,
  browserResolve,
  createResolver,
  fsResolve,
  getBasePath,
  getFileName,
  getSearchParam,
  getSearchParams,
  export_glob as glob,
  hasSearchParam,
  export_isCore as isCore,
  isCss,
  isHtml,
  isJs,
  isJson,
  isRelativeUrl,
  isUrl,
  pkgUp,
  removeSearchParam,
  resolve,
  styleResolve
};
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=index.js.map
