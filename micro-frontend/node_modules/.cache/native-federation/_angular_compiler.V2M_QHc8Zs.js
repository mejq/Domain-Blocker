import { a as E, b as ae } from "@nf-internal/chunk-4CLCTAJ7";
var qu = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g"), On = class n {
    element = null;
    classNames = [];
    attrs = [];
    notSelectors = [];
    static parse(e) { let t = [], s = (l, u) => { u.notSelectors.length > 0 && !u.element && u.classNames.length == 0 && u.attrs.length == 0 && (u.element = "*"), l.push(u); }, r = new n, i, o = r, a = !1; for (qu.lastIndex = 0; i = qu.exec(e);) {
        if (i[1]) {
            if (a)
                throw new Error("Nesting :not in a selector is not allowed");
            a = !0, o = new n, r.notSelectors.push(o);
        }
        let l = i[2];
        if (l) {
            let p = i[3];
            p === "#" ? o.addAttribute("id", l.slice(1)) : p === "." ? o.addClassName(l.slice(1)) : o.setElement(l);
        }
        let u = i[4];
        if (u && o.addAttribute(o.unescapeAttribute(u), i[6]), i[7] && (a = !1, o = r), i[8]) {
            if (a)
                throw new Error("Multiple selectors in :not are not supported");
            s(t, r), r = o = new n;
        }
    } return s(t, r), t; }
    unescapeAttribute(e) { let t = "", s = !1; for (let r = 0; r < e.length; r++) {
        let i = e.charAt(r);
        if (i === "\\") {
            s = !0;
            continue;
        }
        if (i === "$" && !s)
            throw new Error(`Error in attribute selector "${e}". Unescaped "$" is not supported. Please escape with "\\$".`);
        s = !1, t += i;
    } return t; }
    escapeAttribute(e) { return e.replace(/\\/g, "\\\\").replace(/\$/g, "\\$"); }
    isElementSelector() { return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0; }
    hasElementSelector() { return !!this.element; }
    setElement(e = null) { this.element = e; }
    getAttrs() { let e = []; return this.classNames.length > 0 && e.push("class", this.classNames.join(" ")), e.concat(this.attrs); }
    addAttribute(e, t = "") { this.attrs.push(e, t && t.toLowerCase() || ""); }
    addClassName(e) { this.classNames.push(e.toLowerCase()); }
    toString() { let e = this.element || ""; if (this.classNames && this.classNames.forEach(t => e += `.${t}`), this.attrs)
        for (let t = 0; t < this.attrs.length; t += 2) {
            let s = this.escapeAttribute(this.attrs[t]), r = this.attrs[t + 1];
            e += `[${s}${r ? "=" + r : ""}]`;
        } return this.notSelectors.forEach(t => e += `:not(${t})`), e; }
}, fr = class n {
    static createNotMatcher(e) { let t = new n; return t.addSelectables(e, null), t; }
    _elementMap = new Map;
    _elementPartialMap = new Map;
    _classMap = new Map;
    _classPartialMap = new Map;
    _attrValueMap = new Map;
    _attrValuePartialMap = new Map;
    _listContexts = [];
    addSelectables(e, t) { let s = null; e.length > 1 && (s = new Sa(e), this._listContexts.push(s)); for (let r = 0; r < e.length; r++)
        this._addSelectable(e[r], t, s); }
    _addSelectable(e, t, s) { let r = this, i = e.element, o = e.classNames, a = e.attrs, l = new xa(e, t, s); if (i && (a.length === 0 && o.length === 0 ? this._addTerminal(r._elementMap, i, l) : r = this._addPartial(r._elementPartialMap, i)), o)
        for (let u = 0; u < o.length; u++) {
            let p = a.length === 0 && u === o.length - 1, f = o[u];
            p ? this._addTerminal(r._classMap, f, l) : r = this._addPartial(r._classPartialMap, f);
        } if (a)
        for (let u = 0; u < a.length; u += 2) {
            let p = u === a.length - 2, f = a[u], g = a[u + 1];
            if (p) {
                let v = r._attrValueMap, S = v.get(f);
                S || (S = new Map, v.set(f, S)), this._addTerminal(S, g, l);
            }
            else {
                let v = r._attrValuePartialMap, S = v.get(f);
                S || (S = new Map, v.set(f, S)), r = this._addPartial(S, g);
            }
        } }
    _addTerminal(e, t, s) { let r = e.get(t); r || (r = [], e.set(t, r)), r.push(s); }
    _addPartial(e, t) { let s = e.get(t); return s || (s = new n, e.set(t, s)), s; }
    match(e, t) { let s = !1, r = e.element, i = e.classNames, o = e.attrs; for (let a = 0; a < this._listContexts.length; a++)
        this._listContexts[a].alreadyMatched = !1; if (s = this._matchTerminal(this._elementMap, r, e, t) || s, s = this._matchPartial(this._elementPartialMap, r, e, t) || s, i)
        for (let a = 0; a < i.length; a++) {
            let l = i[a];
            s = this._matchTerminal(this._classMap, l, e, t) || s, s = this._matchPartial(this._classPartialMap, l, e, t) || s;
        } if (o)
        for (let a = 0; a < o.length; a += 2) {
            let l = o[a], u = o[a + 1], p = this._attrValueMap.get(l);
            u && (s = this._matchTerminal(p, "", e, t) || s), s = this._matchTerminal(p, u, e, t) || s;
            let f = this._attrValuePartialMap.get(l);
            u && (s = this._matchPartial(f, "", e, t) || s), s = this._matchPartial(f, u, e, t) || s;
        } return s; }
    _matchTerminal(e, t, s, r) { if (!e || typeof t != "string")
        return !1; let i = e.get(t) || [], o = e.get("*"); if (o && (i = i.concat(o)), i.length === 0)
        return !1; let a, l = !1; for (let u = 0; u < i.length; u++)
        a = i[u], l = a.finalize(s, r) || l; return l; }
    _matchPartial(e, t, s, r) { if (!e || typeof t != "string")
        return !1; let i = e.get(t); return i ? i.match(s, r) : !1; }
}, Sa = class {
    selectors;
    alreadyMatched = !1;
    constructor(e) { this.selectors = e; }
}, xa = class {
    selector;
    cbContext;
    listContext;
    notSelectors;
    constructor(e, t, s) { this.selector = e, this.cbContext = t, this.listContext = s, this.notSelectors = e.notSelectors; }
    finalize(e, t) { let s = !0; return this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched) && (s = !fr.createNotMatcher(this.notSelectors).match(e, null)), s && t && (!this.listContext || !this.listContext.alreadyMatched) && (this.listContext && (this.listContext.alreadyMatched = !0), t(this.selector, this.cbContext)), s; }
}, Of = !0, ct = function (n) { return n[n.Emulated = 0] = "Emulated", n[n.None = 2] = "None", n[n.ShadowDom = 3] = "ShadowDom", n; }(ct || {}), si = function (n) { return n[n.OnPush = 0] = "OnPush", n[n.Default = 1] = "Default", n; }(si || {}), ls = function (n) { return n[n.None = 0] = "None", n[n.SignalBased = 1] = "SignalBased", n[n.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", n; }(ls || {}), ya = { name: "custom-elements" }, Ca = { name: "no-errors-schema" }, Vf = Function, ee = function (n) { return n[n.NONE = 0] = "NONE", n[n.HTML = 1] = "HTML", n[n.STYLE = 2] = "STYLE", n[n.SCRIPT = 3] = "SCRIPT", n[n.URL = 4] = "URL", n[n.RESOURCE_URL = 5] = "RESOURCE_URL", n; }(ee || {}), vs = function (n) { return n[n.Error = 0] = "Error", n[n.Warning = 1] = "Warning", n[n.Ignore = 2] = "Ignore", n; }(vs || {});
function qf(n) { let e = n.classNames && n.classNames.length ? [8, ...n.classNames] : []; return [n.element && n.element !== "*" ? n.element : "", ...n.attrs, ...e]; }
function Hf(n) { let e = n.classNames && n.classNames.length ? [8, ...n.classNames] : []; return n.element ? [5, n.element, ...n.attrs, ...e] : n.attrs.length ? [3, ...n.attrs, ...e] : n.classNames && n.classNames.length ? [9, ...n.classNames] : []; }
function Uf(n) { let e = qf(n), t = n.notSelectors && n.notSelectors.length ? n.notSelectors.map(s => Hf(s)) : []; return e.concat(...t); }
function $o(n) { return n ? On.parse(n).map(Uf) : []; }
var MC = Object.freeze({ __proto__: null, CUSTOM_ELEMENTS_SCHEMA: ya, get ChangeDetectionStrategy() { return si; }, get InputFlags() { return ls; }, get MissingTranslationStrategy() { return vs; }, NO_ERRORS_SCHEMA: Ca, get SecurityContext() { return ee; }, Type: Vf, get ViewEncapsulation() { return ct; }, emitDistinctChangesOnlyDefaultValue: Of, parseSelectorToR3Selector: $o }), At = function (n) { return n[n.Directive = 0] = "Directive", n[n.Component = 1] = "Component", n[n.Injectable = 2] = "Injectable", n[n.Pipe = 3] = "Pipe", n[n.NgModule = 4] = "NgModule", n; }(At || {});
var Ci;
function Pp(n) { return n.id || Lp(n); }
function Lp(n) { return zf(jf(n.nodes).join("") + `[${n.meaning}]`); }
function hu(n) { return n.id || Bp(n); }
function Bp(n) { let e = new Aa, t = n.nodes.map(s => s.visit(e, null)); return Mp(t.join(""), n.meaning); }
var Ai = class {
    visitText(e, t) { return e.value; }
    visitContainer(e, t) { return `[${e.children.map(s => s.visit(this)).join(", ")}]`; }
    visitIcu(e, t) { let s = Object.keys(e.cases).map(r => `${r} {${e.cases[r].visit(this)}}`); return `{${e.expression}, ${e.type}, ${s.join(", ")}}`; }
    visitTagPlaceholder(e, t) { return e.isVoid ? `<ph tag name="${e.startName}"/>` : `<ph tag name="${e.startName}">${e.children.map(s => s.visit(this)).join(", ")}</ph name="${e.closeName}">`; }
    visitPlaceholder(e, t) { return e.value ? `<ph name="${e.name}">${e.value}</ph>` : `<ph name="${e.name}"/>`; }
    visitIcuPlaceholder(e, t) { return `<ph icu name="${e.name}">${e.value.visit(this)}</ph>`; }
    visitBlockPlaceholder(e, t) { return `<ph block name="${e.startName}">${e.children.map(s => s.visit(this)).join(", ")}</ph name="${e.closeName}">`; }
}, Wf = new Ai;
function jf(n) { return n.map(e => e.visit(Wf, null)); }
var Aa = class extends Ai {
    visitIcu(e) { let t = Object.keys(e.cases).map(s => `${s} {${e.cases[s].visit(this)}}`); return `{${e.type}, ${t.join(", ")}}`; }
};
function zf(n) { Ci ??= new TextEncoder; let e = [...Ci.encode(n)], t = Yf(e, fu.Big), s = e.length * 8, r = new Uint32Array(80), i = 1732584193, o = 4023233417, a = 2562383102, l = 271733878, u = 3285377520; t[s >> 5] |= 128 << 24 - s % 32, t[(s + 64 >> 9 << 4) + 15] = s; for (let p = 0; p < t.length; p += 16) {
    let f = i, g = o, v = a, S = l, _ = u;
    for (let x = 0; x < 80; x++) {
        x < 16 ? r[x] = t[p + x] : r[x] = Zo(r[x - 3] ^ r[x - 8] ^ r[x - 14] ^ r[x - 16], 1);
        let T = Gf(x, o, a, l), M = T[0], Z = T[1], te = [Zo(i, 5), M, u, Z, r[x]].reduce(ts);
        u = l, l = a, a = Zo(o, 30), o = i, i = te;
    }
    i = ts(i, f), o = ts(o, g), a = ts(a, v), l = ts(l, S), u = ts(u, _);
} return Xs(i) + Xs(o) + Xs(a) + Xs(l) + Xs(u); }
function Xs(n) { return (n >>> 0).toString(16).padStart(8, "0"); }
function Gf(n, e, t, s) { return n < 20 ? [e & t | ~e & s, 1518500249] : n < 40 ? [e ^ t ^ s, 1859775393] : n < 60 ? [e & t | e & s | t & s, 2400959708] : [e ^ t ^ s, 3395469782]; }
function Hu(n) { Ci ??= new TextEncoder; let e = Ci.encode(n), t = new DataView(e.buffer, e.byteOffset, e.byteLength), s = Uu(t, e.length, 0), r = Uu(t, e.length, 102072); return s == 0 && (r == 0 || r == 1) && (s = s ^ 319790063, r = r ^ -1801410264), BigInt.asUintN(32, BigInt(s)) << BigInt(32) | BigInt.asUintN(32, BigInt(r)); }
function Mp(n, e = "") { let t = Hu(n); return e && (t = BigInt.asUintN(64, t << BigInt(1)) | t >> BigInt(63) & BigInt(1), t += Hu(e)), BigInt.asUintN(63, t).toString(); }
function Uu(n, e, t) { let s = 2654435769, r = 2654435769, i = 0, o = e - 12; for (; i <= o; i += 12) {
    s += n.getUint32(i, !0), r += n.getUint32(i + 4, !0), t += n.getUint32(i + 8, !0);
    let l = Wu(s, r, t);
    s = l[0], r = l[1], t = l[2];
} let a = e - i; return t += e, a >= 4 ? (s += n.getUint32(i, !0), i += 4, a >= 8 ? (r += n.getUint32(i, !0), i += 4, a >= 9 && (t += n.getUint8(i++) << 8), a >= 10 && (t += n.getUint8(i++) << 16), a === 11 && (t += n.getUint8(i++) << 24)) : (a >= 5 && (r += n.getUint8(i++)), a >= 6 && (r += n.getUint8(i++) << 8), a === 7 && (r += n.getUint8(i++) << 16))) : (a >= 1 && (s += n.getUint8(i++)), a >= 2 && (s += n.getUint8(i++) << 8), a === 3 && (s += n.getUint8(i++) << 16)), Wu(s, r, t)[2]; }
function Wu(n, e, t) { return n -= e, n -= t, n ^= t >>> 13, e -= t, e -= n, e ^= n << 8, t -= n, t -= e, t ^= e >>> 13, n -= e, n -= t, n ^= t >>> 12, e -= t, e -= n, e ^= n << 16, t -= n, t -= e, t ^= e >>> 5, n -= e, n -= t, n ^= t >>> 3, e -= t, e -= n, e ^= n << 10, t -= n, t -= e, t ^= e >>> 15, [n, e, t]; }
var fu = function (n) { return n[n.Little = 0] = "Little", n[n.Big = 1] = "Big", n; }(fu || {});
function ts(n, e) { return Xf(n, e)[1]; }
function Xf(n, e) { let t = (n & 65535) + (e & 65535), s = (n >>> 16) + (e >>> 16) + (t >>> 16); return [s >>> 16, s << 16 | t & 65535]; }
function Zo(n, e) { return n << e | n >>> 32 - e; }
function Yf(n, e) { let t = n.length + 3 >>> 2, s = []; for (let r = 0; r < t; r++)
    s[r] = Qf(n, r * 4, e); return s; }
function ju(n, e) { return e >= n.length ? 0 : n[e]; }
function Qf(n, e, t) { let s = 0; if (t === fu.Big)
    for (let r = 0; r < 4; r++)
        s += ju(n, e + r) << 24 - 8 * r;
else
    for (let r = 0; r < 4; r++)
        s += ju(n, e + r) << 8 * r; return s; }
var du = function (n) { return n[n.None = 0] = "None", n[n.Const = 1] = "Const", n; }(du || {}), cn = class {
    modifiers;
    constructor(e = du.None) { this.modifiers = e; }
    hasModifier(e) { return (this.modifiers & e) !== 0; }
}, Mt = function (n) { return n[n.Dynamic = 0] = "Dynamic", n[n.Bool = 1] = "Bool", n[n.String = 2] = "String", n[n.Int = 3] = "Int", n[n.Number = 4] = "Number", n[n.Function = 5] = "Function", n[n.Inferred = 6] = "Inferred", n[n.None = 7] = "None", n; }(Mt || {}), dt = class extends cn {
    name;
    constructor(e, t) { super(t), this.name = e; }
    visitType(e, t) { return e.visitBuiltinType(this, t); }
}, He = class extends cn {
    value;
    typeParams;
    constructor(e, t, s = null) { super(t), this.value = e, this.typeParams = s; }
    visitType(e, t) { return e.visitExpressionType(this, t); }
}, _a = class extends cn {
    of;
    constructor(e, t) { super(t), this.of = e; }
    visitType(e, t) { return e.visitArrayType(this, t); }
}, Ta = class extends cn {
    valueType;
    constructor(e, t) { super(t), this.valueType = e || null; }
    visitType(e, t) { return e.visitMapType(this, t); }
}, _i = class extends cn {
    type;
    constructor(e, t) { super(t), this.type = e; }
    visitType(e, t) { return e.visitTransplantedType(this, t); }
}, Be = new dt(Mt.Dynamic), Ve = new dt(Mt.Inferred), Rp = new dt(Mt.Bool), Zf = new dt(Mt.Int), Oo = new dt(Mt.Number), Vo = new dt(Mt.String), Jf = new dt(Mt.Function), mt = new dt(Mt.None), ws = function (n) { return n[n.Minus = 0] = "Minus", n[n.Plus = 1] = "Plus", n; }(ws || {}), b = function (n) { return n[n.Equals = 0] = "Equals", n[n.NotEquals = 1] = "NotEquals", n[n.Identical = 2] = "Identical", n[n.NotIdentical = 3] = "NotIdentical", n[n.Minus = 4] = "Minus", n[n.Plus = 5] = "Plus", n[n.Divide = 6] = "Divide", n[n.Multiply = 7] = "Multiply", n[n.Modulo = 8] = "Modulo", n[n.And = 9] = "And", n[n.Or = 10] = "Or", n[n.BitwiseOr = 11] = "BitwiseOr", n[n.BitwiseAnd = 12] = "BitwiseAnd", n[n.Lower = 13] = "Lower", n[n.LowerEquals = 14] = "LowerEquals", n[n.Bigger = 15] = "Bigger", n[n.BiggerEquals = 16] = "BiggerEquals", n[n.NullishCoalesce = 17] = "NullishCoalesce", n; }(b || {});
function Fp(n, e) { return n == null || e == null ? n == e : n.isEquivalent(e); }
function $p(n, e, t) { let s = n.length; if (s !== e.length)
    return !1; for (let r = 0; r < s; r++)
    if (!t(n[r], e[r]))
        return !1; return !0; }
function ke(n, e) { return $p(n, e, (t, s) => t.isEquivalent(s)); }
var j = class {
    type;
    sourceSpan;
    constructor(e, t) { this.type = e || null, this.sourceSpan = t || null; }
    prop(e, t) { return new Me(this, e, null, t); }
    key(e, t, s) { return new It(this, e, t, s); }
    callFn(e, t, s) { return new Ie(this, e, null, t, s); }
    instantiate(e, t, s) { return new Ss(this, e, t, s); }
    conditional(e, t = null, s) { return new kt(this, e, t, null, s); }
    equals(e, t) { return new W(b.Equals, this, e, null, t); }
    notEquals(e, t) { return new W(b.NotEquals, this, e, null, t); }
    identical(e, t) { return new W(b.Identical, this, e, null, t); }
    notIdentical(e, t) { return new W(b.NotIdentical, this, e, null, t); }
    minus(e, t) { return new W(b.Minus, this, e, null, t); }
    plus(e, t) { return new W(b.Plus, this, e, null, t); }
    divide(e, t) { return new W(b.Divide, this, e, null, t); }
    multiply(e, t) { return new W(b.Multiply, this, e, null, t); }
    modulo(e, t) { return new W(b.Modulo, this, e, null, t); }
    and(e, t) { return new W(b.And, this, e, null, t); }
    bitwiseOr(e, t, s = !0) { return new W(b.BitwiseOr, this, e, null, t, s); }
    bitwiseAnd(e, t, s = !0) { return new W(b.BitwiseAnd, this, e, null, t, s); }
    or(e, t) { return new W(b.Or, this, e, null, t); }
    lower(e, t) { return new W(b.Lower, this, e, null, t); }
    lowerEquals(e, t) { return new W(b.LowerEquals, this, e, null, t); }
    bigger(e, t) { return new W(b.Bigger, this, e, null, t); }
    biggerEquals(e, t) { return new W(b.BiggerEquals, this, e, null, t); }
    isBlank(e) { return this.equals(Op, e); }
    nullishCoalesce(e, t) { return new W(b.NullishCoalesce, this, e, null, t); }
    toStmt() { return new Ge(this, null); }
}, ze = class n extends j {
    name;
    constructor(e, t, s) { super(t, s), this.name = e; }
    isEquivalent(e) { return e instanceof n && this.name === e.name; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitReadVarExpr(this, t); }
    clone() { return new n(this.name, this.type, this.sourceSpan); }
    set(e) { return new dr(this.name, e, null, this.sourceSpan); }
}, Vn = class n extends j {
    expr;
    constructor(e, t, s) { super(t, s), this.expr = e; }
    visitExpression(e, t) { return e.visitTypeofExpr(this, t); }
    isEquivalent(e) { return e instanceof n && e.expr.isEquivalent(this.expr); }
    isConstant() { return this.expr.isConstant(); }
    clone() { return new n(this.expr.clone()); }
}, V = class n extends j {
    node;
    constructor(e, t, s) { super(t, s), this.node = e; }
    isEquivalent(e) { return e instanceof n && this.node === e.node; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitWrappedNodeExpr(this, t); }
    clone() { return new n(this.node, this.type, this.sourceSpan); }
}, dr = class n extends j {
    name;
    value;
    constructor(e, t, s, r) { super(s || t.type, r), this.name = e, this.value = t; }
    isEquivalent(e) { return e instanceof n && this.name === e.name && this.value.isEquivalent(e.value); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitWriteVarExpr(this, t); }
    clone() { return new n(this.name, this.value.clone(), this.type, this.sourceSpan); }
    toDeclStmt(e, t) { return new ve(this.name, this.value, e, t, this.sourceSpan); }
    toConstDecl() { return this.toDeclStmt(Ve, oe.Final); }
}, Es = class n extends j {
    receiver;
    index;
    value;
    constructor(e, t, s, r, i) { super(r || s.type, i), this.receiver = e, this.index = t, this.value = s; }
    isEquivalent(e) { return e instanceof n && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitWriteKeyExpr(this, t); }
    clone() { return new n(this.receiver.clone(), this.index.clone(), this.value.clone(), this.type, this.sourceSpan); }
}, qn = class n extends j {
    receiver;
    name;
    value;
    constructor(e, t, s, r, i) { super(r || s.type, i), this.receiver = e, this.name = t, this.value = s; }
    isEquivalent(e) { return e instanceof n && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitWritePropExpr(this, t); }
    clone() { return new n(this.receiver.clone(), this.name, this.value.clone(), this.type, this.sourceSpan); }
}, Ie = class n extends j {
    fn;
    args;
    pure;
    constructor(e, t, s, r, i = !1) { super(s, r), this.fn = e, this.args = t, this.pure = i; }
    get receiver() { return this.fn; }
    isEquivalent(e) { return e instanceof n && this.fn.isEquivalent(e.fn) && ke(this.args, e.args) && this.pure === e.pure; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitInvokeFunctionExpr(this, t); }
    clone() { return new n(this.fn.clone(), this.args.map(e => e.clone()), this.type, this.sourceSpan, this.pure); }
}, mr = class n extends j {
    tag;
    template;
    constructor(e, t, s, r) { super(s, r), this.tag = e, this.template = t; }
    isEquivalent(e) { return e instanceof n && this.tag.isEquivalent(e.tag) && this.template.isEquivalent(e.template); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitTaggedTemplateLiteralExpr(this, t); }
    clone() { return new n(this.tag.clone(), this.template.clone(), this.type, this.sourceSpan); }
}, Ss = class n extends j {
    classExpr;
    args;
    constructor(e, t, s, r) { super(s, r), this.classExpr = e, this.args = t; }
    isEquivalent(e) { return e instanceof n && this.classExpr.isEquivalent(e.classExpr) && ke(this.args, e.args); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitInstantiateExpr(this, t); }
    clone() { return new n(this.classExpr.clone(), this.args.map(e => e.clone()), this.type, this.sourceSpan); }
}, ge = class n extends j {
    value;
    constructor(e, t, s) { super(t, s), this.value = e; }
    isEquivalent(e) { return e instanceof n && this.value === e.value; }
    isConstant() { return !0; }
    visitExpression(e, t) { return e.visitLiteralExpr(this, t); }
    clone() { return new n(this.value, this.type, this.sourceSpan); }
}, xs = class n extends j {
    elements;
    expressions;
    constructor(e, t, s) { super(null, s), this.elements = e, this.expressions = t; }
    isEquivalent(e) { return e instanceof n && $p(this.elements, e.elements, (t, s) => t.text === s.text) && ke(this.expressions, e.expressions); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitTemplateLiteralExpr(this, t); }
    clone() { return new n(this.elements.map(e => e.clone()), this.expressions.map(e => e.clone())); }
}, gr = class n extends j {
    text;
    rawText;
    constructor(e, t, s) { super(Vo, t), this.text = e, this.rawText = s ?? ba(Ei(e)); }
    visitExpression(e, t) { return e.visitTemplateLiteralElementExpr(this, t); }
    isEquivalent(e) { return e instanceof n && e.text === this.text && e.rawText === this.rawText; }
    isConstant() { return !0; }
    clone() { return new n(this.text, this.sourceSpan, this.rawText); }
}, ln = class {
    text;
    sourceSpan;
    constructor(e, t) { this.text = e, this.sourceSpan = t; }
}, Pn = class {
    text;
    sourceSpan;
    associatedMessage;
    constructor(e, t, s) { this.text = e, this.sourceSpan = t, this.associatedMessage = s; }
}, Kf = "|", zu = "@@", ed = "\u241F", vr = class n extends j {
    metaBlock;
    messageParts;
    placeHolderNames;
    expressions;
    constructor(e, t, s, r, i) { super(Vo, i), this.metaBlock = e, this.messageParts = t, this.placeHolderNames = s, this.expressions = r; }
    isEquivalent(e) { return !1; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitLocalizedString(this, t); }
    clone() { return new n(this.metaBlock, this.messageParts, this.placeHolderNames, this.expressions.map(e => e.clone()), this.sourceSpan); }
    serializeI18nHead() { let e = this.metaBlock.description || ""; return this.metaBlock.meaning && (e = `${this.metaBlock.meaning}${Kf}${e}`), this.metaBlock.customId && (e = `${e}${zu}${this.metaBlock.customId}`), this.metaBlock.legacyIds && this.metaBlock.legacyIds.forEach(t => { e = `${e}${ed}${t}`; }), Gu(e, this.messageParts[0].text, this.getMessagePartSourceSpan(0)); }
    getMessagePartSourceSpan(e) { return this.messageParts[e]?.sourceSpan ?? this.sourceSpan; }
    getPlaceholderSourceSpan(e) { return this.placeHolderNames[e]?.sourceSpan ?? this.expressions[e]?.sourceSpan ?? this.sourceSpan; }
    serializeI18nTemplatePart(e) { let t = this.placeHolderNames[e - 1], s = this.messageParts[e], r = t.text; return t.associatedMessage?.legacyIds.length === 0 && (r += `${zu}${Mp(t.associatedMessage.messageString, t.associatedMessage.meaning)}`), Gu(r, s.text, this.getMessagePartSourceSpan(e)); }
}, Ei = n => n.replace(/\\/g, "\\\\"), td = n => n.replace(/^:/, "\\:"), nd = n => n.replace(/:/g, "\\:"), ba = n => n.replace(/`/g, "\\`").replace(/\${/g, "$\\{");
function Gu(n, e, t) { return n === "" ? { cooked: e, raw: ba(td(Ei(e))), range: t } : { cooked: `:${n}:${e}`, raw: ba(`:${nd(Ei(n))}:${Ei(e)}`), range: t }; }
var jt = class n extends j {
    value;
    typeParams;
    constructor(e, t, s = null, r) { super(t, r), this.value = e, this.typeParams = s; }
    isEquivalent(e) { return e instanceof n && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitExternalExpr(this, t); }
    clone() { return new n(this.value, this.type, this.typeParams, this.sourceSpan); }
}, ka = class {
    moduleName;
    name;
    constructor(e, t) { this.moduleName = e, this.name = t; }
}, kt = class n extends j {
    condition;
    falseCase;
    trueCase;
    constructor(e, t, s = null, r, i) { super(r || t.type, i), this.condition = e, this.falseCase = s, this.trueCase = t; }
    isEquivalent(e) { return e instanceof n && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && Fp(this.falseCase, e.falseCase); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitConditionalExpr(this, t); }
    clone() { return new n(this.condition.clone(), this.trueCase.clone(), this.falseCase?.clone(), this.type, this.sourceSpan); }
}, Hn = class n extends j {
    url;
    urlComment;
    constructor(e, t, s) { super(null, t), this.url = e, this.urlComment = s; }
    isEquivalent(e) { return e instanceof n && this.url === e.url && this.urlComment === e.urlComment; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitDynamicImportExpr(this, t); }
    clone() { return new n(typeof this.url == "string" ? this.url : this.url.clone(), this.sourceSpan, this.urlComment); }
}, ys = class n extends j {
    condition;
    constructor(e, t) { super(Rp, t), this.condition = e; }
    isEquivalent(e) { return e instanceof n && this.condition.isEquivalent(e.condition); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitNotExpr(this, t); }
    clone() { return new n(this.condition.clone(), this.sourceSpan); }
}, Y = class n {
    name;
    type;
    constructor(e, t = null) { this.name = e, this.type = t; }
    isEquivalent(e) { return this.name === e.name; }
    clone() { return new n(this.name, this.type); }
}, Ht = class n extends j {
    params;
    statements;
    name;
    constructor(e, t, s, r, i) { super(s, r), this.params = e, this.statements = t, this.name = i; }
    isEquivalent(e) { return (e instanceof n || e instanceof dn) && ke(this.params, e.params) && ke(this.statements, e.statements); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitFunctionExpr(this, t); }
    toDeclStmt(e, t) { return new dn(e, this.params, this.statements, this.type, t, this.sourceSpan); }
    clone() { return new n(this.params.map(e => e.clone()), this.statements, this.type, this.sourceSpan, this.name); }
}, pn = class n extends j {
    params;
    body;
    constructor(e, t, s, r) { super(s, r), this.params = e, this.body = t; }
    isEquivalent(e) { return !(e instanceof n) || !ke(this.params, e.params) ? !1 : this.body instanceof j && e.body instanceof j ? this.body.isEquivalent(e.body) : Array.isArray(this.body) && Array.isArray(e.body) ? ke(this.body, e.body) : !1; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitArrowFunctionExpr(this, t); }
    clone() { return new n(this.params.map(e => e.clone()), Array.isArray(this.body) ? this.body : this.body.clone(), this.type, this.sourceSpan); }
    toDeclStmt(e, t) { return new ve(e, this, Ve, t, this.sourceSpan); }
}, hn = class n extends j {
    operator;
    expr;
    parens;
    constructor(e, t, s, r, i = !0) { super(s || Oo, r), this.operator = e, this.expr = t, this.parens = i; }
    isEquivalent(e) { return e instanceof n && this.operator === e.operator && this.expr.isEquivalent(e.expr); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitUnaryOperatorExpr(this, t); }
    clone() { return new n(this.operator, this.expr.clone(), this.type, this.sourceSpan, this.parens); }
}, W = class n extends j {
    operator;
    rhs;
    parens;
    lhs;
    constructor(e, t, s, r, i, o = !0) { super(r || t.type, i), this.operator = e, this.rhs = s, this.parens = o, this.lhs = t; }
    isEquivalent(e) { return e instanceof n && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitBinaryOperatorExpr(this, t); }
    clone() { return new n(this.operator, this.lhs.clone(), this.rhs.clone(), this.type, this.sourceSpan, this.parens); }
}, Me = class n extends j {
    receiver;
    name;
    constructor(e, t, s, r) { super(s, r), this.receiver = e, this.name = t; }
    get index() { return this.name; }
    isEquivalent(e) { return e instanceof n && this.receiver.isEquivalent(e.receiver) && this.name === e.name; }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitReadPropExpr(this, t); }
    set(e) { return new qn(this.receiver, this.name, e, null, this.sourceSpan); }
    clone() { return new n(this.receiver.clone(), this.name, this.type, this.sourceSpan); }
}, It = class n extends j {
    receiver;
    index;
    constructor(e, t, s, r) { super(s, r), this.receiver = e, this.index = t; }
    isEquivalent(e) { return e instanceof n && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitReadKeyExpr(this, t); }
    set(e) { return new Es(this.receiver, this.index, e, null, this.sourceSpan); }
    clone() { return new n(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan); }
}, at = class n extends j {
    entries;
    constructor(e, t, s) { super(t, s), this.entries = e; }
    isConstant() { return this.entries.every(e => e.isConstant()); }
    isEquivalent(e) { return e instanceof n && ke(this.entries, e.entries); }
    visitExpression(e, t) { return e.visitLiteralArrayExpr(this, t); }
    clone() { return new n(this.entries.map(e => e.clone()), this.type, this.sourceSpan); }
}, Un = class n {
    key;
    value;
    quoted;
    constructor(e, t, s) { this.key = e, this.value = t, this.quoted = s; }
    isEquivalent(e) { return this.key === e.key && this.value.isEquivalent(e.value); }
    clone() { return new n(this.key, this.value.clone(), this.quoted); }
}, gt = class n extends j {
    entries;
    valueType = null;
    constructor(e, t, s) { super(t, s), this.entries = e, t && (this.valueType = t.valueType); }
    isEquivalent(e) { return e instanceof n && ke(this.entries, e.entries); }
    isConstant() { return this.entries.every(e => e.value.isConstant()); }
    visitExpression(e, t) { return e.visitLiteralMapExpr(this, t); }
    clone() { let e = this.entries.map(t => t.clone()); return new n(e, this.type, this.sourceSpan); }
}, Ia = class n extends j {
    parts;
    constructor(e, t) { super(e[e.length - 1].type, t), this.parts = e; }
    isEquivalent(e) { return e instanceof n && ke(this.parts, e.parts); }
    isConstant() { return !1; }
    visitExpression(e, t) { return e.visitCommaExpr(this, t); }
    clone() { return new n(this.parts.map(e => e.clone())); }
}, Wn = new ge(null, null, null), Op = new ge(null, Ve, null), oe = function (n) { return n[n.None = 0] = "None", n[n.Final = 1] = "Final", n[n.Private = 2] = "Private", n[n.Exported = 4] = "Exported", n[n.Static = 8] = "Static", n; }(oe || {}), wr = class {
    text;
    multiline;
    trailingNewline;
    constructor(e, t, s) { this.text = e, this.multiline = t, this.trailingNewline = s; }
    toString() { return this.multiline ? ` ${this.text} ` : this.text; }
}, Er = class extends wr {
    tags;
    constructor(e) { super("", !0, !0), this.tags = e; }
    toString() { return ud(this.tags); }
}, fn = class {
    modifiers;
    sourceSpan;
    leadingComments;
    constructor(e = oe.None, t = null, s) { this.modifiers = e, this.sourceSpan = t, this.leadingComments = s; }
    hasModifier(e) { return (this.modifiers & e) !== 0; }
    addLeadingComment(e) { this.leadingComments = this.leadingComments ?? [], this.leadingComments.push(e); }
}, ve = class n extends fn {
    name;
    value;
    type;
    constructor(e, t, s, r, i, o) { super(r, i, o), this.name = e, this.value = t, this.type = s || t && t.type || null; }
    isEquivalent(e) { return e instanceof n && this.name === e.name && (this.value ? !!e.value && this.value.isEquivalent(e.value) : !e.value); }
    visitStatement(e, t) { return e.visitDeclareVarStmt(this, t); }
}, dn = class n extends fn {
    name;
    params;
    statements;
    type;
    constructor(e, t, s, r, i, o, a) { super(i, o, a), this.name = e, this.params = t, this.statements = s, this.type = r || null; }
    isEquivalent(e) { return e instanceof n && ke(this.params, e.params) && ke(this.statements, e.statements); }
    visitStatement(e, t) { return e.visitDeclareFunctionStmt(this, t); }
}, Ge = class n extends fn {
    expr;
    constructor(e, t, s) { super(oe.None, t, s), this.expr = e; }
    isEquivalent(e) { return e instanceof n && this.expr.isEquivalent(e.expr); }
    visitStatement(e, t) { return e.visitExpressionStmt(this, t); }
}, ye = class n extends fn {
    value;
    constructor(e, t = null, s) { super(oe.None, t, s), this.value = e; }
    isEquivalent(e) { return e instanceof n && this.value.isEquivalent(e.value); }
    visitStatement(e, t) { return e.visitReturnStmt(this, t); }
}, Sr = class n extends fn {
    condition;
    trueCase;
    falseCase;
    constructor(e, t, s = [], r, i) { super(oe.None, r, i), this.condition = e, this.trueCase = t, this.falseCase = s; }
    isEquivalent(e) { return e instanceof n && this.condition.isEquivalent(e.condition) && ke(this.trueCase, e.trueCase) && ke(this.falseCase, e.falseCase); }
    visitStatement(e, t) { return e.visitIfStmt(this, t); }
}, sd = class {
    visitType(e, t) { return e; }
    visitExpression(e, t) { return e.type && e.type.visitType(this, t), e; }
    visitBuiltinType(e, t) { return this.visitType(e, t); }
    visitExpressionType(e, t) { return e.value.visitExpression(this, t), e.typeParams !== null && e.typeParams.forEach(s => this.visitType(s, t)), this.visitType(e, t); }
    visitArrayType(e, t) { return this.visitType(e, t); }
    visitMapType(e, t) { return this.visitType(e, t); }
    visitTransplantedType(e, t) { return e; }
    visitWrappedNodeExpr(e, t) { return e; }
    visitTypeofExpr(e, t) { return this.visitExpression(e, t); }
    visitReadVarExpr(e, t) { return this.visitExpression(e, t); }
    visitWriteVarExpr(e, t) { return e.value.visitExpression(this, t), this.visitExpression(e, t); }
    visitWriteKeyExpr(e, t) { return e.receiver.visitExpression(this, t), e.index.visitExpression(this, t), e.value.visitExpression(this, t), this.visitExpression(e, t); }
    visitWritePropExpr(e, t) { return e.receiver.visitExpression(this, t), e.value.visitExpression(this, t), this.visitExpression(e, t); }
    visitDynamicImportExpr(e, t) { return this.visitExpression(e, t); }
    visitInvokeFunctionExpr(e, t) { return e.fn.visitExpression(this, t), this.visitAllExpressions(e.args, t), this.visitExpression(e, t); }
    visitTaggedTemplateLiteralExpr(e, t) { return e.tag.visitExpression(this, t), e.template.visitExpression(this, t), this.visitExpression(e, t); }
    visitInstantiateExpr(e, t) { return e.classExpr.visitExpression(this, t), this.visitAllExpressions(e.args, t), this.visitExpression(e, t); }
    visitLiteralExpr(e, t) { return this.visitExpression(e, t); }
    visitLocalizedString(e, t) { return this.visitExpression(e, t); }
    visitExternalExpr(e, t) { return e.typeParams && e.typeParams.forEach(s => s.visitType(this, t)), this.visitExpression(e, t); }
    visitConditionalExpr(e, t) { return e.condition.visitExpression(this, t), e.trueCase.visitExpression(this, t), e.falseCase.visitExpression(this, t), this.visitExpression(e, t); }
    visitNotExpr(e, t) { return e.condition.visitExpression(this, t), this.visitExpression(e, t); }
    visitFunctionExpr(e, t) { return this.visitAllStatements(e.statements, t), this.visitExpression(e, t); }
    visitArrowFunctionExpr(e, t) { return Array.isArray(e.body) ? this.visitAllStatements(e.body, t) : e.body.visitExpression(this, t), this.visitExpression(e, t); }
    visitUnaryOperatorExpr(e, t) { return e.expr.visitExpression(this, t), this.visitExpression(e, t); }
    visitBinaryOperatorExpr(e, t) { return e.lhs.visitExpression(this, t), e.rhs.visitExpression(this, t), this.visitExpression(e, t); }
    visitReadPropExpr(e, t) { return e.receiver.visitExpression(this, t), this.visitExpression(e, t); }
    visitReadKeyExpr(e, t) { return e.receiver.visitExpression(this, t), e.index.visitExpression(this, t), this.visitExpression(e, t); }
    visitLiteralArrayExpr(e, t) { return this.visitAllExpressions(e.entries, t), this.visitExpression(e, t); }
    visitLiteralMapExpr(e, t) { return e.entries.forEach(s => s.value.visitExpression(this, t)), this.visitExpression(e, t); }
    visitCommaExpr(e, t) { return this.visitAllExpressions(e.parts, t), this.visitExpression(e, t); }
    visitTemplateLiteralExpr(e, t) { return this.visitAllExpressions(e.elements, t), this.visitAllExpressions(e.expressions, t), this.visitExpression(e, t); }
    visitTemplateLiteralElementExpr(e, t) { return this.visitExpression(e, t); }
    visitAllExpressions(e, t) { e.forEach(s => s.visitExpression(this, t)); }
    visitDeclareVarStmt(e, t) { return e.value && e.value.visitExpression(this, t), e.type && e.type.visitType(this, t), e; }
    visitDeclareFunctionStmt(e, t) { return this.visitAllStatements(e.statements, t), e.type && e.type.visitType(this, t), e; }
    visitExpressionStmt(e, t) { return e.expr.visitExpression(this, t), e; }
    visitReturnStmt(e, t) { return e.value.visitExpression(this, t), e; }
    visitIfStmt(e, t) { return e.condition.visitExpression(this, t), this.visitAllStatements(e.trueCase, t), this.visitAllStatements(e.falseCase, t), e; }
    visitAllStatements(e, t) { e.forEach(s => s.visitStatement(this, t)); }
};
function rd(n, e = !1, t = !0) { return new wr(n, e, t); }
function Vp(n = []) { return new Er(n); }
function N(n, e, t) { return new ze(n, e, t); }
function y(n, e = null, t) { return new jt(n, null, e, t); }
function id(n, e, t) { return n != null ? me(y(n, e, null), t) : null; }
function me(n, e, t) { return new He(n, e, t); }
function od(n, e) { return new _i(n, e); }
function Vs(n) { return new Vn(n); }
function B(n, e, t) { return new at(n, e, t); }
function ue(n, e = null) { return new gt(n.map(t => new Un(t.key, t.value, t.quoted)), e, null); }
function ad(n, e, t, s) { return new hn(n, e, t, s); }
function qp(n, e) { return new ys(n, e); }
function zt(n, e, t, s, r) { return new Ht(n, e, t, s, r); }
function se(n, e, t, s) { return new pn(n, e, t, s); }
function ri(n, e, t, s, r) { return new Sr(n, e, t, s, r); }
function Hp(n, e, t, s) { return new mr(n, e, t, s); }
function d(n, e, t) { return new ge(n, e, t); }
function Up(n, e, t, s, r) { return new vr(n, e, t, s, r); }
function ld(n) { return n instanceof ge && n.value === null; }
function Xu(n) { let e = ""; if (n.tagName && (e += ` @${n.tagName}`), n.text) {
    if (n.text.match(/\/\*|\*\//))
        throw new Error("JSDoc text cannot contain \"/*\" and \"*/\"");
    e += " " + n.text.replace(/@/g, "\\@");
} return e; }
function ud(n) {
    if (n.length === 0)
        return "";
    if (n.length === 1 && n[0].tagName && !n[0].text)
        return `*${Xu(n[0])} `;
    let e = `*
`;
    for (let t of n)
        e += " *", e += Xu(t).replace(/\n/g, `
 * `), e += `
`;
    return e += " ", e;
}
var FC = Object.freeze({ __proto__: null, ArrayType: _a, ArrowFunctionExpr: pn, BOOL_TYPE: Rp, get BinaryOperator() { return b; }, BinaryOperatorExpr: W, BuiltinType: dt, get BuiltinTypeName() { return Mt; }, CommaExpr: Ia, ConditionalExpr: kt, DYNAMIC_TYPE: Be, DeclareFunctionStmt: dn, DeclareVarStmt: ve, DynamicImportExpr: Hn, Expression: j, ExpressionStatement: Ge, ExpressionType: He, ExternalExpr: jt, ExternalReference: ka, FUNCTION_TYPE: Jf, FnParam: Y, FunctionExpr: Ht, INFERRED_TYPE: Ve, INT_TYPE: Zf, IfStmt: Sr, InstantiateExpr: Ss, InvokeFunctionExpr: Ie, JSDocComment: Er, LeadingComment: wr, LiteralArrayExpr: at, LiteralExpr: ge, LiteralMapEntry: Un, LiteralMapExpr: gt, LiteralPiece: ln, LocalizedString: vr, MapType: Ta, NONE_TYPE: mt, NULL_EXPR: Wn, NUMBER_TYPE: Oo, NotExpr: ys, PlaceholderPiece: Pn, ReadKeyExpr: It, ReadPropExpr: Me, ReadVarExpr: ze, RecursiveAstVisitor: sd, ReturnStatement: ye, STRING_TYPE: Vo, Statement: fn, get StmtModifier() { return oe; }, TYPED_NULL_EXPR: Op, TaggedTemplateLiteralExpr: mr, TemplateLiteralElementExpr: gr, TemplateLiteralExpr: xs, TransplantedType: _i, Type: cn, get TypeModifier() { return du; }, TypeofExpr: Vn, get UnaryOperator() { return ws; }, UnaryOperatorExpr: hn, WrappedNodeExpr: V, WriteKeyExpr: Es, WritePropExpr: qn, WriteVarExpr: dr, areAllEquivalent: ke, arrowFn: se, expressionType: me, fn: zt, ifStmt: ri, importExpr: y, importType: id, isNull: ld, jsDocComment: Vp, leadingComment: rd, literal: d, literalArr: B, literalMap: ue, localizedString: Up, not: qp, nullSafeIsEquivalent: Fp, taggedTemplate: Hp, transplantedType: od, typeofExpr: Vs, unary: ad, variable: N }), cd = "_c", Yu = N("<unknown>"), pd = {}, hd = 50, Ti = class n extends j {
    resolved;
    original;
    shared = !1;
    constructor(e) { super(e.type), this.resolved = e, this.original = e; }
    visitExpression(e, t) { return t === pd ? this.original.visitExpression(e, t) : this.resolved.visitExpression(e, t); }
    isEquivalent(e) { return e instanceof n && this.resolved.isEquivalent(e.resolved); }
    isConstant() { return !0; }
    clone() { throw new Error("Not supported."); }
    fixup(e) { this.resolved = e, this.shared = !0; }
}, bi = class {
    isClosureCompilerEnabled;
    statements = [];
    literals = new Map;
    literalFactories = new Map;
    sharedConstants = new Map;
    _claimedNames = new Map;
    nextNameIndex = 0;
    constructor(e = !1) { this.isClosureCompilerEnabled = e; }
    getConstLiteral(e, t) { if (e instanceof ge && !Qu(e) || e instanceof Ti)
        return e; let s = ds.INSTANCE.keyOf(e), r = this.literals.get(s), i = !1; if (r || (r = new Ti(e), this.literals.set(s, r), i = !0), !i && !r.shared || i && t) {
        let o = this.freshName(), a, l;
        this.isClosureCompilerEnabled && Qu(e) ? (a = N(o).set(new Ht([], [new ye(e)])), l = N(o).callFn([])) : (a = N(o).set(e), l = N(o)), this.statements.push(a.toDeclStmt(Ve, oe.Final)), r.fixup(l);
    } return r; }
    getSharedConstant(e, t) { let s = e.keyOf(t); if (!this.sharedConstants.has(s)) {
        let r = this.freshName();
        this.sharedConstants.set(s, N(r)), this.statements.push(e.toSharedConstantDeclaration(r, t));
    } return this.sharedConstants.get(s); }
    getLiteralFactory(e) { if (e instanceof at) {
        let t = e.entries.map(r => r.isConstant() ? r : Yu), s = ds.INSTANCE.keyOf(B(t));
        return this._getLiteralFactory(s, e.entries, r => B(r));
    }
    else {
        let t = ue(e.entries.map(r => ({ key: r.key, value: r.value.isConstant() ? r.value : Yu, quoted: r.quoted }))), s = ds.INSTANCE.keyOf(t);
        return this._getLiteralFactory(s, e.entries.map(r => r.value), r => ue(r.map((i, o) => ({ key: e.entries[o].key, value: i, quoted: e.entries[o].quoted }))));
    } }
    getSharedFunctionReference(e, t, s = !0) { let r = e instanceof pn; for (let o of this.statements)
        if (r && o instanceof ve && o.value?.isEquivalent(e) || !r && o instanceof dn && e instanceof Ht && e.isEquivalent(o))
            return N(o.name); let i = s ? this.uniqueName(t) : t; return this.statements.push(e instanceof Ht ? e.toDeclStmt(i, oe.Final) : new ve(i, e, Ve, oe.Final, e.sourceSpan)), N(i); }
    _getLiteralFactory(e, t, s) { let r = this.literalFactories.get(e), i = t.filter(o => !o.isConstant()); if (!r) {
        let o = t.map((p, f) => p.isConstant() ? this.getConstLiteral(p, !0) : N(`a${f}`)), a = o.filter(fd).map(p => new Y(p.name, Be)), l = se(a, s(o), Ve), u = this.freshName();
        this.statements.push(N(u).set(l).toDeclStmt(Ve, oe.Final)), r = N(u), this.literalFactories.set(e, r);
    } return { literalFactory: r, literalFactoryArguments: i }; }
    uniqueName(e, t = !0) { let s = this._claimedNames.get(e) ?? 0, r = s === 0 && !t ? `${e}` : `${e}${s}`; return this._claimedNames.set(e, s + 1), r; }
    freshName() { return this.uniqueName(cd); }
}, ds = class n {
    static INSTANCE = new n;
    keyOf(e) { if (e instanceof ge && typeof e.value == "string")
        return `"${e.value}"`; if (e instanceof ge)
        return String(e.value); if (e instanceof at) {
        let t = [];
        for (let s of e.entries)
            t.push(this.keyOf(s));
        return `[${t.join(",")}]`;
    }
    else if (e instanceof gt) {
        let t = [];
        for (let s of e.entries) {
            let r = s.key;
            s.quoted && (r = `"${r}"`), t.push(r + ":" + this.keyOf(s.value));
        }
        return `{${t.join(",")}}`;
    }
    else {
        if (e instanceof jt)
            return `import("${e.value.moduleName}", ${e.value.name})`;
        if (e instanceof ze)
            return `read(${e.name})`;
        if (e instanceof Vn)
            return `typeof(${this.keyOf(e.expr)})`;
        throw new Error(`${this.constructor.name} does not handle expressions of type ${e.constructor.name}`);
    } }
};
function fd(n) { return n instanceof ze; }
function Qu(n) { return n instanceof ge && typeof n.value == "string" && n.value.length >= hd; }
var m = "@angular/core", h = (() => { class n {
    static NEW_METHOD = "factory";
    static TRANSFORM_METHOD = "transform";
    static PATCH_DEPS = "patchedDeps";
    static core = { name: null, moduleName: m };
    static namespaceHTML = { name: "\u0275\u0275namespaceHTML", moduleName: m };
    static namespaceMathML = { name: "\u0275\u0275namespaceMathML", moduleName: m };
    static namespaceSVG = { name: "\u0275\u0275namespaceSVG", moduleName: m };
    static element = { name: "\u0275\u0275element", moduleName: m };
    static elementStart = { name: "\u0275\u0275elementStart", moduleName: m };
    static elementEnd = { name: "\u0275\u0275elementEnd", moduleName: m };
    static advance = { name: "\u0275\u0275advance", moduleName: m };
    static syntheticHostProperty = { name: "\u0275\u0275syntheticHostProperty", moduleName: m };
    static syntheticHostListener = { name: "\u0275\u0275syntheticHostListener", moduleName: m };
    static attribute = { name: "\u0275\u0275attribute", moduleName: m };
    static attributeInterpolate1 = { name: "\u0275\u0275attributeInterpolate1", moduleName: m };
    static attributeInterpolate2 = { name: "\u0275\u0275attributeInterpolate2", moduleName: m };
    static attributeInterpolate3 = { name: "\u0275\u0275attributeInterpolate3", moduleName: m };
    static attributeInterpolate4 = { name: "\u0275\u0275attributeInterpolate4", moduleName: m };
    static attributeInterpolate5 = { name: "\u0275\u0275attributeInterpolate5", moduleName: m };
    static attributeInterpolate6 = { name: "\u0275\u0275attributeInterpolate6", moduleName: m };
    static attributeInterpolate7 = { name: "\u0275\u0275attributeInterpolate7", moduleName: m };
    static attributeInterpolate8 = { name: "\u0275\u0275attributeInterpolate8", moduleName: m };
    static attributeInterpolateV = { name: "\u0275\u0275attributeInterpolateV", moduleName: m };
    static classProp = { name: "\u0275\u0275classProp", moduleName: m };
    static elementContainerStart = { name: "\u0275\u0275elementContainerStart", moduleName: m };
    static elementContainerEnd = { name: "\u0275\u0275elementContainerEnd", moduleName: m };
    static elementContainer = { name: "\u0275\u0275elementContainer", moduleName: m };
    static styleMap = { name: "\u0275\u0275styleMap", moduleName: m };
    static styleMapInterpolate1 = { name: "\u0275\u0275styleMapInterpolate1", moduleName: m };
    static styleMapInterpolate2 = { name: "\u0275\u0275styleMapInterpolate2", moduleName: m };
    static styleMapInterpolate3 = { name: "\u0275\u0275styleMapInterpolate3", moduleName: m };
    static styleMapInterpolate4 = { name: "\u0275\u0275styleMapInterpolate4", moduleName: m };
    static styleMapInterpolate5 = { name: "\u0275\u0275styleMapInterpolate5", moduleName: m };
    static styleMapInterpolate6 = { name: "\u0275\u0275styleMapInterpolate6", moduleName: m };
    static styleMapInterpolate7 = { name: "\u0275\u0275styleMapInterpolate7", moduleName: m };
    static styleMapInterpolate8 = { name: "\u0275\u0275styleMapInterpolate8", moduleName: m };
    static styleMapInterpolateV = { name: "\u0275\u0275styleMapInterpolateV", moduleName: m };
    static classMap = { name: "\u0275\u0275classMap", moduleName: m };
    static classMapInterpolate1 = { name: "\u0275\u0275classMapInterpolate1", moduleName: m };
    static classMapInterpolate2 = { name: "\u0275\u0275classMapInterpolate2", moduleName: m };
    static classMapInterpolate3 = { name: "\u0275\u0275classMapInterpolate3", moduleName: m };
    static classMapInterpolate4 = { name: "\u0275\u0275classMapInterpolate4", moduleName: m };
    static classMapInterpolate5 = { name: "\u0275\u0275classMapInterpolate5", moduleName: m };
    static classMapInterpolate6 = { name: "\u0275\u0275classMapInterpolate6", moduleName: m };
    static classMapInterpolate7 = { name: "\u0275\u0275classMapInterpolate7", moduleName: m };
    static classMapInterpolate8 = { name: "\u0275\u0275classMapInterpolate8", moduleName: m };
    static classMapInterpolateV = { name: "\u0275\u0275classMapInterpolateV", moduleName: m };
    static styleProp = { name: "\u0275\u0275styleProp", moduleName: m };
    static stylePropInterpolate1 = { name: "\u0275\u0275stylePropInterpolate1", moduleName: m };
    static stylePropInterpolate2 = { name: "\u0275\u0275stylePropInterpolate2", moduleName: m };
    static stylePropInterpolate3 = { name: "\u0275\u0275stylePropInterpolate3", moduleName: m };
    static stylePropInterpolate4 = { name: "\u0275\u0275stylePropInterpolate4", moduleName: m };
    static stylePropInterpolate5 = { name: "\u0275\u0275stylePropInterpolate5", moduleName: m };
    static stylePropInterpolate6 = { name: "\u0275\u0275stylePropInterpolate6", moduleName: m };
    static stylePropInterpolate7 = { name: "\u0275\u0275stylePropInterpolate7", moduleName: m };
    static stylePropInterpolate8 = { name: "\u0275\u0275stylePropInterpolate8", moduleName: m };
    static stylePropInterpolateV = { name: "\u0275\u0275stylePropInterpolateV", moduleName: m };
    static nextContext = { name: "\u0275\u0275nextContext", moduleName: m };
    static resetView = { name: "\u0275\u0275resetView", moduleName: m };
    static templateCreate = { name: "\u0275\u0275template", moduleName: m };
    static defer = { name: "\u0275\u0275defer", moduleName: m };
    static deferWhen = { name: "\u0275\u0275deferWhen", moduleName: m };
    static deferOnIdle = { name: "\u0275\u0275deferOnIdle", moduleName: m };
    static deferOnImmediate = { name: "\u0275\u0275deferOnImmediate", moduleName: m };
    static deferOnTimer = { name: "\u0275\u0275deferOnTimer", moduleName: m };
    static deferOnHover = { name: "\u0275\u0275deferOnHover", moduleName: m };
    static deferOnInteraction = { name: "\u0275\u0275deferOnInteraction", moduleName: m };
    static deferOnViewport = { name: "\u0275\u0275deferOnViewport", moduleName: m };
    static deferPrefetchWhen = { name: "\u0275\u0275deferPrefetchWhen", moduleName: m };
    static deferPrefetchOnIdle = { name: "\u0275\u0275deferPrefetchOnIdle", moduleName: m };
    static deferPrefetchOnImmediate = { name: "\u0275\u0275deferPrefetchOnImmediate", moduleName: m };
    static deferPrefetchOnTimer = { name: "\u0275\u0275deferPrefetchOnTimer", moduleName: m };
    static deferPrefetchOnHover = { name: "\u0275\u0275deferPrefetchOnHover", moduleName: m };
    static deferPrefetchOnInteraction = { name: "\u0275\u0275deferPrefetchOnInteraction", moduleName: m };
    static deferPrefetchOnViewport = { name: "\u0275\u0275deferPrefetchOnViewport", moduleName: m };
    static deferHydrateWhen = { name: "\u0275\u0275deferHydrateWhen", moduleName: m };
    static deferHydrateNever = { name: "\u0275\u0275deferHydrateNever", moduleName: m };
    static deferHydrateOnIdle = { name: "\u0275\u0275deferHydrateOnIdle", moduleName: m };
    static deferHydrateOnImmediate = { name: "\u0275\u0275deferHydrateOnImmediate", moduleName: m };
    static deferHydrateOnTimer = { name: "\u0275\u0275deferHydrateOnTimer", moduleName: m };
    static deferHydrateOnHover = { name: "\u0275\u0275deferHydrateOnHover", moduleName: m };
    static deferHydrateOnInteraction = { name: "\u0275\u0275deferHydrateOnInteraction", moduleName: m };
    static deferHydrateOnViewport = { name: "\u0275\u0275deferHydrateOnViewport", moduleName: m };
    static deferEnableTimerScheduling = { name: "\u0275\u0275deferEnableTimerScheduling", moduleName: m };
    static conditional = { name: "\u0275\u0275conditional", moduleName: m };
    static repeater = { name: "\u0275\u0275repeater", moduleName: m };
    static repeaterCreate = { name: "\u0275\u0275repeaterCreate", moduleName: m };
    static repeaterTrackByIndex = { name: "\u0275\u0275repeaterTrackByIndex", moduleName: m };
    static repeaterTrackByIdentity = { name: "\u0275\u0275repeaterTrackByIdentity", moduleName: m };
    static componentInstance = { name: "\u0275\u0275componentInstance", moduleName: m };
    static text = { name: "\u0275\u0275text", moduleName: m };
    static enableBindings = { name: "\u0275\u0275enableBindings", moduleName: m };
    static disableBindings = { name: "\u0275\u0275disableBindings", moduleName: m };
    static getCurrentView = { name: "\u0275\u0275getCurrentView", moduleName: m };
    static textInterpolate = { name: "\u0275\u0275textInterpolate", moduleName: m };
    static textInterpolate1 = { name: "\u0275\u0275textInterpolate1", moduleName: m };
    static textInterpolate2 = { name: "\u0275\u0275textInterpolate2", moduleName: m };
    static textInterpolate3 = { name: "\u0275\u0275textInterpolate3", moduleName: m };
    static textInterpolate4 = { name: "\u0275\u0275textInterpolate4", moduleName: m };
    static textInterpolate5 = { name: "\u0275\u0275textInterpolate5", moduleName: m };
    static textInterpolate6 = { name: "\u0275\u0275textInterpolate6", moduleName: m };
    static textInterpolate7 = { name: "\u0275\u0275textInterpolate7", moduleName: m };
    static textInterpolate8 = { name: "\u0275\u0275textInterpolate8", moduleName: m };
    static textInterpolateV = { name: "\u0275\u0275textInterpolateV", moduleName: m };
    static restoreView = { name: "\u0275\u0275restoreView", moduleName: m };
    static pureFunction0 = { name: "\u0275\u0275pureFunction0", moduleName: m };
    static pureFunction1 = { name: "\u0275\u0275pureFunction1", moduleName: m };
    static pureFunction2 = { name: "\u0275\u0275pureFunction2", moduleName: m };
    static pureFunction3 = { name: "\u0275\u0275pureFunction3", moduleName: m };
    static pureFunction4 = { name: "\u0275\u0275pureFunction4", moduleName: m };
    static pureFunction5 = { name: "\u0275\u0275pureFunction5", moduleName: m };
    static pureFunction6 = { name: "\u0275\u0275pureFunction6", moduleName: m };
    static pureFunction7 = { name: "\u0275\u0275pureFunction7", moduleName: m };
    static pureFunction8 = { name: "\u0275\u0275pureFunction8", moduleName: m };
    static pureFunctionV = { name: "\u0275\u0275pureFunctionV", moduleName: m };
    static pipeBind1 = { name: "\u0275\u0275pipeBind1", moduleName: m };
    static pipeBind2 = { name: "\u0275\u0275pipeBind2", moduleName: m };
    static pipeBind3 = { name: "\u0275\u0275pipeBind3", moduleName: m };
    static pipeBind4 = { name: "\u0275\u0275pipeBind4", moduleName: m };
    static pipeBindV = { name: "\u0275\u0275pipeBindV", moduleName: m };
    static hostProperty = { name: "\u0275\u0275hostProperty", moduleName: m };
    static property = { name: "\u0275\u0275property", moduleName: m };
    static propertyInterpolate = { name: "\u0275\u0275propertyInterpolate", moduleName: m };
    static propertyInterpolate1 = { name: "\u0275\u0275propertyInterpolate1", moduleName: m };
    static propertyInterpolate2 = { name: "\u0275\u0275propertyInterpolate2", moduleName: m };
    static propertyInterpolate3 = { name: "\u0275\u0275propertyInterpolate3", moduleName: m };
    static propertyInterpolate4 = { name: "\u0275\u0275propertyInterpolate4", moduleName: m };
    static propertyInterpolate5 = { name: "\u0275\u0275propertyInterpolate5", moduleName: m };
    static propertyInterpolate6 = { name: "\u0275\u0275propertyInterpolate6", moduleName: m };
    static propertyInterpolate7 = { name: "\u0275\u0275propertyInterpolate7", moduleName: m };
    static propertyInterpolate8 = { name: "\u0275\u0275propertyInterpolate8", moduleName: m };
    static propertyInterpolateV = { name: "\u0275\u0275propertyInterpolateV", moduleName: m };
    static i18n = { name: "\u0275\u0275i18n", moduleName: m };
    static i18nAttributes = { name: "\u0275\u0275i18nAttributes", moduleName: m };
    static i18nExp = { name: "\u0275\u0275i18nExp", moduleName: m };
    static i18nStart = { name: "\u0275\u0275i18nStart", moduleName: m };
    static i18nEnd = { name: "\u0275\u0275i18nEnd", moduleName: m };
    static i18nApply = { name: "\u0275\u0275i18nApply", moduleName: m };
    static i18nPostprocess = { name: "\u0275\u0275i18nPostprocess", moduleName: m };
    static pipe = { name: "\u0275\u0275pipe", moduleName: m };
    static projection = { name: "\u0275\u0275projection", moduleName: m };
    static projectionDef = { name: "\u0275\u0275projectionDef", moduleName: m };
    static reference = { name: "\u0275\u0275reference", moduleName: m };
    static inject = { name: "\u0275\u0275inject", moduleName: m };
    static injectAttribute = { name: "\u0275\u0275injectAttribute", moduleName: m };
    static directiveInject = { name: "\u0275\u0275directiveInject", moduleName: m };
    static invalidFactory = { name: "\u0275\u0275invalidFactory", moduleName: m };
    static invalidFactoryDep = { name: "\u0275\u0275invalidFactoryDep", moduleName: m };
    static templateRefExtractor = { name: "\u0275\u0275templateRefExtractor", moduleName: m };
    static forwardRef = { name: "forwardRef", moduleName: m };
    static resolveForwardRef = { name: "resolveForwardRef", moduleName: m };
    static replaceMetadata = { name: "\u0275\u0275replaceMetadata", moduleName: m };
    static getReplaceMetadataURL = { name: "\u0275\u0275getReplaceMetadataURL", moduleName: m };
    static ɵɵdefineInjectable = { name: "\u0275\u0275defineInjectable", moduleName: m };
    static declareInjectable = { name: "\u0275\u0275ngDeclareInjectable", moduleName: m };
    static InjectableDeclaration = { name: "\u0275\u0275InjectableDeclaration", moduleName: m };
    static resolveWindow = { name: "\u0275\u0275resolveWindow", moduleName: m };
    static resolveDocument = { name: "\u0275\u0275resolveDocument", moduleName: m };
    static resolveBody = { name: "\u0275\u0275resolveBody", moduleName: m };
    static getComponentDepsFactory = { name: "\u0275\u0275getComponentDepsFactory", moduleName: m };
    static defineComponent = { name: "\u0275\u0275defineComponent", moduleName: m };
    static declareComponent = { name: "\u0275\u0275ngDeclareComponent", moduleName: m };
    static setComponentScope = { name: "\u0275\u0275setComponentScope", moduleName: m };
    static ChangeDetectionStrategy = { name: "ChangeDetectionStrategy", moduleName: m };
    static ViewEncapsulation = { name: "ViewEncapsulation", moduleName: m };
    static ComponentDeclaration = { name: "\u0275\u0275ComponentDeclaration", moduleName: m };
    static FactoryDeclaration = { name: "\u0275\u0275FactoryDeclaration", moduleName: m };
    static declareFactory = { name: "\u0275\u0275ngDeclareFactory", moduleName: m };
    static FactoryTarget = { name: "\u0275\u0275FactoryTarget", moduleName: m };
    static defineDirective = { name: "\u0275\u0275defineDirective", moduleName: m };
    static declareDirective = { name: "\u0275\u0275ngDeclareDirective", moduleName: m };
    static DirectiveDeclaration = { name: "\u0275\u0275DirectiveDeclaration", moduleName: m };
    static InjectorDef = { name: "\u0275\u0275InjectorDef", moduleName: m };
    static InjectorDeclaration = { name: "\u0275\u0275InjectorDeclaration", moduleName: m };
    static defineInjector = { name: "\u0275\u0275defineInjector", moduleName: m };
    static declareInjector = { name: "\u0275\u0275ngDeclareInjector", moduleName: m };
    static NgModuleDeclaration = { name: "\u0275\u0275NgModuleDeclaration", moduleName: m };
    static ModuleWithProviders = { name: "ModuleWithProviders", moduleName: m };
    static defineNgModule = { name: "\u0275\u0275defineNgModule", moduleName: m };
    static declareNgModule = { name: "\u0275\u0275ngDeclareNgModule", moduleName: m };
    static setNgModuleScope = { name: "\u0275\u0275setNgModuleScope", moduleName: m };
    static registerNgModuleType = { name: "\u0275\u0275registerNgModuleType", moduleName: m };
    static PipeDeclaration = { name: "\u0275\u0275PipeDeclaration", moduleName: m };
    static definePipe = { name: "\u0275\u0275definePipe", moduleName: m };
    static declarePipe = { name: "\u0275\u0275ngDeclarePipe", moduleName: m };
    static declareClassMetadata = { name: "\u0275\u0275ngDeclareClassMetadata", moduleName: m };
    static declareClassMetadataAsync = { name: "\u0275\u0275ngDeclareClassMetadataAsync", moduleName: m };
    static setClassMetadata = { name: "\u0275setClassMetadata", moduleName: m };
    static setClassMetadataAsync = { name: "\u0275setClassMetadataAsync", moduleName: m };
    static setClassDebugInfo = { name: "\u0275setClassDebugInfo", moduleName: m };
    static queryRefresh = { name: "\u0275\u0275queryRefresh", moduleName: m };
    static viewQuery = { name: "\u0275\u0275viewQuery", moduleName: m };
    static loadQuery = { name: "\u0275\u0275loadQuery", moduleName: m };
    static contentQuery = { name: "\u0275\u0275contentQuery", moduleName: m };
    static viewQuerySignal = { name: "\u0275\u0275viewQuerySignal", moduleName: m };
    static contentQuerySignal = { name: "\u0275\u0275contentQuerySignal", moduleName: m };
    static queryAdvance = { name: "\u0275\u0275queryAdvance", moduleName: m };
    static twoWayProperty = { name: "\u0275\u0275twoWayProperty", moduleName: m };
    static twoWayBindingSet = { name: "\u0275\u0275twoWayBindingSet", moduleName: m };
    static twoWayListener = { name: "\u0275\u0275twoWayListener", moduleName: m };
    static declareLet = { name: "\u0275\u0275declareLet", moduleName: m };
    static storeLet = { name: "\u0275\u0275storeLet", moduleName: m };
    static readContextLet = { name: "\u0275\u0275readContextLet", moduleName: m };
    static attachSourceLocations = { name: "\u0275\u0275attachSourceLocations", moduleName: m };
    static NgOnChangesFeature = { name: "\u0275\u0275NgOnChangesFeature", moduleName: m };
    static InheritDefinitionFeature = { name: "\u0275\u0275InheritDefinitionFeature", moduleName: m };
    static CopyDefinitionFeature = { name: "\u0275\u0275CopyDefinitionFeature", moduleName: m };
    static ProvidersFeature = { name: "\u0275\u0275ProvidersFeature", moduleName: m };
    static HostDirectivesFeature = { name: "\u0275\u0275HostDirectivesFeature", moduleName: m };
    static ExternalStylesFeature = { name: "\u0275\u0275ExternalStylesFeature", moduleName: m };
    static listener = { name: "\u0275\u0275listener", moduleName: m };
    static getInheritedFactory = { name: "\u0275\u0275getInheritedFactory", moduleName: m };
    static sanitizeHtml = { name: "\u0275\u0275sanitizeHtml", moduleName: m };
    static sanitizeStyle = { name: "\u0275\u0275sanitizeStyle", moduleName: m };
    static sanitizeResourceUrl = { name: "\u0275\u0275sanitizeResourceUrl", moduleName: m };
    static sanitizeScript = { name: "\u0275\u0275sanitizeScript", moduleName: m };
    static sanitizeUrl = { name: "\u0275\u0275sanitizeUrl", moduleName: m };
    static sanitizeUrlOrResourceUrl = { name: "\u0275\u0275sanitizeUrlOrResourceUrl", moduleName: m };
    static trustConstantHtml = { name: "\u0275\u0275trustConstantHtml", moduleName: m };
    static trustConstantResourceUrl = { name: "\u0275\u0275trustConstantResourceUrl", moduleName: m };
    static validateIframeAttribute = { name: "\u0275\u0275validateIframeAttribute", moduleName: m };
    static InputSignalBrandWriteType = { name: "\u0275INPUT_SIGNAL_BRAND_WRITE_TYPE", moduleName: m };
    static UnwrapDirectiveSignalInputs = { name: "\u0275UnwrapDirectiveSignalInputs", moduleName: m };
    static unwrapWritableSignal = { name: "\u0275unwrapWritableSignal", moduleName: m };
} return n; })(), dd = /-+([a-z0-9])/g;
function md(n) { return n.replace(dd, (...e) => e[1].toUpperCase()); }
function gd(n, e) { return Wp(n, ":", e); }
function vd(n, e) { return Wp(n, ".", e); }
function Wp(n, e, t) { let s = n.indexOf(e); return s == -1 ? t : [n.slice(0, s).trim(), n.slice(s + 1).trim()]; }
function wd(n) { return n === void 0 ? null : n; }
function $C(n) { return n.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1"); }
function Ed(n) { let e = []; for (let t = 0; t < n.length; t++) {
    let s = n.charCodeAt(t);
    if (s >= 55296 && s <= 56319 && n.length > t + 1) {
        let r = n.charCodeAt(t + 1);
        r >= 56320 && r <= 57343 && (t++, s = (s - 55296 << 10) + r - 56320 + 65536);
    }
    s <= 127 ? e.push(s) : s <= 2047 ? e.push(s >> 6 & 31 | 192, s & 63 | 128) : s <= 65535 ? e.push(s >> 12 | 224, s >> 6 & 63 | 128, s & 63 | 128) : s <= 2097151 && e.push(s >> 18 & 7 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, s & 63 | 128);
} return e; }
function jp(n) {
    if (typeof n == "string")
        return n;
    if (Array.isArray(n))
        return `[${n.map(jp).join(", ")}]`;
    if (n == null)
        return "" + n;
    let e = n.overriddenName || n.name;
    if (e)
        return `${e}`;
    if (!n.toString)
        return "object";
    let t = n.toString();
    if (t == null)
        return "" + t;
    let s = t.indexOf(`
`);
    return s >= 0 ? t.slice(0, s) : t;
}
var Na = class {
    full;
    major;
    minor;
    patch;
    constructor(e) { this.full = e; let t = e.split("."); this.major = t[0], this.minor = t[1], this.patch = t.slice(2).join("."); }
}, Si = globalThis, Sd = /^([1-9]|1[0-8])\./;
function zp(n) { return n.startsWith("0.") ? !0 : !Sd.test(n); }
var xd = 3, yd = "# sourceMappingURL=data:application/json;base64,", Da = class {
    file;
    sourcesContent = new Map;
    lines = [];
    lastCol0 = 0;
    hasMappings = !1;
    constructor(e = null) { this.file = e; }
    addSource(e, t = null) { return this.sourcesContent.has(e) || this.sourcesContent.set(e, t), this; }
    addLine() { return this.lines.push([]), this.lastCol0 = 0, this; }
    addMapping(e, t, s, r) { if (!this.currentLine)
        throw new Error("A line must be added before mappings can be added"); if (t != null && !this.sourcesContent.has(t))
        throw new Error(`Unknown source file "${t}"`); if (e == null)
        throw new Error("The column in the generated code must be provided"); if (e < this.lastCol0)
        throw new Error("Mapping should be added in output order"); if (t && (s == null || r == null))
        throw new Error("The source location must be provided when a source url is provided"); return this.hasMappings = !0, this.lastCol0 = e, this.currentLine.push({ col0: e, sourceUrl: t, sourceLine0: s, sourceCol0: r }), this; }
    get currentLine() { return this.lines.slice(-1)[0]; }
    toJSON() { if (!this.hasMappings)
        return null; let e = new Map, t = [], s = []; Array.from(this.sourcesContent.keys()).forEach((u, p) => { e.set(u, p), t.push(u), s.push(this.sourcesContent.get(u) || null); }); let r = "", i = 0, o = 0, a = 0, l = 0; return this.lines.forEach(u => { i = 0, r += u.map(p => { let f = ui(p.col0 - i); return i = p.col0, p.sourceUrl != null && (f += ui(e.get(p.sourceUrl) - o), o = e.get(p.sourceUrl), f += ui(p.sourceLine0 - a), a = p.sourceLine0, f += ui(p.sourceCol0 - l), l = p.sourceCol0), f; }).join(","), r += ";"; }), r = r.slice(0, -1), { file: this.file || "", version: xd, sourceRoot: "", sources: t, sourcesContent: s, mappings: r }; }
    toJsComment() { return this.hasMappings ? "//" + yd + Cd(JSON.stringify(this, null, 0)) : ""; }
};
function Cd(n) { let e = "", t = Ed(n); for (let s = 0; s < t.length;) {
    let r = t[s++], i = s < t.length ? t[s++] : null, o = s < t.length ? t[s++] : null;
    e += er(r >> 2), e += er((r & 3) << 4 | (i === null ? 0 : i >> 4)), e += i === null ? "=" : er((i & 15) << 2 | (o === null ? 0 : o >> 6)), e += i === null || o === null ? "=" : er(o & 63);
} return e; }
function ui(n) { n = n < 0 ? (-n << 1) + 1 : n << 1; let e = ""; do {
    let t = n & 31;
    n = n >> 5, n > 0 && (t = t | 32), e += er(t);
} while (n > 0); return e; }
var Ad = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function er(n) { if (n < 0 || n >= 64)
    throw new Error("Can only encode value in the range [0, 63]"); return Ad[n]; }
var _d = /'|\\|\n|\r|\$/g, Td = /^[$A-Z_][0-9A-Z_$]*$/i, Pa = "  ", ki = class {
    indent;
    partsLength = 0;
    parts = [];
    srcSpans = [];
    constructor(e) { this.indent = e; }
}, La = class n {
    _indent;
    static createRoot() { return new n(0); }
    _lines;
    constructor(e) { this._indent = e, this._lines = [new ki(e)]; }
    get _currentLine() { return this._lines[this._lines.length - 1]; }
    println(e, t = "") { this.print(e || null, t, !0); }
    lineIsEmpty() { return this._currentLine.parts.length === 0; }
    lineLength() { return this._currentLine.indent * Pa.length + this._currentLine.partsLength; }
    print(e, t, s = !1) { t.length > 0 && (this._currentLine.parts.push(t), this._currentLine.partsLength += t.length, this._currentLine.srcSpans.push(e && e.sourceSpan || null)), s && this._lines.push(new ki(this._indent)); }
    removeEmptyLastLine() { this.lineIsEmpty() && this._lines.pop(); }
    incIndent() { this._indent++, this.lineIsEmpty() && (this._currentLine.indent = this._indent); }
    decIndent() { this._indent--, this.lineIsEmpty() && (this._currentLine.indent = this._indent); }
    toSource() {
        return this.sourceLines.map(e => e.parts.length > 0 ? Zu(e.indent) + e.parts.join("") : "").join(`
`);
    }
    toSourceMapGenerator(e, t = 0) { let s = new Da(e), r = !1, i = () => { r || (s.addSource(e, " ").addMapping(0, e, 0, 0), r = !0); }; for (let o = 0; o < t; o++)
        s.addLine(), i(); return this.sourceLines.forEach((o, a) => { s.addLine(); let l = o.srcSpans, u = o.parts, p = o.indent * Pa.length, f = 0; for (; f < l.length && !l[f];)
        p += u[f].length, f++; for (f < l.length && a === 0 && p === 0 ? r = !0 : i(); f < l.length;) {
        let g = l[f], v = g.start.file, S = g.start.line, _ = g.start.col;
        for (s.addSource(v.url, v.content).addMapping(p, v.url, S, _), p += u[f].length, f++; f < l.length && (g === l[f] || !l[f]);)
            p += u[f].length, f++;
    } }), s; }
    spanOf(e, t) { let s = this._lines[e]; if (s) {
        let r = t - Zu(s.indent).length;
        for (let i = 0; i < s.parts.length; i++) {
            let o = s.parts[i];
            if (o.length > r)
                return s.srcSpans[i];
            r -= o.length;
        }
    } return null; }
    get sourceLines() { return this._lines.length && this._lines[this._lines.length - 1].parts.length === 0 ? this._lines.slice(0, -1) : this._lines; }
}, Ba = class {
    _escapeDollarInStrings;
    constructor(e) { this._escapeDollarInStrings = e; }
    printLeadingComments(e, t) {
        if (e.leadingComments !== void 0)
            for (let s of e.leadingComments)
                s instanceof Er ? t.print(e, `/*${s.toString()}*/`, s.trailingNewline) : s.multiline ? t.print(e, `/* ${s.text} */`, s.trailingNewline) : s.text.split(`
`).forEach(r => { t.println(e, `// ${r}`); });
    }
    visitExpressionStmt(e, t) { return this.printLeadingComments(e, t), e.expr.visitExpression(this, t), t.println(e, ";"), null; }
    visitReturnStmt(e, t) { return this.printLeadingComments(e, t), t.print(e, "return "), e.value.visitExpression(this, t), t.println(e, ";"), null; }
    visitIfStmt(e, t) { this.printLeadingComments(e, t), t.print(e, "if ("), e.condition.visitExpression(this, t), t.print(e, ") {"); let s = e.falseCase != null && e.falseCase.length > 0; return e.trueCase.length <= 1 && !s ? (t.print(e, " "), this.visitAllStatements(e.trueCase, t), t.removeEmptyLastLine(), t.print(e, " ")) : (t.println(), t.incIndent(), this.visitAllStatements(e.trueCase, t), t.decIndent(), s && (t.println(e, "} else {"), t.incIndent(), this.visitAllStatements(e.falseCase, t), t.decIndent())), t.println(e, "}"), null; }
    visitWriteVarExpr(e, t) { let s = t.lineIsEmpty(); return s || t.print(e, "("), t.print(e, `${e.name} = `), e.value.visitExpression(this, t), s || t.print(e, ")"), null; }
    visitWriteKeyExpr(e, t) { let s = t.lineIsEmpty(); return s || t.print(e, "("), e.receiver.visitExpression(this, t), t.print(e, "["), e.index.visitExpression(this, t), t.print(e, "] = "), e.value.visitExpression(this, t), s || t.print(e, ")"), null; }
    visitWritePropExpr(e, t) { let s = t.lineIsEmpty(); return s || t.print(e, "("), e.receiver.visitExpression(this, t), t.print(e, `.${e.name} = `), e.value.visitExpression(this, t), s || t.print(e, ")"), null; }
    visitInvokeFunctionExpr(e, t) { let s = e.fn instanceof pn; return s && t.print(e.fn, "("), e.fn.visitExpression(this, t), s && t.print(e.fn, ")"), t.print(e, "("), this.visitAllExpressions(e.args, t, ","), t.print(e, ")"), null; }
    visitTaggedTemplateLiteralExpr(e, t) { return e.tag.visitExpression(this, t), e.template.visitExpression(this, t), null; }
    visitTemplateLiteralExpr(e, t) { t.print(e, "`"); for (let s = 0; s < e.elements.length; s++) {
        e.elements[s].visitExpression(this, t);
        let r = s < e.expressions.length ? e.expressions[s] : null;
        r !== null && (t.print(r, "${"), r.visitExpression(this, t), t.print(r, "}"));
    } t.print(e, "`"); }
    visitTemplateLiteralElementExpr(e, t) { t.print(e, e.rawText); }
    visitWrappedNodeExpr(e, t) { throw new Error("Abstract emitter cannot visit WrappedNodeExpr."); }
    visitTypeofExpr(e, t) { t.print(e, "typeof "), e.expr.visitExpression(this, t); }
    visitReadVarExpr(e, t) { return t.print(e, e.name), null; }
    visitInstantiateExpr(e, t) { return t.print(e, "new "), e.classExpr.visitExpression(this, t), t.print(e, "("), this.visitAllExpressions(e.args, t, ","), t.print(e, ")"), null; }
    visitLiteralExpr(e, t) { let s = e.value; return typeof s == "string" ? t.print(e, bn(s, this._escapeDollarInStrings)) : t.print(e, `${s}`), null; }
    visitLocalizedString(e, t) { let s = e.serializeI18nHead(); t.print(e, "$localize `" + s.raw); for (let r = 1; r < e.messageParts.length; r++)
        t.print(e, "${"), e.expressions[r - 1].visitExpression(this, t), t.print(e, `}${e.serializeI18nTemplatePart(r).raw}`); return t.print(e, "`"), null; }
    visitConditionalExpr(e, t) { return t.print(e, "("), e.condition.visitExpression(this, t), t.print(e, "? "), e.trueCase.visitExpression(this, t), t.print(e, ": "), e.falseCase.visitExpression(this, t), t.print(e, ")"), null; }
    visitDynamicImportExpr(e, t) { t.print(e, `import(${e.url})`); }
    visitNotExpr(e, t) { return t.print(e, "!"), e.condition.visitExpression(this, t), null; }
    visitUnaryOperatorExpr(e, t) { let s; switch (e.operator) {
        case ws.Plus:
            s = "+";
            break;
        case ws.Minus:
            s = "-";
            break;
        default: throw new Error(`Unknown operator ${e.operator}`);
    } return e.parens && t.print(e, "("), t.print(e, s), e.expr.visitExpression(this, t), e.parens && t.print(e, ")"), null; }
    visitBinaryOperatorExpr(e, t) { let s; switch (e.operator) {
        case b.Equals:
            s = "==";
            break;
        case b.Identical:
            s = "===";
            break;
        case b.NotEquals:
            s = "!=";
            break;
        case b.NotIdentical:
            s = "!==";
            break;
        case b.And:
            s = "&&";
            break;
        case b.BitwiseOr:
            s = "|";
            break;
        case b.BitwiseAnd:
            s = "&";
            break;
        case b.Or:
            s = "||";
            break;
        case b.Plus:
            s = "+";
            break;
        case b.Minus:
            s = "-";
            break;
        case b.Divide:
            s = "/";
            break;
        case b.Multiply:
            s = "*";
            break;
        case b.Modulo:
            s = "%";
            break;
        case b.Lower:
            s = "<";
            break;
        case b.LowerEquals:
            s = "<=";
            break;
        case b.Bigger:
            s = ">";
            break;
        case b.BiggerEquals:
            s = ">=";
            break;
        case b.NullishCoalesce:
            s = "??";
            break;
        default: throw new Error(`Unknown operator ${e.operator}`);
    } return e.parens && t.print(e, "("), e.lhs.visitExpression(this, t), t.print(e, ` ${s} `), e.rhs.visitExpression(this, t), e.parens && t.print(e, ")"), null; }
    visitReadPropExpr(e, t) { return e.receiver.visitExpression(this, t), t.print(e, "."), t.print(e, e.name), null; }
    visitReadKeyExpr(e, t) { return e.receiver.visitExpression(this, t), t.print(e, "["), e.index.visitExpression(this, t), t.print(e, "]"), null; }
    visitLiteralArrayExpr(e, t) { return t.print(e, "["), this.visitAllExpressions(e.entries, t, ","), t.print(e, "]"), null; }
    visitLiteralMapExpr(e, t) { return t.print(e, "{"), this.visitAllObjects(s => { t.print(e, `${bn(s.key, this._escapeDollarInStrings, s.quoted)}:`), s.value.visitExpression(this, t); }, e.entries, t, ","), t.print(e, "}"), null; }
    visitCommaExpr(e, t) { return t.print(e, "("), this.visitAllExpressions(e.parts, t, ","), t.print(e, ")"), null; }
    visitAllExpressions(e, t, s) { this.visitAllObjects(r => r.visitExpression(this, t), e, t, s); }
    visitAllObjects(e, t, s, r) { let i = !1; for (let o = 0; o < t.length; o++)
        o > 0 && (s.lineLength() > 80 ? (s.print(null, r, !0), i || (s.incIndent(), s.incIndent(), i = !0)) : s.print(null, r, !1)), e(t[o]); i && (s.decIndent(), s.decIndent()); }
    visitAllStatements(e, t) { e.forEach(s => s.visitStatement(this, t)); }
};
function bn(n, e, t = !0) {
    if (n == null)
        return null;
    let s = n.replace(_d, (...i) => i[0] == "$" ? e ? "\\$" : "$" : i[0] == `
` ? "\\n" : i[0] == "\r" ? "\\r" : `\\${i[0]}`);
    return t || !Td.test(s) ? `'${s}'` : s;
}
function Zu(n) { let e = ""; for (let t = 0; t < n; t++)
    e += Pa; return e; }
function qo(n, e) { if (e === 0)
    return me(n); let t = []; for (let s = 0; s < e; s++)
    t.push(Be); return me(n, void 0, t); }
function bd(n, e) { let t = bn(e, !1, !1); return t !== e ? `${n}[${t}]` : `${n}.${e}`; }
function kd(n) { return Gp("ngJitMode", n); }
function xr(n) { return Gp("ngDevMode", n); }
function Gp(n, e) { let t = new jt({ name: n, moduleName: null }), s = new W(b.Identical, new Vn(t), d("undefined")), r = new W(b.Or, s, t, void 0, void 0, !0); return new W(b.And, r, e); }
function fe(n) { let e = new V(n); return { value: e, type: e }; }
function ht(n, e) { let t = B(n.map(s => s.value)); return e ? se([], t) : t; }
function mu(n, e) { return { expression: n, forwardRef: e }; }
function us({ expression: n, forwardRef: e }) { switch (e) {
    case 0:
    case 1: return n;
    case 2: return gu(n);
} }
function gu(n) { return y(h.forwardRef).callFn([se([], n)]); }
var Ii = function (n) { return n[n.Class = 0] = "Class", n[n.Function = 1] = "Function", n; }(Ii || {});
function An(n) { let e = N("__ngFactoryType__"), t = null, s = Ku(n) ? e : new W(b.Or, e, n.type.value), r = null; n.deps !== null ? n.deps !== "invalid" && (r = new Ss(s, Ju(n.deps, n.target))) : (t = N(`\u0275${n.name}_BaseFactory`), r = t.callFn([s])); let i = [], o = null; function a(u) { let p = N("__ngConditionalFactory__"); i.push(p.set(Wn).toDeclStmt()); let f = r !== null ? p.set(r).toStmt() : y(h.invalidFactory).callFn([]).toStmt(); return i.push(ri(e, [f], [p.set(u).toStmt()])), p; } if (Ku(n)) {
    let u = Ju(n.delegateDeps, n.target), p = new (n.delegateType === Ii.Class ? Ss : Ie)(n.delegate, u);
    o = a(p);
}
else
    Pd(n) ? o = a(n.expression) : o = r; if (o === null)
    i.push(y(h.invalidFactory).callFn([]).toStmt());
else if (t !== null) {
    let u = y(h.getInheritedFactory).callFn([n.type.value]), p = new W(b.Or, t, t.set(u));
    i.push(new ye(p.callFn([s])));
}
else
    i.push(new ye(o)); let l = zt([new Y(e.name, Be)], i, Ve, void 0, `${n.name}_Factory`); return t !== null && (l = se([], [new ve(t.name), new ye(l)]).callFn([], void 0, !0)), { expression: l, statements: [], type: Xp(n) }; }
function Xp(n) { let e = n.deps !== null && n.deps !== "invalid" ? Nd(n.deps) : mt; return me(y(h.FactoryDeclaration, [qo(n.type.type, n.typeArgumentCount), e])); }
function Ju(n, e) { return n.map((t, s) => Id(t, e, s)); }
function Id(n, e, t) { if (n.token === null)
    return y(h.invalidFactoryDep).callFn([d(t)]); if (n.attributeNameType === null) {
    let s = 0 | (n.self ? 2 : 0) | (n.skipSelf ? 4 : 0) | (n.host ? 1 : 0) | (n.optional ? 8 : 0) | (e === At.Pipe ? 16 : 0), r = s !== 0 || n.optional ? d(s) : null, i = [n.token];
    r && i.push(r);
    let o = Ld(e);
    return y(o).callFn(i);
}
else
    return y(h.injectAttribute).callFn([n.token]); }
function Nd(n) { let e = !1, t = n.map(s => { let r = Dd(s); return r !== null ? (e = !0, r) : d(null); }); return e ? me(B(t)) : mt; }
function Dd(n) { let e = []; return n.attributeNameType !== null && e.push({ key: "attribute", value: n.attributeNameType, quoted: !1 }), n.optional && e.push({ key: "optional", value: d(!0), quoted: !1 }), n.host && e.push({ key: "host", value: d(!0), quoted: !1 }), n.self && e.push({ key: "self", value: d(!0), quoted: !1 }), n.skipSelf && e.push({ key: "skipSelf", value: d(!0), quoted: !1 }), e.length > 0 ? ue(e) : null; }
function Ku(n) { return n.delegateType !== void 0; }
function Pd(n) { return n.expression !== void 0; }
function Ld(n) { switch (n) {
    case At.Component:
    case At.Directive:
    case At.Pipe: return h.directiveInject;
    case At.NgModule:
    case At.Injectable:
    default: return h.inject;
} }
var yr = class {
    input;
    errLocation;
    ctxLocation;
    message;
    constructor(e, t, s, r) { this.input = t, this.errLocation = s, this.ctxLocation = r, this.message = `Parser Error: ${e} ${s} [${t}] in ${r}`; }
}, jn = class {
    start;
    end;
    constructor(e, t) { this.start = e, this.end = t; }
    toAbsolute(e) { return new qe(e + this.start, e + this.end); }
}, re = class {
    span;
    sourceSpan;
    constructor(e, t) { this.span = e, this.sourceSpan = t; }
    toString() { return "AST"; }
}, Cs = class extends re {
    nameSpan;
    constructor(e, t, s) { super(e, t), this.nameSpan = s; }
}, Ne = class extends re {
    visit(e, t = null) { }
}, rt = class extends re {
    visit(e, t = null) { return e.visitImplicitReceiver(this, t); }
}, zn = class extends rt {
    visit(e, t = null) { return e.visitThisReceiver?.(this, t); }
}, As = class extends re {
    expressions;
    constructor(e, t, s) { super(e, t), this.expressions = s; }
    visit(e, t = null) { return e.visitChain(this, t); }
}, Ni = class extends re {
    condition;
    trueExp;
    falseExp;
    constructor(e, t, s, r, i) { super(e, t), this.condition = s, this.trueExp = r, this.falseExp = i; }
    visit(e, t = null) { return e.visitConditional(this, t); }
}, Gn = class extends Cs {
    receiver;
    name;
    constructor(e, t, s, r, i) { super(e, t, s), this.receiver = r, this.name = i; }
    visit(e, t = null) { return e.visitPropertyRead(this, t); }
}, Di = class extends Cs {
    receiver;
    name;
    value;
    constructor(e, t, s, r, i, o) { super(e, t, s), this.receiver = r, this.name = i, this.value = o; }
    visit(e, t = null) { return e.visitPropertyWrite(this, t); }
}, Pi = class extends Cs {
    receiver;
    name;
    constructor(e, t, s, r, i) { super(e, t, s), this.receiver = r, this.name = i; }
    visit(e, t = null) { return e.visitSafePropertyRead(this, t); }
}, Cr = class extends re {
    receiver;
    key;
    constructor(e, t, s, r) { super(e, t), this.receiver = s, this.key = r; }
    visit(e, t = null) { return e.visitKeyedRead(this, t); }
}, Li = class extends re {
    receiver;
    key;
    constructor(e, t, s, r) { super(e, t), this.receiver = s, this.key = r; }
    visit(e, t = null) { return e.visitSafeKeyedRead(this, t); }
}, Bi = class extends re {
    receiver;
    key;
    value;
    constructor(e, t, s, r, i) { super(e, t), this.receiver = s, this.key = r, this.value = i; }
    visit(e, t = null) { return e.visitKeyedWrite(this, t); }
}, Mi = class extends Cs {
    exp;
    name;
    args;
    constructor(e, t, s, r, i, o) { super(e, t, o), this.exp = s, this.name = r, this.args = i; }
    visit(e, t = null) { return e.visitPipe(this, t); }
}, Ze = class extends re {
    value;
    constructor(e, t, s) { super(e, t), this.value = s; }
    visit(e, t = null) { return e.visitLiteralPrimitive(this, t); }
}, Ri = class extends re {
    expressions;
    constructor(e, t, s) { super(e, t), this.expressions = s; }
    visit(e, t = null) { return e.visitLiteralArray(this, t); }
}, Fi = class extends re {
    keys;
    values;
    constructor(e, t, s, r) { super(e, t), this.keys = s, this.values = r; }
    visit(e, t = null) { return e.visitLiteralMap(this, t); }
}, ii = class extends re {
    strings;
    expressions;
    constructor(e, t, s, r) { super(e, t), this.strings = s, this.expressions = r; }
    visit(e, t = null) { return e.visitInterpolation(this, t); }
}, ut = class extends re {
    operation;
    left;
    right;
    constructor(e, t, s, r, i) { super(e, t), this.operation = s, this.left = r, this.right = i; }
    visit(e, t = null) { return e.visitBinary(this, t); }
}, Ar = class n extends ut {
    operator;
    expr;
    left = null;
    right = null;
    operation = null;
    static createMinus(e, t, s) { return new n(e, t, "-", s, "-", new Ze(e, t, 0), s); }
    static createPlus(e, t, s) { return new n(e, t, "+", s, "-", s, new Ze(e, t, 0)); }
    constructor(e, t, s, r, i, o, a) { super(e, t, i, o, a), this.operator = s, this.expr = r; }
    visit(e, t = null) { return e.visitUnary !== void 0 ? e.visitUnary(this, t) : e.visitBinary(this, t); }
}, $i = class extends re {
    expression;
    constructor(e, t, s) { super(e, t), this.expression = s; }
    visit(e, t = null) { return e.visitPrefixNot(this, t); }
}, Oi = class extends re {
    expression;
    constructor(e, t, s) { super(e, t), this.expression = s; }
    visit(e, t = null) { return e.visitTypeofExpression(this, t); }
}, _r = class extends re {
    expression;
    constructor(e, t, s) { super(e, t), this.expression = s; }
    visit(e, t = null) { return e.visitNonNullAssert(this, t); }
}, Tr = class extends re {
    receiver;
    args;
    argumentSpan;
    constructor(e, t, s, r, i) { super(e, t), this.receiver = s, this.args = r, this.argumentSpan = i; }
    visit(e, t = null) { return e.visitCall(this, t); }
}, Vi = class extends re {
    receiver;
    args;
    argumentSpan;
    constructor(e, t, s, r, i) { super(e, t), this.receiver = s, this.args = r, this.argumentSpan = i; }
    visit(e, t = null) { return e.visitSafeCall(this, t); }
}, br = class extends re {
    elements;
    expressions;
    constructor(e, t, s, r) { super(e, t), this.elements = s, this.expressions = r; }
    visit(e, t) { return e.visitTemplateLiteral(this, t); }
}, qi = class extends re {
    text;
    constructor(e, t, s) { super(e, t), this.text = s; }
    visit(e, t) { return e.visitTemplateLiteralElement(this, t); }
}, qe = class {
    start;
    end;
    constructor(e, t) { this.start = e, this.end = t; }
}, Ke = class extends re {
    ast;
    source;
    location;
    errors;
    constructor(e, t, s, r, i) { super(new jn(0, t === null ? 0 : t.length), new qe(r, t === null ? r : r + t.length)), this.ast = e, this.source = t, this.location = s, this.errors = i; }
    visit(e, t = null) { return e.visitASTWithSource ? e.visitASTWithSource(this, t) : this.ast.visit(e, t); }
    toString() { return `${this.source} in ${this.location}`; }
}, kr = class {
    sourceSpan;
    key;
    value;
    constructor(e, t, s) { this.sourceSpan = e, this.key = t, this.value = s; }
}, Ma = class {
    sourceSpan;
    key;
    value;
    constructor(e, t, s) { this.sourceSpan = e, this.key = t, this.value = s; }
}, Hi = class {
    visit(e, t) { e.visit(this, t); }
    visitUnary(e, t) { this.visit(e.expr, t); }
    visitBinary(e, t) { this.visit(e.left, t), this.visit(e.right, t); }
    visitChain(e, t) { this.visitAll(e.expressions, t); }
    visitConditional(e, t) { this.visit(e.condition, t), this.visit(e.trueExp, t), this.visit(e.falseExp, t); }
    visitPipe(e, t) { this.visit(e.exp, t), this.visitAll(e.args, t); }
    visitImplicitReceiver(e, t) { }
    visitThisReceiver(e, t) { }
    visitInterpolation(e, t) { this.visitAll(e.expressions, t); }
    visitKeyedRead(e, t) { this.visit(e.receiver, t), this.visit(e.key, t); }
    visitKeyedWrite(e, t) { this.visit(e.receiver, t), this.visit(e.key, t), this.visit(e.value, t); }
    visitLiteralArray(e, t) { this.visitAll(e.expressions, t); }
    visitLiteralMap(e, t) { this.visitAll(e.values, t); }
    visitLiteralPrimitive(e, t) { }
    visitPrefixNot(e, t) { this.visit(e.expression, t); }
    visitTypeofExpression(e, t) { this.visit(e.expression, t); }
    visitNonNullAssert(e, t) { this.visit(e.expression, t); }
    visitPropertyRead(e, t) { this.visit(e.receiver, t); }
    visitPropertyWrite(e, t) { this.visit(e.receiver, t), this.visit(e.value, t); }
    visitSafePropertyRead(e, t) { this.visit(e.receiver, t); }
    visitSafeKeyedRead(e, t) { this.visit(e.receiver, t), this.visit(e.key, t); }
    visitCall(e, t) { this.visit(e.receiver, t), this.visitAll(e.args, t); }
    visitSafeCall(e, t) { this.visit(e.receiver, t), this.visitAll(e.args, t); }
    visitTemplateLiteral(e, t) { for (let s = 0; s < e.elements.length; s++) {
        this.visit(e.elements[s], t);
        let r = s < e.expressions.length ? e.expressions[s] : null;
        r !== null && this.visit(r, t);
    } }
    visitTemplateLiteralElement(e, t) { }
    visitAll(e, t) { for (let s of e)
        this.visit(s, t); }
}, ir = class {
    name;
    expression;
    type;
    sourceSpan;
    keySpan;
    valueSpan;
    isLiteral;
    isAnimation;
    constructor(e, t, s, r, i, o) { this.name = e, this.expression = t, this.type = s, this.sourceSpan = r, this.keySpan = i, this.valueSpan = o, this.isLiteral = this.type === sn.LITERAL_ATTR, this.isAnimation = this.type === sn.ANIMATION; }
}, sn = function (n) { return n[n.DEFAULT = 0] = "DEFAULT", n[n.LITERAL_ATTR = 1] = "LITERAL_ATTR", n[n.ANIMATION = 2] = "ANIMATION", n[n.TWO_WAY = 3] = "TWO_WAY", n; }(sn || {}), it = function (n) { return n[n.Regular = 0] = "Regular", n[n.Animation = 1] = "Animation", n[n.TwoWay = 2] = "TwoWay", n; }(it || {}), Ui = class {
    name;
    targetOrPhase;
    type;
    handler;
    sourceSpan;
    handlerSpan;
    keySpan;
    constructor(e, t, s, r, i, o, a) { this.name = e, this.targetOrPhase = t, this.type = s, this.handler = r, this.sourceSpan = i, this.handlerSpan = o, this.keySpan = a; }
}, Ra = class {
    name;
    value;
    sourceSpan;
    keySpan;
    valueSpan;
    constructor(e, t, s, r, i) { this.name = e, this.value = t, this.sourceSpan = s, this.keySpan = r, this.valueSpan = i; }
}, K = function (n) { return n[n.Property = 0] = "Property", n[n.Attribute = 1] = "Attribute", n[n.Class = 2] = "Class", n[n.Style = 3] = "Style", n[n.Animation = 4] = "Animation", n[n.TwoWay = 5] = "TwoWay", n; }(K || {}), Wi = class {
    name;
    type;
    securityContext;
    value;
    unit;
    sourceSpan;
    keySpan;
    valueSpan;
    constructor(e, t, s, r, i, o, a, l) { this.name = e, this.type = t, this.securityContext = s, this.value = r, this.unit = i, this.sourceSpan = o, this.keySpan = a, this.valueSpan = l; }
}, _t = function (n) { return n[n.RAW_TEXT = 0] = "RAW_TEXT", n[n.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", n[n.PARSABLE_DATA = 2] = "PARSABLE_DATA", n; }(_t || {});
function vt(n, e = !0) { if (n[0] != ":")
    return [null, n]; let t = n.indexOf(":", 1); if (t === -1) {
    if (e)
        throw new Error(`Unsupported format "${n}" expecting ":namespace:name"`);
    return [null, n];
} return [n.slice(1, t), n.slice(t + 1)]; }
function ec(n) { return vt(n)[1] === "ng-container"; }
function Fa(n) { return vt(n)[1] === "ng-content"; }
function Bd(n) { return vt(n)[1] === "ng-template"; }
function $a(n) { return n === null ? null : vt(n)[0]; }
function Oa(n, e) { return n ? `:${n}:${e}` : e; }
var Ho = class {
    value;
    sourceSpan;
    constructor(e, t) { this.value = e, this.sourceSpan = t; }
    visit(e) { throw new Error("visit() not implemented for Comment"); }
}, kn = class {
    value;
    sourceSpan;
    constructor(e, t) { this.value = e, this.sourceSpan = t; }
    visit(e) { return e.visitText(this); }
}, _s = class {
    value;
    sourceSpan;
    i18n;
    constructor(e, t, s) { this.value = e, this.sourceSpan = t, this.i18n = s; }
    visit(e) { return e.visitBoundText(this); }
}, Ts = class {
    name;
    value;
    sourceSpan;
    keySpan;
    valueSpan;
    i18n;
    constructor(e, t, s, r, i, o) { this.name = e, this.value = t, this.sourceSpan = s, this.keySpan = r, this.valueSpan = i, this.i18n = o; }
    visit(e) { return e.visitTextAttribute(this); }
}, Va = class n {
    name;
    type;
    securityContext;
    value;
    unit;
    sourceSpan;
    keySpan;
    valueSpan;
    i18n;
    constructor(e, t, s, r, i, o, a, l, u) { this.name = e, this.type = t, this.securityContext = s, this.value = r, this.unit = i, this.sourceSpan = o, this.keySpan = a, this.valueSpan = l, this.i18n = u; }
    static fromBoundElementProperty(e, t) { if (e.keySpan === void 0)
        throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${e.name}: ${e.sourceSpan}`); return new n(e.name, e.type, e.securityContext, e.value, e.unit, e.sourceSpan, e.keySpan, e.valueSpan, t); }
    visit(e) { return e.visitBoundAttribute(this); }
}, qa = class n {
    name;
    type;
    handler;
    target;
    phase;
    sourceSpan;
    handlerSpan;
    keySpan;
    constructor(e, t, s, r, i, o, a, l) { this.name = e, this.type = t, this.handler = s, this.target = r, this.phase = i, this.sourceSpan = o, this.handlerSpan = a, this.keySpan = l; }
    static fromParsedEvent(e) { let t = e.type === it.Regular ? e.targetOrPhase : null, s = e.type === it.Animation ? e.targetOrPhase : null; if (e.keySpan === void 0)
        throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${e.name}: ${e.sourceSpan}`); return new n(e.name, e.type, e.handler, t, s, e.sourceSpan, e.handlerSpan, e.keySpan); }
    visit(e) { return e.visitBoundEvent(this); }
}, Nt = class {
    name;
    attributes;
    inputs;
    outputs;
    children;
    references;
    sourceSpan;
    startSourceSpan;
    endSourceSpan;
    i18n;
    constructor(e, t, s, r, i, o, a, l, u, p) { this.name = e, this.attributes = t, this.inputs = s, this.outputs = r, this.children = i, this.references = o, this.sourceSpan = a, this.startSourceSpan = l, this.endSourceSpan = u, this.i18n = p; }
    visit(e) { return e.visitElement(this); }
}, Dt = class {
    nameSpan;
    sourceSpan;
    prefetchSpan;
    whenOrOnSourceSpan;
    hydrateSpan;
    constructor(e, t, s, r, i) { this.nameSpan = e, this.sourceSpan = t, this.prefetchSpan = s, this.whenOrOnSourceSpan = r, this.hydrateSpan = i; }
    visit(e) { return e.visitDeferredTrigger(this); }
}, Ha = class extends Dt {
    value;
    constructor(e, t, s, r, i) { super(null, t, s, r, i), this.value = e; }
}, Ua = class extends Dt {
}, Wa = class extends Dt {
}, ja = class extends Dt {
}, ji = class extends Dt {
    reference;
    constructor(e, t, s, r, i, o) { super(t, s, r, i, o), this.reference = e; }
}, za = class extends Dt {
    delay;
    constructor(e, t, s, r, i, o) { super(t, s, r, i, o), this.delay = e; }
}, zi = class extends Dt {
    reference;
    constructor(e, t, s, r, i, o) { super(t, s, r, i, o), this.reference = e; }
}, Gi = class extends Dt {
    reference;
    constructor(e, t, s, r, i, o) { super(t, s, r, i, o), this.reference = e; }
}, lt = class {
    nameSpan;
    sourceSpan;
    startSourceSpan;
    endSourceSpan;
    constructor(e, t, s, r) { this.nameSpan = e, this.sourceSpan = t, this.startSourceSpan = s, this.endSourceSpan = r; }
}, Ir = class extends lt {
    children;
    minimumTime;
    i18n;
    constructor(e, t, s, r, i, o, a) { super(s, r, i, o), this.children = e, this.minimumTime = t, this.i18n = a; }
    visit(e) { return e.visitDeferredBlockPlaceholder(this); }
}, Nr = class extends lt {
    children;
    afterTime;
    minimumTime;
    i18n;
    constructor(e, t, s, r, i, o, a, l) { super(r, i, o, a), this.children = e, this.afterTime = t, this.minimumTime = s, this.i18n = l; }
    visit(e) { return e.visitDeferredBlockLoading(this); }
}, Dr = class extends lt {
    children;
    i18n;
    constructor(e, t, s, r, i, o) { super(t, s, r, i), this.children = e, this.i18n = o; }
    visit(e) { return e.visitDeferredBlockError(this); }
}, Xn = class extends lt {
    children;
    placeholder;
    loading;
    error;
    mainBlockSpan;
    i18n;
    triggers;
    prefetchTriggers;
    hydrateTriggers;
    definedTriggers;
    definedPrefetchTriggers;
    definedHydrateTriggers;
    constructor(e, t, s, r, i, o, a, l, u, p, f, g, v) { super(l, u, f, g), this.children = e, this.placeholder = i, this.loading = o, this.error = a, this.mainBlockSpan = p, this.i18n = v, this.triggers = t, this.prefetchTriggers = s, this.hydrateTriggers = r, this.definedTriggers = Object.keys(t), this.definedPrefetchTriggers = Object.keys(s), this.definedHydrateTriggers = Object.keys(r); }
    visit(e) { return e.visitDeferredBlock(this); }
    visitAll(e) { this.visitTriggers(this.definedHydrateTriggers, this.hydrateTriggers, e), this.visitTriggers(this.definedTriggers, this.triggers, e), this.visitTriggers(this.definedPrefetchTriggers, this.prefetchTriggers, e), ne(e, this.children); let t = [this.placeholder, this.loading, this.error].filter(s => s !== null); ne(e, t); }
    visitTriggers(e, t, s) { ne(s, e.map(r => t[r])); }
}, Xi = class extends lt {
    expression;
    cases;
    unknownBlocks;
    constructor(e, t, s, r, i, o, a) { super(a, r, i, o), this.expression = e, this.cases = t, this.unknownBlocks = s; }
    visit(e) { return e.visitSwitchBlock(this); }
}, Pr = class extends lt {
    expression;
    children;
    i18n;
    constructor(e, t, s, r, i, o, a) { super(o, s, r, i), this.expression = e, this.children = t, this.i18n = a; }
    visit(e) { return e.visitSwitchBlockCase(this); }
}, bs = class extends lt {
    item;
    expression;
    trackBy;
    trackKeywordSpan;
    contextVariables;
    children;
    empty;
    mainBlockSpan;
    i18n;
    constructor(e, t, s, r, i, o, a, l, u, p, f, g, v) { super(g, l, p, f), this.item = e, this.expression = t, this.trackBy = s, this.trackKeywordSpan = r, this.contextVariables = i, this.children = o, this.empty = a, this.mainBlockSpan = u, this.i18n = v; }
    visit(e) { return e.visitForLoopBlock(this); }
}, Lr = class extends lt {
    children;
    i18n;
    constructor(e, t, s, r, i, o) { super(i, t, s, r), this.children = e, this.i18n = o; }
    visit(e) { return e.visitForLoopBlockEmpty(this); }
}, Yi = class extends lt {
    branches;
    constructor(e, t, s, r, i) { super(i, t, s, r), this.branches = e; }
    visit(e) { return e.visitIfBlock(this); }
}, Ln = class extends lt {
    expression;
    children;
    expressionAlias;
    i18n;
    constructor(e, t, s, r, i, o, a, l) { super(a, r, i, o), this.expression = e, this.children = t, this.expressionAlias = s, this.i18n = l; }
    visit(e) { return e.visitIfBlockBranch(this); }
}, Qi = class {
    name;
    sourceSpan;
    nameSpan;
    constructor(e, t, s) { this.name = e, this.sourceSpan = t, this.nameSpan = s; }
    visit(e) { return e.visitUnknownBlock(this); }
}, vu = class {
    name;
    value;
    sourceSpan;
    nameSpan;
    valueSpan;
    constructor(e, t, s, r, i) { this.name = e, this.value = t, this.sourceSpan = s, this.nameSpan = r, this.valueSpan = i; }
    visit(e) { return e.visitLetDeclaration(this); }
}, Ue = class {
    tagName;
    attributes;
    inputs;
    outputs;
    templateAttrs;
    children;
    references;
    variables;
    sourceSpan;
    startSourceSpan;
    endSourceSpan;
    i18n;
    constructor(e, t, s, r, i, o, a, l, u, p, f, g) { this.tagName = e, this.attributes = t, this.inputs = s, this.outputs = r, this.templateAttrs = i, this.children = o, this.references = a, this.variables = l, this.sourceSpan = u, this.startSourceSpan = p, this.endSourceSpan = f, this.i18n = g; }
    visit(e) { return e.visitTemplate(this); }
}, ks = class {
    selector;
    attributes;
    children;
    sourceSpan;
    i18n;
    name = "ng-content";
    constructor(e, t, s, r, i) { this.selector = e, this.attributes = t, this.children = s, this.sourceSpan = r, this.i18n = i; }
    visit(e) { return e.visitContent(this); }
}, mn = class {
    name;
    value;
    sourceSpan;
    keySpan;
    valueSpan;
    constructor(e, t, s, r, i) { this.name = e, this.value = t, this.sourceSpan = s, this.keySpan = r, this.valueSpan = i; }
    visit(e) { return e.visitVariable(this); }
}, Br = class {
    name;
    value;
    sourceSpan;
    keySpan;
    valueSpan;
    constructor(e, t, s, r, i) { this.name = e, this.value = t, this.sourceSpan = s, this.keySpan = r, this.valueSpan = i; }
    visit(e) { return e.visitReference(this); }
}, Yp = class {
    vars;
    placeholders;
    sourceSpan;
    i18n;
    constructor(e, t, s, r) { this.vars = e, this.placeholders = t, this.sourceSpan = s, this.i18n = r; }
    visit(e) { return e.visitIcu(this); }
}, Md = class {
    visitElement(e) { ne(this, e.attributes), ne(this, e.inputs), ne(this, e.outputs), ne(this, e.children), ne(this, e.references); }
    visitTemplate(e) { ne(this, e.attributes), ne(this, e.inputs), ne(this, e.outputs), ne(this, e.children), ne(this, e.references), ne(this, e.variables); }
    visitDeferredBlock(e) { e.visitAll(this); }
    visitDeferredBlockPlaceholder(e) { ne(this, e.children); }
    visitDeferredBlockError(e) { ne(this, e.children); }
    visitDeferredBlockLoading(e) { ne(this, e.children); }
    visitSwitchBlock(e) { ne(this, e.cases); }
    visitSwitchBlockCase(e) { ne(this, e.children); }
    visitForLoopBlock(e) { let t = [e.item, ...e.contextVariables, ...e.children]; e.empty && t.push(e.empty), ne(this, t); }
    visitForLoopBlockEmpty(e) { ne(this, e.children); }
    visitIfBlock(e) { ne(this, e.branches); }
    visitIfBlockBranch(e) { let t = e.children; e.expressionAlias && t.push(e.expressionAlias), ne(this, t); }
    visitContent(e) { ne(this, e.children); }
    visitVariable(e) { }
    visitReference(e) { }
    visitTextAttribute(e) { }
    visitBoundAttribute(e) { }
    visitBoundEvent(e) { }
    visitText(e) { }
    visitBoundText(e) { }
    visitIcu(e) { }
    visitDeferredTrigger(e) { }
    visitUnknownBlock(e) { }
    visitLetDeclaration(e) { }
};
function ne(n, e) { let t = []; if (n.visit)
    for (let s of e)
        n.visit(s) || s.visit(n);
else
    for (let s of e) {
        let r = s.visit(n);
        r && t.push(r);
    } return t; }
var Ae = class {
    nodes;
    placeholders;
    placeholderToMessage;
    meaning;
    description;
    customId;
    sources;
    id;
    legacyIds = [];
    messageString;
    constructor(e, t, s, r, i, o) { this.nodes = e, this.placeholders = t, this.placeholderToMessage = s, this.meaning = r, this.description = i, this.customId = o, this.id = this.customId, this.messageString = Rd(this.nodes), e.length ? this.sources = [{ filePath: e[0].sourceSpan.start.file.url, startLine: e[0].sourceSpan.start.line + 1, startCol: e[0].sourceSpan.start.col + 1, endLine: e[e.length - 1].sourceSpan.end.line + 1, endCol: e[0].sourceSpan.start.col + 1 }] : this.sources = []; }
}, Tt = class {
    value;
    sourceSpan;
    constructor(e, t) { this.value = e, this.sourceSpan = t; }
    visit(e, t) { return e.visitText(this, t); }
}, We = class {
    children;
    sourceSpan;
    constructor(e, t) { this.children = e, this.sourceSpan = t; }
    visit(e, t) { return e.visitContainer(this, t); }
}, gn = class {
    expression;
    type;
    cases;
    sourceSpan;
    expressionPlaceholder;
    constructor(e, t, s, r, i) { this.expression = e, this.type = t, this.cases = s, this.sourceSpan = r, this.expressionPlaceholder = i; }
    visit(e, t) { return e.visitIcu(this, t); }
}, Pt = class {
    tag;
    attrs;
    startName;
    closeName;
    children;
    isVoid;
    sourceSpan;
    startSourceSpan;
    endSourceSpan;
    constructor(e, t, s, r, i, o, a, l, u) { this.tag = e, this.attrs = t, this.startName = s, this.closeName = r, this.children = i, this.isVoid = o, this.sourceSpan = a, this.startSourceSpan = l, this.endSourceSpan = u; }
    visit(e, t) { return e.visitTagPlaceholder(this, t); }
}, ot = class {
    value;
    name;
    sourceSpan;
    constructor(e, t, s) { this.value = e, this.name = t, this.sourceSpan = s; }
    visit(e, t) { return e.visitPlaceholder(this, t); }
}, vn = class {
    value;
    name;
    sourceSpan;
    previousMessage;
    constructor(e, t, s) { this.value = e, this.name = t, this.sourceSpan = s; }
    visit(e, t) { return e.visitIcuPlaceholder(this, t); }
}, Lt = class {
    name;
    parameters;
    startName;
    closeName;
    children;
    sourceSpan;
    startSourceSpan;
    endSourceSpan;
    constructor(e, t, s, r, i, o, a, l) { this.name = e, this.parameters = t, this.startName = s, this.closeName = r, this.children = i, this.sourceSpan = o, this.startSourceSpan = a, this.endSourceSpan = l; }
    visit(e, t) { return e.visitBlockPlaceholder(this, t); }
}, Ga = class {
    visitText(e, t) { return new Tt(e.value, e.sourceSpan); }
    visitContainer(e, t) { let s = e.children.map(r => r.visit(this, t)); return new We(s, e.sourceSpan); }
    visitIcu(e, t) { let s = {}; return Object.keys(e.cases).forEach(i => s[i] = e.cases[i].visit(this, t)), new gn(e.expression, e.type, s, e.sourceSpan, e.expressionPlaceholder); }
    visitTagPlaceholder(e, t) { let s = e.children.map(r => r.visit(this, t)); return new Pt(e.tag, e.attrs, e.startName, e.closeName, s, e.isVoid, e.sourceSpan, e.startSourceSpan, e.endSourceSpan); }
    visitPlaceholder(e, t) { return new ot(e.value, e.name, e.sourceSpan); }
    visitIcuPlaceholder(e, t) { return new vn(e.value, e.name, e.sourceSpan); }
    visitBlockPlaceholder(e, t) { let s = e.children.map(r => r.visit(this, t)); return new Lt(e.name, e.parameters, e.startName, e.closeName, s, e.sourceSpan, e.startSourceSpan, e.endSourceSpan); }
}, Xa = class {
    visitText(e, t) { }
    visitContainer(e, t) { e.children.forEach(s => s.visit(this)); }
    visitIcu(e, t) { Object.keys(e.cases).forEach(s => { e.cases[s].visit(this); }); }
    visitTagPlaceholder(e, t) { e.children.forEach(s => s.visit(this)); }
    visitPlaceholder(e, t) { }
    visitIcuPlaceholder(e, t) { }
    visitBlockPlaceholder(e, t) { e.children.forEach(s => s.visit(this)); }
};
function Rd(n) { let e = new Ya; return n.map(s => s.visit(e)).join(""); }
var Ya = class {
    visitText(e) { return e.value; }
    visitContainer(e) { return e.children.map(t => t.visit(this)).join(""); }
    visitIcu(e) { let t = Object.keys(e.cases).map(s => `${s} {${e.cases[s].visit(this)}}`); return `{${e.expressionPlaceholder}, ${e.type}, ${t.join(" ")}}`; }
    visitTagPlaceholder(e) { let t = e.children.map(s => s.visit(this)).join(""); return `{$${e.startName}}${t}{$${e.closeName}}`; }
    visitPlaceholder(e) { return `{$${e.name}}`; }
    visitIcuPlaceholder(e) { return `{$${e.name}}`; }
    visitBlockPlaceholder(e) { let t = e.children.map(s => s.visit(this)).join(""); return `{$${e.startName}}${t}{$${e.closeName}}`; }
}, Is = class {
    createNameMapper(e) { return null; }
}, Zi = class extends Xa {
    mapName;
    internalToPublic = {};
    publicToNextId = {};
    publicToInternal = {};
    constructor(e, t) { super(), this.mapName = t, e.nodes.forEach(s => s.visit(this)); }
    toPublicName(e) { return this.internalToPublic.hasOwnProperty(e) ? this.internalToPublic[e] : null; }
    toInternalName(e) { return this.publicToInternal.hasOwnProperty(e) ? this.publicToInternal[e] : null; }
    visitText(e, t) { return null; }
    visitTagPlaceholder(e, t) { this.visitPlaceholderName(e.startName), super.visitTagPlaceholder(e, t), this.visitPlaceholderName(e.closeName); }
    visitPlaceholder(e, t) { this.visitPlaceholderName(e.name); }
    visitBlockPlaceholder(e, t) { this.visitPlaceholderName(e.startName), super.visitBlockPlaceholder(e, t), this.visitPlaceholderName(e.closeName); }
    visitIcuPlaceholder(e, t) { this.visitPlaceholderName(e.name); }
    visitPlaceholderName(e) { if (!e || this.internalToPublic.hasOwnProperty(e))
        return; let t = this.mapName(e); if (this.publicToInternal.hasOwnProperty(t)) {
        let s = this.publicToNextId[t];
        this.publicToNextId[t] = s + 1, t = `${t}_${s}`;
    }
    else
        this.publicToNextId[t] = 1; this.internalToPublic[e] = t, this.publicToInternal[t] = e; }
}, Fd = class {
    visitTag(e) { let t = this._serializeAttributes(e.attrs); if (e.children.length == 0)
        return `<${e.name}${t}/>`; let s = e.children.map(r => r.visit(this)); return `<${e.name}${t}>${s.join("")}</${e.name}>`; }
    visitText(e) { return e.value; }
    visitDeclaration(e) { return `<?xml${this._serializeAttributes(e.attrs)} ?>`; }
    _serializeAttributes(e) { let t = Object.keys(e).map(s => `${s}="${e[s]}"`).join(" "); return t.length > 0 ? " " + t : ""; }
    visitDoctype(e) {
        return `<!DOCTYPE ${e.rootTag} [
${e.dtd}
]>`;
    }
}, $d = new Fd;
function wu(n) { return n.map(e => e.visit($d)).join(""); }
var Mr = class {
    attrs = {};
    constructor(e) { Object.keys(e).forEach(t => { this.attrs[t] = Uo(e[t]); }); }
    visit(e) { return e.visitDeclaration(this); }
}, Qa = class {
    rootTag;
    dtd;
    constructor(e, t) { this.rootTag = e, this.dtd = t; }
    visit(e) { return e.visitDoctype(this); }
}, P = class {
    name;
    children;
    attrs = {};
    constructor(e, t = {}, s = []) { this.name = e, this.children = s, Object.keys(t).forEach(r => { this.attrs[r] = Uo(t[r]); }); }
    visit(e) { return e.visitTag(this); }
}, G = class {
    value;
    constructor(e) { this.value = Uo(e); }
    visit(e) { return e.visitText(this); }
}, U = class extends G {
    constructor(e = 0) {
        super(`
${new Array(e + 1).join(" ")}`);
    }
}, Od = [[/&/g, "&amp;"], [/"/g, "&quot;"], [/'/g, "&apos;"], [/</g, "&lt;"], [/>/g, "&gt;"]];
function Uo(n) { return Od.reduce((e, t) => e.replace(t[0], t[1]), n); }
var Vd = "angular", tc = "messagebundle", qd = "msg", yn = "ph", Cn = "ex", Hd = "source", Ud = `<!ELEMENT messagebundle (msg)*>
<!ATTLIST messagebundle class CDATA #IMPLIED>

<!ELEMENT msg (#PCDATA|ph|source)*>
<!ATTLIST msg id CDATA #IMPLIED>
<!ATTLIST msg seq CDATA #IMPLIED>
<!ATTLIST msg name CDATA #IMPLIED>
<!ATTLIST msg desc CDATA #IMPLIED>
<!ATTLIST msg meaning CDATA #IMPLIED>
<!ATTLIST msg obsolete (obsolete) #IMPLIED>
<!ATTLIST msg xml:space (default|preserve) "default">
<!ATTLIST msg is_hidden CDATA #IMPLIED>

<!ELEMENT source (#PCDATA)>

<!ELEMENT ph (#PCDATA|ex)*>
<!ATTLIST ph name CDATA #REQUIRED>

<!ELEMENT ex (#PCDATA)>`, Za = class extends Is {
    write(e, t) { let s = new Ja, r = new Wd, i = new P(tc); return i.attrs.handler = Vd, e.forEach(o => { let a = { id: o.id }; o.description && (a.desc = o.description), o.meaning && (a.meaning = o.meaning); let l = []; o.sources.forEach(u => { l.push(new P(Hd, {}, [new G(`${u.filePath}:${u.startLine}${u.endLine !== u.startLine ? "," + u.endLine : ""}`)])); }), i.children.push(new U(2), new P(qd, a, [...l, ...r.serialize(o.nodes)])); }), i.children.push(new U), wu([new Mr({ version: "1.0", encoding: "UTF-8" }), new U, new Qa(tc, Ud), new U, s.addDefaultExamples(i), new U]); }
    load(e, t) { throw new Error("Unsupported"); }
    digest(e) { return Qp(e); }
    createNameMapper(e) { return new Zi(e, Eu); }
}, Wd = class {
    visitText(e, t) { return [new G(e.value)]; }
    visitContainer(e, t) { let s = []; return e.children.forEach(r => s.push(...r.visit(this))), s; }
    visitIcu(e, t) { let s = [new G(`{${e.expressionPlaceholder}, ${e.type}, `)]; return Object.keys(e.cases).forEach(r => { s.push(new G(`${r} {`), ...e.cases[r].visit(this), new G("} ")); }), s.push(new G("}")), s; }
    visitTagPlaceholder(e, t) { let s = new G(`<${e.tag}>`), r = new P(Cn, {}, [s]), i = new P(yn, { name: e.startName }, [r, s]); if (e.isVoid)
        return [i]; let o = new G(`</${e.tag}>`), a = new P(Cn, {}, [o]), l = new P(yn, { name: e.closeName }, [a, o]); return [i, ...this.serialize(e.children), l]; }
    visitPlaceholder(e, t) { let s = new G(`{{${e.value}}}`), r = new P(Cn, {}, [s]); return [new P(yn, { name: e.name }, [r, s])]; }
    visitBlockPlaceholder(e, t) { let s = new G(`@${e.name}`), r = new P(Cn, {}, [s]), i = new P(yn, { name: e.startName }, [r, s]), o = new G("}"), a = new P(Cn, {}, [o]), l = new P(yn, { name: e.closeName }, [a, o]); return [i, ...this.serialize(e.children), l]; }
    visitIcuPlaceholder(e, t) { let s = e.value.expression, r = e.value.type, i = Object.keys(e.value.cases).map(l => l + " {...}").join(" "), o = new G(`{${s}, ${r}, ${i}}`), a = new P(Cn, {}, [o]); return [new P(yn, { name: e.name }, [a, o])]; }
    serialize(e) { return [].concat(...e.map(t => t.visit(this))); }
};
function Qp(n) { return hu(n); }
var Ja = class {
    addDefaultExamples(e) { return e.visit(this), e; }
    visitTag(e) { if (e.name === yn) {
        if (!e.children || e.children.length == 0) {
            let t = new G(e.attrs.name || "...");
            e.children = [new P(Cn, {}, [t])];
        }
    }
    else
        e.children && e.children.forEach(t => t.visit(this)); }
    visitText(e) { }
    visitDeclaration(e) { }
    visitDoctype(e) { }
};
function Eu(n) { return n.toUpperCase().replace(/[^A-Z0-9_]/g, "_"); }
var Zp = "i18n", Ka = "i18n-", jd = "VAR_";
function Jp(n) { return n === Zp || n.startsWith(Ka); }
function zd(n) { return n.attrs.some(e => Jp(e.name)); }
function Kp(n) { return n.nodes[0]; }
function Su(n = {}, e) { let t = {}; return n && Object.keys(n).length && Object.keys(n).forEach(s => t[oi(s, e)] = n[s]), t; }
function oi(n, e = !0) { let t = Eu(n); if (!e)
    return t; let s = t.split("_"); if (s.length === 1)
    return n.toLowerCase(); let r; /^\d+$/.test(s[s.length - 1]) && (r = s.pop()); let i = s.shift().toLowerCase(); return s.length && (i += s.map(o => o.charAt(0).toUpperCase() + o.slice(1).toLowerCase()).join("")), r ? `${i}_${r}` : i; }
var xu = /[-.]/, yu = "_t", Rr = "ctx", Cu = "rf";
function eh(n, e) { let t = null; return () => (t || (n(new ve(yu, void 0, Be)), t = N(e)), t); }
function be(n) { return Array.isArray(n) ? B(n.map(be)) : d(n, Ve); }
function el(n, e) { let t = Object.getOwnPropertyNames(n); return t.length === 0 ? null : ue(t.map(s => { let r = n[s], i, o, a, l; if (typeof r == "string")
    i = s, a = s, o = r, l = be(o);
else {
    a = s, i = r.classPropertyName, o = r.bindingPropertyName;
    let u = o !== i, p = r.transformFunction !== null, f = ls.None;
    if (r.isSignal && (f |= ls.SignalBased), p && (f |= ls.HasDecoratorInputTransform), e && (u || p || f !== ls.None)) {
        let g = [d(f), be(o)];
        (u || p) && (g.push(be(i)), p && g.push(r.transformFunction)), l = B(g);
    }
    else
        l = be(o);
} return { key: a, quoted: xu.test(a), value: l }; })); }
var ie = class {
    values = [];
    set(e, t) { if (t) {
        let s = this.values.find(r => r.key === e);
        s ? s.value = t : this.values.push({ key: e, value: t, quoted: !1 });
    } }
    toLiteralMap() { return ue(this.values); }
};
function Gd(n) { let e = n instanceof Nt ? n.name : "ng-template", t = Xd(n), s = new On, r = vt(e)[1]; return s.setElement(r), Object.getOwnPropertyNames(t).forEach(i => { let o = vt(i)[1], a = t[i]; s.addAttribute(o, a), i.toLowerCase() === "class" && a.trim().split(/\s+/).forEach(u => s.addClassName(u)); }), s; }
function Xd(n) { let e = {}; return n instanceof Ue && n.tagName !== "ng-template" ? n.templateAttrs.forEach(t => e[t.name] = "") : (n.attributes.forEach(t => { Jp(t.name) || (e[t.name] = t.value); }), n.inputs.forEach(t => { (t.type === K.Property || t.type === K.TwoWay) && (e[t.name] = ""); }), n.outputs.forEach(t => { e[t.name] = ""; })), e; }
function nc(n, e) { let t = null, s = { name: n.name, type: n.type, typeArgumentCount: n.typeArgumentCount, deps: [], target: At.Injectable }; if (n.useClass !== void 0) {
    let a = n.useClass.expression.isEquivalent(n.type.value), l;
    n.deps !== void 0 && (l = n.deps), l !== void 0 ? t = An(ae(E({}, s), { delegate: n.useClass.expression, delegateDeps: l, delegateType: Ii.Class })) : a ? t = An(s) : t = { statements: [], expression: sc(n.type.value, n.useClass.expression, e) };
}
else
    n.useFactory !== void 0 ? n.deps !== void 0 ? t = An(ae(E({}, s), { delegate: n.useFactory, delegateDeps: n.deps || [], delegateType: Ii.Function })) : t = { statements: [], expression: se([], n.useFactory.callFn([])) } : n.useValue !== void 0 ? t = An(ae(E({}, s), { expression: n.useValue.expression })) : n.useExisting !== void 0 ? t = An(ae(E({}, s), { expression: y(h.inject).callFn([n.useExisting.expression]) })) : t = { statements: [], expression: sc(n.type.value, n.type.value, e) }; let r = n.type.value, i = new ie; return i.set("token", r), i.set("factory", t.expression), n.providedIn.expression.value !== null && i.set("providedIn", us(n.providedIn)), { expression: y(h.ɵɵdefineInjectable).callFn([i.toLiteralMap()], void 0, !0), type: th(n), statements: t.statements }; }
function th(n) { return new He(y(h.InjectableDeclaration, [qo(n.type.type, n.typeArgumentCount)])); }
function sc(n, e, t) { if (n.node === e.node)
    return e.prop("\u0275fac"); if (!t)
    return rc(e); let s = y(h.resolveForwardRef).callFn([e]); return rc(s); }
function rc(n) { let e = new Y("__ngFactoryType__", Be); return se([e], n.prop("\u0275fac").callFn([N(e.name)])); }
var Yd = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function Qd(n, e) { if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${n}' to be an array, [start, end].`); if (e != null) {
    let t = e[0], s = e[1];
    Yd.forEach(r => { if (r.test(t) || r.test(s))
        throw new Error(`['${t}', '${s}'] contains unusable interpolation symbol.`); });
} }
var Ji = class n {
    start;
    end;
    static fromArray(e) { return e ? (Qd("interpolation", e), new n(e[0], e[1])) : et; }
    constructor(e, t) { this.start = e, this.end = t; }
}, et = new Ji("{{", "}}"), nh = new Set(["switch"]), Se = 0, Zd = 8, Au = 9, Bn = 10, sh = 11, rh = 12, _u = 13, ih = 32, tl = 33, Fr = 34, oh = 35, Wo = 36, Jd = 37, Ki = 38, $r = 39, Ut = 40, ft = 41, Kd = 42, ah = 43, st = 44, eo = 45, os = 46, $t = 47, rn = 58, $e = 59, cs = 60, In = 61, tn = 62, ic = 63, Tu = 48, em = 55, lh = 57, qs = 65, tm = 69, nm = 70, sm = 88, jo = 90, ms = 91, gs = 92, ps = 93, rm = 94, ai = 95, Yn = 97, im = 98, om = 101, bu = 102, uh = 110, ch = 114, ph = 116, hh = 117, fh = 118, dh = 120, li = 122, pt = 123, oc = 124, Pe = 125, mh = 160, Jo = 64, nl = 96;
function Or(n) { return n >= Au && n <= ih || n == mh; }
function Ct(n) { return Tu <= n && n <= lh; }
function Vr(n) { return n >= Yn && n <= li || n >= qs && n <= jo; }
function am(n) { return n >= Yn && n <= bu || n >= qs && n <= nm || Ct(n); }
function ku(n) { return n === Bn || n === _u; }
function ac(n) { return Tu <= n && n <= em; }
function or(n) { return n === $r || n === Fr || n === nl; }
var Qn = class n {
    file;
    offset;
    line;
    col;
    constructor(e, t, s, r) { this.file = e, this.offset = t, this.line = s, this.col = r; }
    toString() { return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url; }
    moveBy(e) { let t = this.file.content, s = t.length, r = this.offset, i = this.line, o = this.col; for (; r > 0 && e < 0;)
        if (r--, e++, t.charCodeAt(r) == Bn) {
            i--;
            let l = t.substring(0, r - 1).lastIndexOf(String.fromCharCode(Bn));
            o = l > 0 ? r - l : r;
        }
        else
            o--; for (; r < s && e > 0;) {
        let a = t.charCodeAt(r);
        r++, e--, a == Bn ? (i++, o = 0) : o++;
    } return new n(this.file, r, i, o); }
    getContext(e, t) {
        let s = this.file.content, r = this.offset;
        if (r != null) {
            r > s.length - 1 && (r = s.length - 1);
            let i = r, o = 0, a = 0;
            for (; o < e && r > 0 && (r--, o++, !(s[r] == `
` && ++a == t));)
                ;
            for (o = 0, a = 0; o < e && i < s.length - 1 && (i++, o++, !(s[i] == `
` && ++a == t));)
                ;
            return { before: s.substring(r, this.offset), after: s.substring(this.offset, i + 1) };
        }
        return null;
    }
}, qr = class {
    content;
    url;
    constructor(e, t) { this.content = e, this.url = t; }
}, R = class {
    start;
    end;
    fullStart;
    details;
    constructor(e, t, s = e, r = null) { this.start = e, this.end = t, this.fullStart = s, this.details = r; }
    toString() { return this.start.file.content.substring(this.start.offset, this.end.offset); }
}, an = function (n) { return n[n.WARNING = 0] = "WARNING", n[n.ERROR = 1] = "ERROR", n; }(an || {}), L = class {
    span;
    msg;
    level;
    relatedError;
    constructor(e, t, s = an.ERROR, r) { this.span = e, this.msg = t, this.level = s, this.relatedError = r; }
    contextualMessage() { let e = this.span.start.getContext(100, 3); return e ? `${this.msg} ("${e.before}[${an[this.level]} ->]${e.after}")` : this.msg; }
    toString() { let e = this.span.details ? `, ${this.span.details}` : ""; return `${this.contextualMessage()}: ${this.span.start}${e}`; }
};
function lm(n, e, t) { let s = `in ${n} ${e} in ${t}`, r = new qr("", s); return new R(new Qn(r, -1, -1, -1), new Qn(r, -1, -1, -1)); }
var um = 0;
function cm(n) { if (!n || !n.reference)
    return null; let e = n.reference; if (e.__anonymousType)
    return e.__anonymousType; if (e.__forward_ref__)
    return "__forward_ref__"; let t = jp(e); return t.indexOf("(") >= 0 ? (t = `anonymous_${um++}`, e.__anonymousType = t) : t = ar(t), t; }
function ar(n) { return n.replace(/\W/g, "_"); }
var lc = "(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})", sl = class extends Ba {
    constructor() { super(!1); }
    visitWrappedNodeExpr(e, t) { throw new Error("Cannot emit a WrappedNodeExpr in Javascript."); }
    visitDeclareVarStmt(e, t) { return t.print(e, `var ${e.name}`), e.value && (t.print(e, " = "), e.value.visitExpression(this, t)), t.println(e, ";"), null; }
    visitTaggedTemplateLiteralExpr(e, t) { let s = e.template.elements; return e.tag.visitExpression(this, t), t.print(e, `(${lc}(`), t.print(e, `[${s.map(r => bn(r.text, !1)).join(", ")}], `), t.print(e, `[${s.map(r => bn(r.rawText, !1)).join(", ")}])`), e.template.expressions.forEach(r => { t.print(e, ", "), r.visitExpression(this, t); }), t.print(e, ")"), null; }
    visitTemplateLiteralExpr(e, t) { t.print(e, "`"); for (let s = 0; s < e.elements.length; s++) {
        e.elements[s].visitExpression(this, t);
        let r = s < e.expressions.length ? e.expressions[s] : null;
        r !== null && (t.print(r, "${"), r.visitExpression(this, t), t.print(r, "}"));
    } t.print(e, "`"); }
    visitTemplateLiteralElementExpr(e, t) { return t.print(e, e.rawText), null; }
    visitFunctionExpr(e, t) { return t.print(e, `function${e.name ? " " + e.name : ""}(`), this._visitParams(e.params, t), t.println(e, ") {"), t.incIndent(), this.visitAllStatements(e.statements, t), t.decIndent(), t.print(e, "}"), null; }
    visitArrowFunctionExpr(e, t) { if (t.print(e, "("), this._visitParams(e.params, t), t.print(e, ") =>"), Array.isArray(e.body))
        t.println(e, "{"), t.incIndent(), this.visitAllStatements(e.body, t), t.decIndent(), t.print(e, "}");
    else {
        let s = e.body instanceof gt;
        s && t.print(e, "("), e.body.visitExpression(this, t), s && t.print(e, ")");
    } return null; }
    visitDeclareFunctionStmt(e, t) { return t.print(e, `function ${e.name}(`), this._visitParams(e.params, t), t.println(e, ") {"), t.incIndent(), this.visitAllStatements(e.statements, t), t.decIndent(), t.println(e, "}"), null; }
    visitLocalizedString(e, t) { t.print(e, `$localize(${lc}(`); let s = [e.serializeI18nHead()]; for (let r = 1; r < e.messageParts.length; r++)
        s.push(e.serializeI18nTemplatePart(r)); return t.print(e, `[${s.map(r => bn(r.cooked, !1)).join(", ")}], `), t.print(e, `[${s.map(r => bn(r.raw, !1)).join(", ")}])`), e.expressions.forEach(r => { t.print(e, ", "), r.visitExpression(this, t); }), t.print(e, ")"), null; }
    _visitParams(e, t) { this.visitAllObjects(s => t.print(null, s.name), e, t, ","); }
}, ci;
function pm() { if (ci === void 0) {
    let n = Si.trustedTypes;
    if (ci = null, n)
        try {
            ci = n.createPolicy("angular#unsafe-jit", { createScript: e => e });
        }
        catch { }
} return ci; }
function hm(n) { return pm()?.createScript(n) || n; }
function uc(...n) {
    if (!Si.trustedTypes)
        return new Function(...n);
    let e = n.slice(0, -1).join(","), t = n[n.length - 1], s = `(function anonymous(${e}
) { ${t}
})`, r = Si.eval(hm(s));
    return r.bind === void 0 ? new Function(...n) : (r.toString = () => s, r.bind(Si));
}
var rl = class {
    evaluateStatements(e, t, s, r) { let i = new il(s), o = La.createRoot(); return t.length > 0 && !fm(t[0]) && (t = [d("use strict").toStmt(), ...t]), i.visitAllStatements(t, o), i.createReturnStmt(o), this.evaluateCode(e, o, i.getArgs(), r); }
    evaluateCode(e, t, s, r) {
        let i = `"use strict";${t.toSource()}
//# sourceURL=${e}`, o = [], a = [];
        for (let u in s)
            a.push(s[u]), o.push(u);
        if (r) {
            let u = uc(...o.concat("return null;")).toString(), p = u.slice(0, u.indexOf("return null;")).split(`
`).length - 1;
            i += `
${t.toSourceMapGenerator(e, p).toJsComment()}`;
        }
        let l = uc(...o.concat(i));
        return this.executeFunction(l, a);
    }
    executeFunction(e, t) { return e(...t); }
}, il = class extends sl {
    refResolver;
    _evalArgNames = [];
    _evalArgValues = [];
    _evalExportedVars = [];
    constructor(e) { super(), this.refResolver = e; }
    createReturnStmt(e) { new ye(new gt(this._evalExportedVars.map(s => new Un(s, N(s), !1)))).visitStatement(this, e); }
    getArgs() { let e = {}; for (let t = 0; t < this._evalArgNames.length; t++)
        e[this._evalArgNames[t]] = this._evalArgValues[t]; return e; }
    visitExternalExpr(e, t) { return this._emitReferenceToExternal(e, this.refResolver.resolveExternalReference(e.value), t), null; }
    visitWrappedNodeExpr(e, t) { return this._emitReferenceToExternal(e, e.node, t), null; }
    visitDeclareVarStmt(e, t) { return e.hasModifier(oe.Exported) && this._evalExportedVars.push(e.name), super.visitDeclareVarStmt(e, t); }
    visitDeclareFunctionStmt(e, t) { return e.hasModifier(oe.Exported) && this._evalExportedVars.push(e.name), super.visitDeclareFunctionStmt(e, t); }
    _emitReferenceToExternal(e, t, s) { let r = this._evalArgValues.indexOf(t); if (r === -1) {
        r = this._evalArgValues.length, this._evalArgValues.push(t);
        let i = cm({ reference: t }) || "val";
        this._evalArgNames.push(`jit_${i}_${r}`);
    } s.print(e, this._evalArgNames[r]); }
};
function fm(n) { return n.isEquivalent(d("use strict").toStmt()); }
function cc(n) { let e = new ie; n.providers !== null && e.set("providers", n.providers), n.imports.length > 0 && e.set("imports", B(n.imports)); let t = y(h.defineInjector).callFn([e.toLiteralMap()], void 0, !0), s = gh(n); return { expression: t, type: s, statements: [] }; }
function gh(n) { return new He(y(h.InjectorDeclaration, [new He(n.type.type)])); }
var ol = class {
    context;
    constructor(e) { this.context = e; }
    resolveExternalReference(e) { if (e.moduleName !== "@angular/core")
        throw new Error(`Cannot resolve external reference to ${e.moduleName}, only references to @angular/core are supported.`); if (!this.context.hasOwnProperty(e.name))
        throw new Error(`No value provided for @angular/core symbol '${e.name}'.`); return this.context[e.name]; }
}, to = function (n) { return n[n.Inline = 0] = "Inline", n[n.SideEffect = 1] = "SideEffect", n[n.Omit = 2] = "Omit", n; }(to || {}), Vt = function (n) { return n[n.Global = 0] = "Global", n[n.Local = 1] = "Local", n; }(Vt || {});
function dm(n) { let e = [], t = new ie; if (t.set("type", n.type.value), n.kind === Vt.Global && n.bootstrap.length > 0 && t.set("bootstrap", ht(n.bootstrap, n.containsForwardDecls)), n.selectorScopeMode === to.Inline)
    n.declarations.length > 0 && t.set("declarations", ht(n.declarations, n.containsForwardDecls)), n.imports.length > 0 && t.set("imports", ht(n.imports, n.containsForwardDecls)), n.exports.length > 0 && t.set("exports", ht(n.exports, n.containsForwardDecls));
else if (n.selectorScopeMode === to.SideEffect) {
    let i = gm(n);
    i !== null && e.push(i);
} n.schemas !== null && n.schemas.length > 0 && t.set("schemas", B(n.schemas.map(i => i.value))), n.id !== null && (t.set("id", n.id), e.push(y(h.registerNgModuleType).callFn([n.type.value, n.id]).toStmt())); let s = y(h.defineNgModule).callFn([t.toLiteralMap()], void 0, !0), r = vh(n); return { expression: s, type: r, statements: e }; }
function mm(n) { let e = new ie; return e.set("type", new V(n.type)), n.bootstrap !== void 0 && e.set("bootstrap", new V(n.bootstrap)), n.declarations !== void 0 && e.set("declarations", new V(n.declarations)), n.imports !== void 0 && e.set("imports", new V(n.imports)), n.exports !== void 0 && e.set("exports", new V(n.exports)), n.schemas !== void 0 && e.set("schemas", new V(n.schemas)), n.id !== void 0 && e.set("id", new V(n.id)), y(h.defineNgModule).callFn([e.toLiteralMap()]); }
function vh(n) { if (n.kind === Vt.Local)
    return new He(n.type.value); let { type: e, declarations: t, exports: s, imports: r, includeImportTypes: i, publicDeclarationTypes: o } = n; return new He(y(h.NgModuleDeclaration, [new He(e.type), o === null ? Ko(t) : vm(o), i ? Ko(r) : mt, Ko(s)])); }
function gm(n) { let e = new ie; if (n.kind === Vt.Global ? n.declarations.length > 0 && e.set("declarations", ht(n.declarations, n.containsForwardDecls)) : n.declarationsExpression && e.set("declarations", n.declarationsExpression), n.kind === Vt.Global ? n.imports.length > 0 && e.set("imports", ht(n.imports, n.containsForwardDecls)) : n.importsExpression && e.set("imports", n.importsExpression), n.kind === Vt.Global ? n.exports.length > 0 && e.set("exports", ht(n.exports, n.containsForwardDecls)) : n.exportsExpression && e.set("exports", n.exportsExpression), n.kind === Vt.Local && n.bootstrapExpression && e.set("bootstrap", n.bootstrapExpression), Object.keys(e.values).length === 0)
    return null; let t = new Ie(y(h.setNgModuleScope), [n.type.value, e.toLiteralMap()]), s = kd(t), r = new Ht([], [s.toStmt()]); return new Ie(r, []).toStmt(); }
function Ko(n) { let e = n.map(t => Vs(t.type)); return n.length > 0 ? me(B(e)) : mt; }
function vm(n) { let e = n.map(t => Vs(t)); return n.length > 0 ? me(B(e)) : mt; }
function pc(n) { let e = []; e.push({ key: "name", value: d(n.pipeName), quoted: !1 }), e.push({ key: "type", value: n.type.value, quoted: !1 }), e.push({ key: "pure", value: d(n.pure), quoted: !1 }), n.isStandalone === !1 && e.push({ key: "standalone", value: d(!1), quoted: !1 }); let t = y(h.definePipe).callFn([ue(e)], void 0, !0), s = wh(n); return { expression: t, type: s, statements: [] }; }
function wh(n) { return new He(y(h.PipeDeclaration, [qo(n.type.type, n.typeArgumentCount), new He(new ge(n.pipeName)), new He(new ge(n.isStandalone))])); }
var Mn = function (n) { return n[n.Directive = 0] = "Directive", n[n.Pipe = 1] = "Pipe", n[n.NgModule = 2] = "NgModule", n; }(Mn || {}), wm = new Set(["inherit", "initial", "revert", "unset", "alternate", "alternate-reverse", "normal", "reverse", "backwards", "both", "forwards", "none", "paused", "running", "ease", "ease-in", "ease-in-out", "ease-out", "linear", "step-start", "step-end", "end", "jump-both", "jump-end", "jump-none", "jump-start", "start"]), Em = ["@media", "@supports", "@document", "@layer", "@container", "@scope", "@starting-style"], no = class {
    shimCssText(e, t, s = "") {
        let r = [];
        e = e.replace(Pm, a => {
            if (a.match(Lm))
                r.push(a);
            else {
                let l = a.match(Dm);
                r.push((l?.join("") ?? "") + `
`);
            }
            return Iu;
        }), e = this._insertDirectives(e);
        let i = this._scopeCssText(e, t, s), o = 0;
        return i.replace(Bm, () => r[o++]);
    }
    _insertDirectives(e) { return e = this._insertPolyfillDirectivesInCssText(e), this._insertPolyfillRulesInCssText(e); }
    _scopeKeyframesRelatedCss(e, t) { let s = new Set, r = pi(e, i => this._scopeLocalKeyframeDeclarations(i, t, s)); return pi(r, i => this._scopeAnimationRule(i, t, s)); }
    _scopeLocalKeyframeDeclarations(e, t, s) { return ae(E({}, e), { selector: e.selector.replace(/(^@(?:-webkit-)?keyframes(?:\s+))(['"]?)(.+)\2(\s*)$/, (r, i, o, a, l) => (s.add(dc(a, o)), `${i}${o}${t}_${a}${o}${l}`)) }); }
    _scopeAnimationKeyframe(e, t, s) { return e.replace(/^(\s*)(['"]?)(.+?)\2(\s*)$/, (r, i, o, a, l) => (a = `${s.has(dc(a, o)) ? t + "_" : ""}${a}`, `${i}${o}${a}${o}${l}`)); }
    _animationDeclarationKeyframesRe = /(^|\s+|,)(?:(?:(['"])((?:\\\\|\\\2|(?!\2).)+)\2)|(-?[A-Za-z][\w\-]*))(?=[,\s]|$)/g;
    _scopeAnimationRule(e, t, s) { let r = e.content.replace(/((?:^|\s+|;)(?:-webkit-)?animation\s*:\s*),*([^;]+)/g, (i, o, a) => o + a.replace(this._animationDeclarationKeyframesRe, (l, u, p = "", f, g) => f ? `${u}${this._scopeAnimationKeyframe(`${p}${f}${p}`, t, s)}` : wm.has(g) ? l : `${u}${this._scopeAnimationKeyframe(g, t, s)}`)); return r = r.replace(/((?:^|\s+|;)(?:-webkit-)?animation-name(?:\s*):(?:\s*))([^;]+)/g, (i, o, a) => `${o}${a.split(",").map(l => this._scopeAnimationKeyframe(l, t, s)).join(",")}`), ae(E({}, e), { content: r }); }
    _insertPolyfillDirectivesInCssText(e) { return e.replace(xm, function (...t) { return t[2] + "{"; }); }
    _insertPolyfillRulesInCssText(e) { return e.replace(ym, (...t) => { let s = t[0].replace(t[1], "").replace(t[2], ""); return t[4] + s; }); }
    _scopeCssText(e, t, s) {
        let r = this._extractUnscopedRulesFromCssText(e);
        return e = this._insertPolyfillHostInCssText(e), e = this._convertColonHost(e), e = this._convertColonHostContext(e), e = this._convertShadowDOMSelectors(e), t && (e = this._scopeKeyframesRelatedCss(e, t), e = this._scopeSelectors(e, t, s)), e = e + `
` + r, e.trim();
    }
    _extractUnscopedRulesFromCssText(e) {
        let t = "", s;
        for (hc.lastIndex = 0; (s = hc.exec(e)) !== null;) {
            let r = s[0].replace(s[2], "").replace(s[1], s[4]);
            t += r + `

`;
        }
        return t;
    }
    _convertColonHost(e) { return e.replace(Cm, (t, s, r) => { if (s) {
        let i = [], o = s.split(",").map(a => a.trim());
        for (let a of o) {
            if (!a)
                break;
            let l = nn + a.replace(so, "") + r;
            i.push(l);
        }
        return i.join(",");
    }
    else
        return nn + r; }); }
    _convertColonHostContext(e) { let t = e.length, s = 0, r = 0, i = ""; for (let o = 0; o < t; o++) {
        let a = e[o];
        if (a === "," && s === 0) {
            i += this._convertColonHostContextInSelectorPart(e.slice(r, o)) + ",", r = o + 1;
            continue;
        }
        if (o === t - 1) {
            i += this._convertColonHostContextInSelectorPart(e.slice(r));
            break;
        }
        a === "(" ? s++ : a === ")" && s--;
    } return i; }
    _convertColonHostContextInSelectorPart(e) { return e.replace(Am, (t, s) => { let r = [[]], i; for (; i = _m.exec(t);) {
        let o = (i[1] ?? "").trim().split(",").map(l => l.trim()).filter(l => l !== ""), a = r.length;
        jm(r, o.length);
        for (let l = 0; l < o.length; l++)
            for (let u = 0; u < a; u++)
                r[u + l * a].push(o[l]);
        t = i[2];
    } return r.map(o => Wm(o, t, s)).join(", "); }); }
    _convertShadowDOMSelectors(e) { return bm.reduce((t, s) => t.replace(s, " "), e); }
    _scopeSelectors(e, t, s) { return pi(e, r => { let i = r.selector, o = r.content; return r.selector[0] !== "@" ? i = this._scopeSelector({ selector: i, scopeSelector: t, hostSelector: s, isParentSelector: !0 }) : Em.some(a => r.selector.startsWith(a)) ? o = this._scopeSelectors(r.content, t, s) : (r.selector.startsWith("@font-face") || r.selector.startsWith("@page")) && (o = this._stripScopingSelectors(r.content)), new Hr(i, o); }); }
    _stripScopingSelectors(e) { return pi(e, t => { let s = t.selector.replace(fc, " ").replace(ea, " "); return new Hr(s, t.content); }); }
    _safeSelector;
    _shouldScopeIndicator;
    _scopeSelector({ selector: e, scopeSelector: t, hostSelector: s, isParentSelector: r = !1 }) { let i = / ?,(?!(?:[^)(]*(?:\([^)(]*(?:\([^)(]*(?:\([^)(]*\)[^)(]*)*\)[^)(]*)*\)[^)(]*)*\))) ?/; return e.split(i).map(o => o.split(fc)).map(o => { let [a, ...l] = o; return [(p => this._selectorNeedsScoping(p, t) ? this._applySelectorScope({ selector: p, scopeSelector: t, hostSelector: s, isParentSelector: r }) : p)(a), ...l].join(" "); }).join(", "); }
    _selectorNeedsScoping(e, t) { return !this._makeScopeMatcher(t).test(e); }
    _makeScopeMatcher(e) { let t = /\[/g, s = /\]/g; return e = e.replace(t, "\\[").replace(s, "\\]"), new RegExp("^(" + e + ")" + km, "m"); }
    _applySimpleSelectorScope(e, t, s) { if (hs.lastIndex = 0, hs.test(e)) {
        let r = `[${s}]`, i = e;
        for (; i.match(ea);)
            i = i.replace(ea, (o, a) => a.replace(/([^:\)]*)(:*)(.*)/, (l, u, p, f) => u + r + p + f));
        return i.replace(hs, r);
    } return t + " " + e; }
    _applySelectorScope({ selector: e, scopeSelector: t, hostSelector: s, isParentSelector: r }) { let i = /\[is=([^\]]*)\]/g; t = t.replace(i, (_, ...x) => x[0]); let o = `[${t}]`, a = _ => { let x = _.trim(); if (!x)
        return _; if (_.includes(nn)) {
        if (x = this._applySimpleSelectorScope(_, t, s), !_.match(Tm)) {
            let [T, M, Z, te] = x.match(/([^:]*)(:*)([\s\S]*)/);
            x = M + o + Z + te;
        }
    }
    else {
        let T = _.replace(hs, "");
        if (T.length > 0) {
            let M = T.match(/([^:]*)(:*)([\s\S]*)/);
            M && (x = M[1] + o + M[2] + M[3]);
        }
    } return x; }, l = _ => { let x = "", T = [], M; for (; (M = Ys.exec(_)) !== null;) {
        let Z = 1, te = Ys.lastIndex;
        for (; te < _.length;) {
            let Te = _[te];
            if (te++, Te === "(") {
                Z++;
                continue;
            }
            if (Te === ")") {
                if (Z--, Z === 0)
                    break;
                continue;
            }
        }
        T.push(`${M[0]}${_.slice(Ys.lastIndex, te)}`), Ys.lastIndex = te;
    } return T.join("") === _ ? x = T.map(Z => { let [te] = Z.match(Ys) ?? [], Te = Z.slice(te?.length, -1); Te.includes(nn) && (this._shouldScopeIndicator = !0); let es = this._scopeSelector({ selector: Te, scopeSelector: t, hostSelector: s }); return `${te}${es})`; }).join("") : (this._shouldScopeIndicator = this._shouldScopeIndicator || _.includes(nn), x = this._shouldScopeIndicator ? a(_) : _), x; }; r && (this._safeSelector = new al(e), e = this._safeSelector.content()); let u = "", p = 0, f, g = /( |>|\+|~(?!=))(?!([^)(]*(?:\([^)(]*(?:\([^)(]*(?:\([^)(]*\)[^)(]*)*\)[^)(]*)*\)[^)(]*)*\)))\s*/g, v = e.includes(nn); for ((r || this._shouldScopeIndicator) && (this._shouldScopeIndicator = !v); (f = g.exec(e)) !== null;) {
        let _ = f[1], x = e.slice(p, f.index);
        if (x.match(/__esc-ph-(\d+)__/) && e[f.index + 1]?.match(/[a-fA-F\d]/))
            continue;
        let T = l(x);
        u += `${T} ${_} `, p = g.lastIndex;
    } let S = e.substring(p); return u += l(S), this._safeSelector.restore(u); }
    _insertPolyfillHostInCssText(e) { return e.replace(Nm, Eh).replace(Im, so); }
}, al = class {
    placeholders = [];
    index = 0;
    _content;
    constructor(e) { e = this._escapeRegexMatches(e, /(\[[^\]]*\])/g), e = e.replace(/(\\.)/g, (t, s) => { let r = `__esc-ph-${this.index}__`; return this.placeholders.push(s), this.index++, r; }), this._content = e.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (t, s, r) => { let i = `__ph-${this.index}__`; return this.placeholders.push(r), this.index++, s + i; }); }
    restore(e) { return e.replace(/__(?:ph|esc-ph)-(\d+)__/g, (t, s) => this.placeholders[+s]); }
    content() { return this._content; }
    _escapeRegexMatches(e, t) { return e.replace(t, (s, r) => { let i = `__ph-${this.index}__`; return this.placeholders.push(r), this.index++, i; }); }
}, Sm = "(:(where|is)\\()?", Ys = /:(where|is)\(/gi, xm = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim, ym = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim, hc = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim, so = "-shadowcsshost", Eh = "-shadowcsscontext", Sh = "(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))", Cm = new RegExp(so + Sh + "?([^,{]*)", "gim"), xh = Eh + Sh + "?([^{]*)", Am = new RegExp(`${Sm}(${xh})`, "gim"), _m = new RegExp(xh, "im"), nn = so + "-no-combinator", Tm = new RegExp(`${nn}(?![^(]*\\))`, "g"), ea = /-shadowcsshost-no-combinator([^\s,]*)/, bm = [/::shadow/g, /::content/g, /\/shadow-deep\//g, /\/shadow\//g], fc = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g, km = "([>\\s~+[.,{:][\\s\\S]*)?$", hs = /-shadowcsshost/gim, Im = /:host/gim, Nm = /:host-context/gim, Dm = /\r?\n/g, Pm = /\/\*[\s\S]*?\*\//g, Lm = /\/\*\s*#\s*source(Mapping)?URL=/g, Iu = "%COMMENT%", Bm = new RegExp(Iu, "g"), ta = "%BLOCK%", Mm = new RegExp(`(\\s*(?:${Iu}\\s*)*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))`, "g"), Rm = new Map([["{", "}"]]), yh = "%COMMA_IN_PLACEHOLDER%", Ch = "%SEMI_IN_PLACEHOLDER%", Ah = "%COLON_IN_PLACEHOLDER%", Fm = new RegExp(yh, "g"), $m = new RegExp(Ch, "g"), Om = new RegExp(Ah, "g"), Hr = class {
    selector;
    content;
    constructor(e, t) { this.selector = e, this.content = t; }
};
function pi(n, e) { let t = Hm(n), s = Vm(t, Rm, ta), r = 0, i = s.escapedString.replace(Mm, (...o) => { let a = o[2], l = "", u = o[4], p = ""; u && u.startsWith("{" + ta) && (l = s.blocks[r++], u = u.substring(ta.length + 1), p = "{"); let f = e(new Hr(a, l)); return `${o[1]}${f.selector}${o[3]}${p}${f.content}${u}`; }); return Um(i); }
var ll = class {
    escapedString;
    blocks;
    constructor(e, t) { this.escapedString = e, this.blocks = t; }
};
function Vm(n, e, t) { let s = [], r = [], i = 0, o = 0, a = -1, l, u; for (let p = 0; p < n.length; p++) {
    let f = n[p];
    f === "\\" ? p++ : f === u ? (i--, i === 0 && (r.push(n.substring(a, p)), s.push(t), o = p, a = -1, l = u = void 0)) : f === l ? i++ : i === 0 && e.has(f) && (l = f, u = e.get(f), i = 1, a = p + 1, s.push(n.substring(o, a)));
} return a !== -1 ? (r.push(n.substring(a)), s.push(t)) : s.push(n.substring(o)), new ll(s.join(""), r); }
var qm = { ";": Ch, ",": yh, ":": Ah };
function Hm(n) { let e = n, t = null; for (let s = 0; s < e.length; s++) {
    let r = e[s];
    if (r === "\\")
        s++;
    else if (t !== null) {
        if (r === t)
            t = null;
        else {
            let i = qm[r];
            i && (e = `${e.substr(0, s)}${i}${e.substr(s + 1)}`, s += i.length - 1);
        }
    }
    else
        (r === "'" || r === "\"") && (t = r);
} return e; }
function Um(n) { let e = n.replace(Fm, ","); return e = e.replace($m, ";"), e = e.replace(Om, ":"), e; }
function dc(n, e) { return e ? n.replace(/((?:^|[^\\])(?:\\\\)*)\\(?=['"])/g, "$1") : n; }
function Wm(n, e, t = "") { let s = nn; hs.lastIndex = 0; let r = hs.test(e); if (n.length === 0)
    return s + e; let i = [n.pop() || ""]; for (; n.length > 0;) {
    let o = i.length, a = n.pop();
    for (let l = 0; l < o; l++) {
        let u = i[l];
        i[o * 2 + l] = u + " " + a, i[o + l] = a + " " + u, i[l] = a + u;
    }
} return i.map(o => r ? `${t}${o}${e}` : `${t}${o}${s}${e}, ${t}${o} ${s}${e}`).join(","); }
function jm(n, e) { let t = n.length; for (let s = 1; s < e; s++)
    for (let r = 0; r < t; r++)
        n[r + s * t] = n[r].slice(0); }
var c = function (n) { return n[n.ListEnd = 0] = "ListEnd", n[n.Statement = 1] = "Statement", n[n.Variable = 2] = "Variable", n[n.ElementStart = 3] = "ElementStart", n[n.Element = 4] = "Element", n[n.Template = 5] = "Template", n[n.ElementEnd = 6] = "ElementEnd", n[n.ContainerStart = 7] = "ContainerStart", n[n.Container = 8] = "Container", n[n.ContainerEnd = 9] = "ContainerEnd", n[n.DisableBindings = 10] = "DisableBindings", n[n.Conditional = 11] = "Conditional", n[n.EnableBindings = 12] = "EnableBindings", n[n.Text = 13] = "Text", n[n.Listener = 14] = "Listener", n[n.InterpolateText = 15] = "InterpolateText", n[n.Binding = 16] = "Binding", n[n.Property = 17] = "Property", n[n.StyleProp = 18] = "StyleProp", n[n.ClassProp = 19] = "ClassProp", n[n.StyleMap = 20] = "StyleMap", n[n.ClassMap = 21] = "ClassMap", n[n.Advance = 22] = "Advance", n[n.Pipe = 23] = "Pipe", n[n.Attribute = 24] = "Attribute", n[n.ExtractedAttribute = 25] = "ExtractedAttribute", n[n.Defer = 26] = "Defer", n[n.DeferOn = 27] = "DeferOn", n[n.DeferWhen = 28] = "DeferWhen", n[n.I18nMessage = 29] = "I18nMessage", n[n.HostProperty = 30] = "HostProperty", n[n.Namespace = 31] = "Namespace", n[n.ProjectionDef = 32] = "ProjectionDef", n[n.Projection = 33] = "Projection", n[n.RepeaterCreate = 34] = "RepeaterCreate", n[n.Repeater = 35] = "Repeater", n[n.TwoWayProperty = 36] = "TwoWayProperty", n[n.TwoWayListener = 37] = "TwoWayListener", n[n.DeclareLet = 38] = "DeclareLet", n[n.StoreLet = 39] = "StoreLet", n[n.I18nStart = 40] = "I18nStart", n[n.I18n = 41] = "I18n", n[n.I18nEnd = 42] = "I18nEnd", n[n.I18nExpression = 43] = "I18nExpression", n[n.I18nApply = 44] = "I18nApply", n[n.IcuStart = 45] = "IcuStart", n[n.IcuEnd = 46] = "IcuEnd", n[n.IcuPlaceholder = 47] = "IcuPlaceholder", n[n.I18nContext = 48] = "I18nContext", n[n.I18nAttributes = 49] = "I18nAttributes", n[n.SourceLocation = 50] = "SourceLocation", n; }(c || {}), k = function (n) { return n[n.LexicalRead = 0] = "LexicalRead", n[n.Context = 1] = "Context", n[n.TrackContext = 2] = "TrackContext", n[n.ReadVariable = 3] = "ReadVariable", n[n.NextContext = 4] = "NextContext", n[n.Reference = 5] = "Reference", n[n.StoreLet = 6] = "StoreLet", n[n.ContextLetReference = 7] = "ContextLetReference", n[n.GetCurrentView = 8] = "GetCurrentView", n[n.RestoreView = 9] = "RestoreView", n[n.ResetView = 10] = "ResetView", n[n.PureFunctionExpr = 11] = "PureFunctionExpr", n[n.PureFunctionParameterExpr = 12] = "PureFunctionParameterExpr", n[n.PipeBinding = 13] = "PipeBinding", n[n.PipeBindingVariadic = 14] = "PipeBindingVariadic", n[n.SafePropertyRead = 15] = "SafePropertyRead", n[n.SafeKeyedRead = 16] = "SafeKeyedRead", n[n.SafeInvokeFunction = 17] = "SafeInvokeFunction", n[n.SafeTernaryExpr = 18] = "SafeTernaryExpr", n[n.EmptyExpr = 19] = "EmptyExpr", n[n.AssignTemporaryExpr = 20] = "AssignTemporaryExpr", n[n.ReadTemporaryExpr = 21] = "ReadTemporaryExpr", n[n.SlotLiteralExpr = 22] = "SlotLiteralExpr", n[n.ConditionalCase = 23] = "ConditionalCase", n[n.ConstCollected = 24] = "ConstCollected", n[n.TwoWayBindingSet = 25] = "TwoWayBindingSet", n; }(k || {}), tt = function (n) { return n[n.None = 0] = "None", n[n.AlwaysInline = 1] = "AlwaysInline", n; }(tt || {}), we = function (n) { return n[n.Context = 0] = "Context", n[n.Identifier = 1] = "Identifier", n[n.SavedView = 2] = "SavedView", n[n.Alias = 3] = "Alias", n; }(we || {}), Xe = function (n) { return n[n.Normal = 0] = "Normal", n[n.TemplateDefinitionBuilder = 1] = "TemplateDefinitionBuilder", n; }(Xe || {}), I = function (n) { return n[n.Attribute = 0] = "Attribute", n[n.ClassName = 1] = "ClassName", n[n.StyleProperty = 2] = "StyleProperty", n[n.Property = 3] = "Property", n[n.Template = 4] = "Template", n[n.I18n = 5] = "I18n", n[n.Animation = 6] = "Animation", n[n.TwoWayProperty = 7] = "TwoWayProperty", n; }(I || {}), Ur = function (n) { return n[n.Creation = 0] = "Creation", n[n.Postproccessing = 1] = "Postproccessing", n; }(Ur || {}), Hs = function (n) { return n[n.I18nText = 0] = "I18nText", n[n.I18nAttribute = 1] = "I18nAttribute", n; }(Hs || {}), J = function (n) { return n[n.None = 0] = "None", n[n.ElementTag = 1] = "ElementTag", n[n.TemplateTag = 2] = "TemplateTag", n[n.OpenTag = 4] = "OpenTag", n[n.CloseTag = 8] = "CloseTag", n[n.ExpressionIndex = 16] = "ExpressionIndex", n; }(J || {}), Ce = function (n) { return n[n.HTML = 0] = "HTML", n[n.SVG = 1] = "SVG", n[n.Math = 2] = "Math", n; }(Ce || {}), X = function (n) { return n[n.Idle = 0] = "Idle", n[n.Immediate = 1] = "Immediate", n[n.Timer = 2] = "Timer", n[n.Hover = 3] = "Hover", n[n.Interaction = 4] = "Interaction", n[n.Viewport = 5] = "Viewport", n[n.Never = 6] = "Never", n; }(X || {}), Nn = function (n) { return n[n.RootI18n = 0] = "RootI18n", n[n.Icu = 1] = "Icu", n[n.Attr = 2] = "Attr", n; }(Nn || {}), je = function (n) { return n[n.NgTemplate = 0] = "NgTemplate", n[n.Structural = 1] = "Structural", n[n.Block = 2] = "Block", n; }(je || {}), _h = Symbol("ConsumesSlot"), Nu = Symbol("DependsOnSlotContext"), Us = Symbol("ConsumesVars"), zo = Symbol("UsesVarOffset"), Rt = { [_h]: !0, numSlotsUsed: 1 }, Ye = { [Nu]: !0 }, Fe = { [Us]: !0 };
function Ws(n) { return n[_h] === !0; }
function ro(n) { return n[Nu] === !0; }
function na(n) { return n[Us] === !0; }
function mc(n) { return n[zo] === !0; }
function wt(n) { return E({ kind: c.Statement, statement: n }, $); }
function on(n, e, t, s) { return E({ kind: c.Variable, xref: n, variable: e, initializer: t, flags: s }, $); }
var $ = { debugListId: null, prev: null, next: null };
function zm(n, e, t) { return E(E(E({ kind: c.InterpolateText, target: n, interpolation: e, sourceSpan: t }, Ye), Fe), $); }
var le = class {
    strings;
    expressions;
    i18nPlaceholders;
    constructor(e, t, s) { if (this.strings = e, this.expressions = t, this.i18nPlaceholders = s, s.length !== 0 && s.length !== t.length)
        throw new Error(`Expected ${t.length} placeholders to match interpolation expression count, but got ${s.length}`); }
};
function Zn(n, e, t, s, r, i, o, a, l, u, p) { return E({ kind: c.Binding, bindingKind: e, target: n, name: t, expression: s, unit: r, securityContext: i, isTextAttribute: o, isStructuralTemplateAttribute: a, templateKind: l, i18nContext: null, i18nMessage: u, sourceSpan: p }, $); }
function Gm(n, e, t, s, r, i, o, a, l, u) { return E(E(E({ kind: c.Property, target: n, name: e, expression: t, isAnimationTrigger: s, securityContext: r, sanitizer: null, isStructuralTemplateAttribute: i, templateKind: o, i18nContext: a, i18nMessage: l, sourceSpan: u }, Ye), Fe), $); }
function Xm(n, e, t, s, r, i, o, a, l) { return E(E(E({ kind: c.TwoWayProperty, target: n, name: e, expression: t, securityContext: s, sanitizer: null, isStructuralTemplateAttribute: r, templateKind: i, i18nContext: o, i18nMessage: a, sourceSpan: l }, Ye), Fe), $); }
function Ym(n, e, t, s, r) { return E(E(E({ kind: c.StyleProp, target: n, name: e, expression: t, unit: s, sourceSpan: r }, Ye), Fe), $); }
function Qm(n, e, t, s) { return E(E(E({ kind: c.ClassProp, target: n, name: e, expression: t, sourceSpan: s }, Ye), Fe), $); }
function Zm(n, e, t) { return E(E(E({ kind: c.StyleMap, target: n, expression: e, sourceSpan: t }, Ye), Fe), $); }
function Jm(n, e, t) { return E(E(E({ kind: c.ClassMap, target: n, expression: e, sourceSpan: t }, Ye), Fe), $); }
function Km(n, e, t, s, r, i, o, a, l, u) { return E(E(E({ kind: c.Attribute, target: n, namespace: e, name: t, expression: s, securityContext: r, sanitizer: null, isTextAttribute: i, isStructuralTemplateAttribute: o, templateKind: a, i18nContext: null, i18nMessage: l, sourceSpan: u }, Ye), Fe), $); }
function eg(n, e) { return E({ kind: c.Advance, delta: n, sourceSpan: e }, $); }
function Th(n, e, t, s) { return E(E(E({ kind: c.Conditional, target: n, test: e, conditions: t, processed: null, sourceSpan: s, contextValue: null }, $), Ye), Fe); }
function tg(n, e, t, s) { return E(E({ kind: c.Repeater, target: n, targetSlot: e, collection: t, sourceSpan: s }, $), Ye); }
function ng(n, e, t, s) { return E(E(E({ kind: c.DeferWhen, target: n, expr: e, modifier: t, sourceSpan: s }, $), Ye), Fe); }
function bh(n, e, t, s, r, i, o, a, l, u, p) { return E(E(E({ kind: c.I18nExpression, context: n, target: e, i18nOwner: t, handle: s, expression: r, icuPlaceholder: i, i18nPlaceholder: o, resolutionTime: a, usage: l, name: u, sourceSpan: p }, $), Fe), Ye); }
function sg(n, e, t) { return E({ kind: c.I18nApply, owner: n, handle: e, sourceSpan: t }, $); }
function rg(n, e, t, s) { return E(E(E({ kind: c.StoreLet, target: n, declaredName: e, value: t, sourceSpan: s }, Ye), Fe), $); }
function Bt(n) { return n instanceof Q; }
var Q = class extends j {
    constructor(e = null) { super(null, e); }
}, xe = class n extends Q {
    name;
    kind = k.LexicalRead;
    constructor(e) { super(), this.name = e; }
    visitExpression(e, t) { }
    isEquivalent(e) { return this.name === e.name; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { return new n(this.name); }
}, io = class n extends Q {
    target;
    targetSlot;
    offset;
    kind = k.Reference;
    constructor(e, t, s) { super(), this.target = e, this.targetSlot = t, this.offset = s; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.target === this.target; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { return new n(this.target, this.targetSlot, this.offset); }
}, Wr = class n extends Q {
    target;
    value;
    sourceSpan;
    kind = k.StoreLet;
    [Us] = !0;
    [Nu] = !0;
    constructor(e, t, s) { super(), this.target = e, this.value = t, this.sourceSpan = s; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.target === this.target && e.value.isEquivalent(this.value); }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.value = A(this.value, e, t); }
    clone() { return new n(this.target, this.value, this.sourceSpan); }
}, jr = class n extends Q {
    target;
    targetSlot;
    kind = k.ContextLetReference;
    constructor(e, t) { super(), this.target = e, this.targetSlot = t; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.target === this.target; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { return new n(this.target, this.targetSlot); }
}, Gt = class n extends Q {
    view;
    kind = k.Context;
    constructor(e) { super(), this.view = e; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.view === this.view; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { return new n(this.view); }
}, ul = class n extends Q {
    view;
    kind = k.TrackContext;
    constructor(e) { super(), this.view = e; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.view === this.view; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { return new n(this.view); }
}, oo = class n extends Q {
    kind = k.NextContext;
    steps = 1;
    constructor() { super(); }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.steps === this.steps; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { let e = new n; return e.steps = this.steps, e; }
}, cl = class n extends Q {
    kind = k.GetCurrentView;
    constructor() { super(); }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { return new n; }
}, ao = class n extends Q {
    view;
    kind = k.RestoreView;
    constructor(e) { super(), this.view = e; }
    visitExpression(e, t) { typeof this.view != "number" && this.view.visitExpression(e, t); }
    isEquivalent(e) { return !(e instanceof n) || typeof e.view != typeof this.view ? !1 : typeof this.view == "number" ? this.view === e.view : this.view.isEquivalent(e.view); }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { typeof this.view != "number" && (this.view = A(this.view, e, t)); }
    clone() { return new n(this.view instanceof j ? this.view.clone() : this.view); }
}, pl = class n extends Q {
    expr;
    kind = k.ResetView;
    constructor(e) { super(), this.expr = e; }
    visitExpression(e, t) { this.expr.visitExpression(e, t); }
    isEquivalent(e) { return e instanceof n && this.expr.isEquivalent(e.expr); }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.expr = A(this.expr, e, t); }
    clone() { return new n(this.expr.clone()); }
}, lo = class n extends Q {
    target;
    value;
    kind = k.TwoWayBindingSet;
    constructor(e, t) { super(), this.target = e, this.value = t; }
    visitExpression(e, t) { this.target.visitExpression(e, t), this.value.visitExpression(e, t); }
    isEquivalent(e) { return this.target.isEquivalent(e.target) && this.value.isEquivalent(e.value); }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.target = A(this.target, e, t), this.value = A(this.value, e, t); }
    clone() { return new n(this.target, this.value); }
}, Wt = class n extends Q {
    xref;
    kind = k.ReadVariable;
    name = null;
    constructor(e) { super(), this.xref = e; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.xref === this.xref; }
    isConstant() { return !1; }
    transformInternalExpressions() { }
    clone() { let e = new n(this.xref); return e.name = this.name, e; }
}, Jn = class n extends Q {
    kind = k.PureFunctionExpr;
    [Us] = !0;
    [zo] = !0;
    varOffset = null;
    body;
    args;
    fn = null;
    constructor(e, t) { super(), this.body = e, this.args = t; }
    visitExpression(e, t) { this.body?.visitExpression(e, t); for (let s of this.args)
        s.visitExpression(e, t); }
    isEquivalent(e) { return !(e instanceof n) || e.args.length !== this.args.length ? !1 : e.body !== null && this.body !== null && e.body.isEquivalent(this.body) && e.args.every((t, s) => t.isEquivalent(this.args[s])); }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.body !== null ? this.body = A(this.body, e, t | z.InChildOperation) : this.fn !== null && (this.fn = A(this.fn, e, t)); for (let s = 0; s < this.args.length; s++)
        this.args[s] = A(this.args[s], e, t); }
    clone() { let e = new n(this.body?.clone() ?? null, this.args.map(t => t.clone())); return e.fn = this.fn?.clone() ?? null, e.varOffset = this.varOffset, e; }
}, Ns = class n extends Q {
    index;
    kind = k.PureFunctionParameterExpr;
    constructor(e) { super(), this.index = e; }
    visitExpression() { }
    isEquivalent(e) { return e instanceof n && e.index === this.index; }
    isConstant() { return !0; }
    transformInternalExpressions() { }
    clone() { return new n(this.index); }
}, Ds = class n extends Q {
    target;
    targetSlot;
    name;
    args;
    kind = k.PipeBinding;
    [Us] = !0;
    [zo] = !0;
    varOffset = null;
    constructor(e, t, s, r) { super(), this.target = e, this.targetSlot = t, this.name = s, this.args = r; }
    visitExpression(e, t) { for (let s of this.args)
        s.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { for (let s = 0; s < this.args.length; s++)
        this.args[s] = A(this.args[s], e, t); }
    clone() { let e = new n(this.target, this.targetSlot, this.name, this.args.map(t => t.clone())); return e.varOffset = this.varOffset, e; }
}, uo = class n extends Q {
    target;
    targetSlot;
    name;
    args;
    numArgs;
    kind = k.PipeBindingVariadic;
    [Us] = !0;
    [zo] = !0;
    varOffset = null;
    constructor(e, t, s, r, i) { super(), this.target = e, this.targetSlot = t, this.name = s, this.args = r, this.numArgs = i; }
    visitExpression(e, t) { this.args.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.args = A(this.args, e, t); }
    clone() { let e = new n(this.target, this.targetSlot, this.name, this.args.clone(), this.numArgs); return e.varOffset = this.varOffset, e; }
}, Ps = class n extends Q {
    receiver;
    name;
    kind = k.SafePropertyRead;
    constructor(e, t) { super(), this.receiver = e, this.name = t; }
    get index() { return this.name; }
    visitExpression(e, t) { this.receiver.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.receiver = A(this.receiver, e, t); }
    clone() { return new n(this.receiver.clone(), this.name); }
}, Ls = class n extends Q {
    receiver;
    index;
    kind = k.SafeKeyedRead;
    constructor(e, t, s) { super(s), this.receiver = e, this.index = t; }
    visitExpression(e, t) { this.receiver.visitExpression(e, t), this.index.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.receiver = A(this.receiver, e, t), this.index = A(this.index, e, t); }
    clone() { return new n(this.receiver.clone(), this.index.clone(), this.sourceSpan); }
}, Kn = class n extends Q {
    receiver;
    args;
    kind = k.SafeInvokeFunction;
    constructor(e, t) { super(), this.receiver = e, this.args = t; }
    visitExpression(e, t) { this.receiver.visitExpression(e, t); for (let s of this.args)
        s.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.receiver = A(this.receiver, e, t); for (let s = 0; s < this.args.length; s++)
        this.args[s] = A(this.args[s], e, t); }
    clone() { return new n(this.receiver.clone(), this.args.map(e => e.clone())); }
}, Bs = class n extends Q {
    guard;
    expr;
    kind = k.SafeTernaryExpr;
    constructor(e, t) { super(), this.guard = e, this.expr = t; }
    visitExpression(e, t) { this.guard.visitExpression(e, t), this.expr.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.guard = A(this.guard, e, t), this.expr = A(this.expr, e, t); }
    clone() { return new n(this.guard.clone(), this.expr.clone()); }
}, zr = class n extends Q {
    kind = k.EmptyExpr;
    visitExpression(e, t) { }
    isEquivalent(e) { return e instanceof n; }
    isConstant() { return !0; }
    clone() { return new n; }
    transformInternalExpressions() { }
}, Et = class n extends Q {
    expr;
    xref;
    kind = k.AssignTemporaryExpr;
    name = null;
    constructor(e, t) { super(), this.expr = e, this.xref = t; }
    visitExpression(e, t) { this.expr.visitExpression(e, t); }
    isEquivalent() { return !1; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { this.expr = A(this.expr, e, t); }
    clone() { let e = new n(this.expr.clone(), this.xref); return e.name = this.name, e; }
}, Xt = class n extends Q {
    xref;
    kind = k.ReadTemporaryExpr;
    name = null;
    constructor(e) { super(), this.xref = e; }
    visitExpression(e, t) { }
    isEquivalent() { return this.xref === this.xref; }
    isConstant() { return !1; }
    transformInternalExpressions(e, t) { }
    clone() { let e = new n(this.xref); return e.name = this.name, e; }
}, co = class n extends Q {
    slot;
    kind = k.SlotLiteralExpr;
    constructor(e) { super(), this.slot = e; }
    visitExpression(e, t) { }
    isEquivalent(e) { return e instanceof n && e.slot === this.slot; }
    isConstant() { return !0; }
    clone() { return new n(this.slot); }
    transformInternalExpressions() { }
}, po = class n extends Q {
    expr;
    target;
    targetSlot;
    alias;
    kind = k.ConditionalCase;
    constructor(e, t, s, r = null) { super(), this.expr = e, this.target = t, this.targetSlot = s, this.alias = r; }
    visitExpression(e, t) { this.expr !== null && this.expr.visitExpression(e, t); }
    isEquivalent(e) { return e instanceof n && e.expr === this.expr; }
    isConstant() { return !0; }
    clone() { return new n(this.expr, this.target, this.targetSlot); }
    transformInternalExpressions(e, t) { this.expr !== null && (this.expr = A(this.expr, e, t)); }
}, Gr = class n extends Q {
    expr;
    kind = k.ConstCollected;
    constructor(e) { super(), this.expr = e; }
    transformInternalExpressions(e, t) { this.expr = e(this.expr, t); }
    visitExpression(e, t) { this.expr.visitExpression(e, t); }
    isEquivalent(e) { return e instanceof n ? this.expr.isEquivalent(e.expr) : !1; }
    isConstant() { return this.expr.isConstant(); }
    clone() { return new n(this.expr); }
};
function _e(n, e) { ce(n, (t, s) => (e(t, s), t), z.None); }
var z = function (n) { return n[n.None = 0] = "None", n[n.InChildOperation = 1] = "InChildOperation", n; }(z || {});
function sa(n, e, t) { for (let s = 0; s < n.expressions.length; s++)
    n.expressions[s] = A(n.expressions[s], e, t); }
function ce(n, e, t) { switch (n.kind) {
    case c.StyleProp:
    case c.StyleMap:
    case c.ClassProp:
    case c.ClassMap:
    case c.Binding:
        n.expression instanceof le ? sa(n.expression, e, t) : n.expression = A(n.expression, e, t);
        break;
    case c.Property:
    case c.HostProperty:
    case c.Attribute:
        n.expression instanceof le ? sa(n.expression, e, t) : n.expression = A(n.expression, e, t), n.sanitizer = n.sanitizer && A(n.sanitizer, e, t);
        break;
    case c.TwoWayProperty:
        n.expression = A(n.expression, e, t), n.sanitizer = n.sanitizer && A(n.sanitizer, e, t);
        break;
    case c.I18nExpression:
        n.expression = A(n.expression, e, t);
        break;
    case c.InterpolateText:
        sa(n.interpolation, e, t);
        break;
    case c.Statement:
        ho(n.statement, e, t);
        break;
    case c.Variable:
        n.initializer = A(n.initializer, e, t);
        break;
    case c.Conditional:
        for (let s of n.conditions)
            s.expr !== null && (s.expr = A(s.expr, e, t));
        n.processed !== null && (n.processed = A(n.processed, e, t)), n.contextValue !== null && (n.contextValue = A(n.contextValue, e, t));
        break;
    case c.Listener:
    case c.TwoWayListener:
        for (let s of n.handlerOps)
            ce(s, e, t | z.InChildOperation);
        break;
    case c.ExtractedAttribute:
        n.expression = n.expression && A(n.expression, e, t), n.trustedValueFn = n.trustedValueFn && A(n.trustedValueFn, e, t);
        break;
    case c.RepeaterCreate:
        if (n.trackByOps === null)
            n.track = A(n.track, e, t);
        else
            for (let s of n.trackByOps)
                ce(s, e, t | z.InChildOperation);
        n.trackByFn !== null && (n.trackByFn = A(n.trackByFn, e, t));
        break;
    case c.Repeater:
        n.collection = A(n.collection, e, t);
        break;
    case c.Defer:
        n.loadingConfig !== null && (n.loadingConfig = A(n.loadingConfig, e, t)), n.placeholderConfig !== null && (n.placeholderConfig = A(n.placeholderConfig, e, t)), n.resolverFn !== null && (n.resolverFn = A(n.resolverFn, e, t));
        break;
    case c.I18nMessage:
        for (let [s, r] of n.params)
            n.params.set(s, A(r, e, t));
        for (let [s, r] of n.postprocessingParams)
            n.postprocessingParams.set(s, A(r, e, t));
        break;
    case c.DeferWhen:
        n.expr = A(n.expr, e, t);
        break;
    case c.StoreLet:
        n.value = A(n.value, e, t);
        break;
    case c.Advance:
    case c.Container:
    case c.ContainerEnd:
    case c.ContainerStart:
    case c.DeferOn:
    case c.DisableBindings:
    case c.Element:
    case c.ElementEnd:
    case c.ElementStart:
    case c.EnableBindings:
    case c.I18n:
    case c.I18nApply:
    case c.I18nContext:
    case c.I18nEnd:
    case c.I18nStart:
    case c.IcuEnd:
    case c.IcuStart:
    case c.Namespace:
    case c.Pipe:
    case c.Projection:
    case c.ProjectionDef:
    case c.Template:
    case c.Text:
    case c.I18nAttributes:
    case c.IcuPlaceholder:
    case c.DeclareLet:
    case c.SourceLocation: break;
    default: throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${c[n.kind]}`);
} }
function A(n, e, t) { if (n instanceof Q)
    n.transformInternalExpressions(e, t);
else if (n instanceof W)
    n.lhs = A(n.lhs, e, t), n.rhs = A(n.rhs, e, t);
else if (n instanceof hn)
    n.expr = A(n.expr, e, t);
else if (n instanceof Me)
    n.receiver = A(n.receiver, e, t);
else if (n instanceof It)
    n.receiver = A(n.receiver, e, t), n.index = A(n.index, e, t);
else if (n instanceof qn)
    n.receiver = A(n.receiver, e, t), n.value = A(n.value, e, t);
else if (n instanceof Es)
    n.receiver = A(n.receiver, e, t), n.index = A(n.index, e, t), n.value = A(n.value, e, t);
else if (n instanceof Ie) {
    n.fn = A(n.fn, e, t);
    for (let s = 0; s < n.args.length; s++)
        n.args[s] = A(n.args[s], e, t);
}
else if (n instanceof at)
    for (let s = 0; s < n.entries.length; s++)
        n.entries[s] = A(n.entries[s], e, t);
else if (n instanceof gt)
    for (let s = 0; s < n.entries.length; s++)
        n.entries[s].value = A(n.entries[s].value, e, t);
else if (n instanceof kt)
    n.condition = A(n.condition, e, t), n.trueCase = A(n.trueCase, e, t), n.falseCase !== null && (n.falseCase = A(n.falseCase, e, t));
else if (n instanceof Vn)
    n.expr = A(n.expr, e, t);
else if (n instanceof dr)
    n.value = A(n.value, e, t);
else if (n instanceof vr)
    for (let s = 0; s < n.expressions.length; s++)
        n.expressions[s] = A(n.expressions[s], e, t);
else if (n instanceof ys)
    n.condition = A(n.condition, e, t);
else if (n instanceof mr)
    n.tag = A(n.tag, e, t), n.template.expressions = n.template.expressions.map(s => A(s, e, t));
else if (n instanceof pn) {
    if (Array.isArray(n.body))
        for (let s = 0; s < n.body.length; s++)
            ho(n.body[s], e, t);
    else
        n.body = A(n.body, e, t);
}
else if (!(n instanceof V)) {
    if (n instanceof xs)
        for (let s = 0; s < n.expressions.length; s++)
            n.expressions[s] = A(n.expressions[s], e, t);
    else if (!(n instanceof ze || n instanceof jt || n instanceof ge))
        throw new Error(`Unhandled expression kind: ${n.constructor.name}`);
} return e(n, t); }
function ho(n, e, t) { if (n instanceof Ge)
    n.expr = A(n.expr, e, t);
else if (n instanceof ye)
    n.value = A(n.value, e, t);
else if (n instanceof ve)
    n.value !== void 0 && (n.value = A(n.value, e, t));
else if (n instanceof Sr) {
    n.condition = A(n.condition, e, t);
    for (let s of n.trueCase)
        ho(s, e, t);
    for (let s of n.falseCase)
        ho(s, e, t);
}
else
    throw new Error(`Unhandled statement kind: ${n.constructor.name}`); }
function kh(n) { return n instanceof ge && typeof n.value == "string"; }
var w = (() => { class n {
    static nextListId = 0;
    debugListId = n.nextListId++;
    head = { kind: c.ListEnd, next: null, prev: null, debugListId: this.debugListId };
    tail = { kind: c.ListEnd, next: null, prev: null, debugListId: this.debugListId };
    constructor() { this.head.next = this.tail, this.tail.prev = this.head; }
    push(t) { if (Array.isArray(t)) {
        for (let r of t)
            this.push(r);
        return;
    } n.assertIsNotEnd(t), n.assertIsUnowned(t), t.debugListId = this.debugListId; let s = this.tail.prev; t.prev = s, s.next = t, t.next = this.tail, this.tail.prev = t; }
    prepend(t) { if (t.length === 0)
        return; for (let i of t)
        n.assertIsNotEnd(i), n.assertIsUnowned(i), i.debugListId = this.debugListId; let s = this.head.next, r = this.head; for (let i of t)
        r.next = i, i.prev = r, r = i; r.next = s, s.prev = r; }
    *[Symbol.iterator]() { let t = this.head.next; for (; t !== this.tail;) {
        n.assertIsOwned(t, this.debugListId);
        let s = t.next;
        yield t, t = s;
    } }
    *reversed() { let t = this.tail.prev; for (; t !== this.head;) {
        n.assertIsOwned(t, this.debugListId);
        let s = t.prev;
        yield t, t = s;
    } }
    static replace(t, s) { n.assertIsNotEnd(t), n.assertIsNotEnd(s), n.assertIsOwned(t), n.assertIsUnowned(s), s.debugListId = t.debugListId, t.prev !== null && (t.prev.next = s, s.prev = t.prev), t.next !== null && (t.next.prev = s, s.next = t.next), t.debugListId = null, t.prev = null, t.next = null; }
    static replaceWithMany(t, s) { if (s.length === 0) {
        n.remove(t);
        return;
    } n.assertIsNotEnd(t), n.assertIsOwned(t); let r = t.debugListId; t.debugListId = null; for (let p of s)
        n.assertIsNotEnd(p), n.assertIsUnowned(p); let { prev: i, next: o } = t; t.prev = null, t.next = null; let a = i; for (let p of s)
        this.assertIsUnowned(p), p.debugListId = r, a.next = p, p.prev = a, p.next = null, a = p; let l = s[0], u = a; i !== null && (i.next = l, l.prev = i), o !== null && (o.prev = u, u.next = o); }
    static remove(t) { n.assertIsNotEnd(t), n.assertIsOwned(t), t.prev.next = t.next, t.next.prev = t.prev, t.debugListId = null, t.prev = null, t.next = null; }
    static insertBefore(t, s) { if (Array.isArray(t)) {
        for (let r of t)
            this.insertBefore(r, s);
        return;
    } if (n.assertIsOwned(s), s.prev === null)
        throw new Error("AssertionError: illegal operation on list start"); n.assertIsNotEnd(t), n.assertIsUnowned(t), t.debugListId = s.debugListId, t.prev = null, s.prev.next = t, t.prev = s.prev, t.next = s, s.prev = t; }
    static insertAfter(t, s) { if (n.assertIsOwned(s), s.next === null)
        throw new Error("AssertionError: illegal operation on list end"); n.assertIsNotEnd(t), n.assertIsUnowned(t), t.debugListId = s.debugListId, s.next.prev = t, t.next = s.next, t.prev = s, s.next = t; }
    static assertIsUnowned(t) { if (t.debugListId !== null)
        throw new Error(`AssertionError: illegal operation on owned node: ${c[t.kind]}`); }
    static assertIsOwned(t, s) { if (t.debugListId === null)
        throw new Error(`AssertionError: illegal operation on unowned node: ${c[t.kind]}`); if (s !== void 0 && t.debugListId !== s)
        throw new Error(`AssertionError: node belongs to the wrong list (expected ${s}, actual ${t.debugListId})`); }
    static assertIsNotEnd(t) { if (t.kind === c.ListEnd)
        throw new Error("AssertionError: illegal operation on list head or tail"); }
} return n; })(), Re = class {
    slot = null;
}, ig = new Set([c.Element, c.ElementStart, c.Container, c.ContainerStart, c.Template, c.RepeaterCreate]);
function wn(n) { return ig.has(n.kind); }
function og(n, e, t, s, r, i) { return E(E({ kind: c.ElementStart, xref: e, tag: n, handle: new Re, attributes: null, localRefs: [], nonBindable: !1, namespace: t, i18nPlaceholder: s, startSourceSpan: r, wholeSourceSpan: i }, Rt), $); }
function Go(n, e, t, s, r, i, o, a) { return E(E({ kind: c.Template, xref: n, templateKind: e, attributes: null, tag: t, handle: new Re, functionNameSuffix: s, decls: null, vars: null, localRefs: [], nonBindable: !1, namespace: r, i18nPlaceholder: i, startSourceSpan: o, wholeSourceSpan: a }, Rt), $); }
function ag(n, e, t, s, r, i, o, a, l, u) { return ae(E(E(E({ kind: c.RepeaterCreate, attributes: null, xref: n, handle: new Re, emptyView: e, track: s, trackByFn: null, trackByOps: null, tag: t, emptyTag: i, emptyAttributes: null, functionNameSuffix: "For", namespace: Ce.HTML, nonBindable: !1, localRefs: [], decls: null, vars: null, varNames: r, usesComponentInstance: !1, i18nPlaceholder: o, emptyI18nPlaceholder: a, startSourceSpan: l, wholeSourceSpan: u }, Rt), $), Fe), { numSlotsUsed: e === null ? 2 : 3 }); }
function lg(n, e) { return E({ kind: c.ElementEnd, xref: n, sourceSpan: e }, $); }
function ug(n) { return E({ kind: c.DisableBindings, xref: n }, $); }
function cg(n) { return E({ kind: c.EnableBindings, xref: n }, $); }
function Ih(n, e, t, s) { return E(E({ kind: c.Text, xref: n, handle: new Re, initialValue: e, icuPlaceholder: t, sourceSpan: s }, Rt), $); }
function Du(n, e, t, s, r, i, o, a, l) { let u = new w; return u.push(r), E({ kind: c.Listener, target: n, targetSlot: e, tag: s, hostListener: a, name: t, handlerOps: u, handlerFnName: null, consumesDollarEvent: !1, isAnimationListener: i !== null, animationPhase: i, eventTarget: o, sourceSpan: l }, $); }
function Nh(n, e, t, s, r, i) { let o = new w; return o.push(r), E({ kind: c.TwoWayListener, target: n, targetSlot: e, tag: s, name: t, handlerOps: o, handlerFnName: null, sourceSpan: i }, $); }
function Dh(n, e, t) { return E(E({ kind: c.Pipe, xref: n, handle: e, name: t }, $), Rt); }
function pg(n) { return E({ kind: c.Namespace, active: n }, $); }
function hg(n) { return E({ kind: c.ProjectionDef, def: n }, $); }
function fg(n, e, t, s, r) { return ae(E(E({ kind: c.Projection, xref: n, handle: new Re, selector: e, i18nPlaceholder: t, fallbackView: s, projectionSlotIndex: 0, attributes: null, localRefs: [], sourceSpan: r }, $), Rt), { numSlotsUsed: s === null ? 1 : 2 }); }
function nt(n, e, t, s, r, i, o, a) { return E({ kind: c.ExtractedAttribute, target: n, bindingKind: e, namespace: t, name: s, expression: r, i18nContext: i, i18nMessage: o, securityContext: a, trustedValueFn: null }, $); }
function dg(n, e, t, s, r, i) { return ae(E(E({ kind: c.Defer, xref: n, handle: new Re, mainView: e, mainSlot: t, loadingView: null, loadingSlot: null, loadingConfig: null, loadingMinimumTime: null, loadingAfterTime: null, placeholderView: null, placeholderSlot: null, placeholderConfig: null, placeholderMinimumTime: null, errorView: null, errorSlot: null, ownResolverFn: s, resolverFn: r, flags: null, sourceSpan: i }, $), Rt), { numSlotsUsed: 2 }); }
function Kt(n, e, t, s) { return E({ kind: c.DeferOn, defer: n, trigger: e, modifier: t, sourceSpan: s }, $); }
function mg(n, e, t) { return E(E({ kind: c.DeclareLet, xref: n, declaredName: e, sourceSpan: t, handle: new Re }, Rt), $); }
function gg(n, e, t, s, r, i, o, a) { return E({ kind: c.I18nMessage, xref: n, i18nContext: e, i18nBlock: t, message: s, messagePlaceholder: r, params: i, postprocessingParams: o, needsPostprocessing: a, subMessages: [] }, $); }
function Xo(n, e, t, s) { return E(E({ kind: c.I18nStart, xref: n, handle: new Re, root: t ?? n, message: e, messageIndex: null, subTemplateIndex: null, context: null, sourceSpan: s }, $), Rt); }
function Yo(n, e) { return E({ kind: c.I18nEnd, xref: n, sourceSpan: e }, $); }
function vg(n, e, t, s) { return E({ kind: c.IcuStart, xref: n, message: e, messagePlaceholder: t, context: null, sourceSpan: s }, $); }
function wg(n) { return E({ kind: c.IcuEnd, xref: n }, $); }
function Eg(n, e, t) { return E({ kind: c.IcuPlaceholder, xref: n, name: e, strings: t, expressionPlaceholders: [] }, $); }
function ra(n, e, t, s, r) { if (t === null && n !== Nn.Attr)
    throw new Error("AssertionError: i18nBlock must be provided for non-attribute contexts."); return E({ kind: c.I18nContext, contextKind: n, xref: e, i18nBlock: t, message: s, sourceSpan: r, params: new Map, postprocessingParams: new Map }, $); }
function Ph(n, e, t) { return E(E({ kind: c.I18nAttributes, xref: n, handle: e, target: t, i18nAttributesConfig: null }, $), Rt); }
function Sg(n, e) { return E({ kind: c.SourceLocation, templatePath: n, locations: e }, $); }
function xg(n, e, t, s, r, i) { return E(E({ kind: c.HostProperty, name: n, expression: e, isAnimationTrigger: t, i18nContext: s, securityContext: r, sanitizer: null, sourceSpan: i }, Fe), $); }
var Lh = "CTX_REF_MARKER", C = function (n) { return n[n.Tmpl = 0] = "Tmpl", n[n.Host = 1] = "Host", n[n.Both = 2] = "Both", n; }(C || {}), fo = class {
    componentName;
    pool;
    compatibility;
    constructor(e, t, s) { this.componentName = e, this.pool = t, this.compatibility = s; }
    kind = C.Both;
    allocateXrefId() { return this.nextXrefId++; }
    nextXrefId = 0;
}, Xr = class extends fo {
    relativeContextFilePath;
    i18nUseExternalIds;
    deferMeta;
    allDeferrableDepsFn;
    relativeTemplatePath;
    enableDebugLocations;
    constructor(e, t, s, r, i, o, a, l, u) { super(e, t, s), this.relativeContextFilePath = r, this.i18nUseExternalIds = i, this.deferMeta = o, this.allDeferrableDepsFn = a, this.relativeTemplatePath = l, this.enableDebugLocations = u, this.root = new bt(this, this.allocateXrefId(), null), this.views.set(this.root.xref, this.root); }
    kind = C.Tmpl;
    fnSuffix = "Template";
    root;
    views = new Map;
    contentSelectors = null;
    allocateView(e) { let t = new bt(this, this.allocateXrefId(), e); return this.views.set(t.xref, t), t; }
    get units() { return this.views.values(); }
    addConst(e, t) { for (let r = 0; r < this.consts.length; r++)
        if (this.consts[r].isEquivalent(e))
            return r; let s = this.consts.length; return this.consts.push(e), t && this.constsInitializers.push(...t), s; }
    consts = [];
    constsInitializers = [];
}, mo = class {
    xref;
    constructor(e) { this.xref = e; }
    create = new w;
    update = new w;
    fnName = null;
    vars = null;
    *ops() { for (let e of this.create)
        if (yield e, e.kind === c.Listener || e.kind === c.TwoWayListener)
            for (let t of e.handlerOps)
                yield t;
        else if (e.kind === c.RepeaterCreate && e.trackByOps !== null)
            for (let t of e.trackByOps)
                yield t; for (let e of this.update)
        yield e; }
}, bt = class extends mo {
    job;
    parent;
    constructor(e, t, s) { super(t), this.job = e, this.parent = s; }
    contextVariables = new Map;
    aliases = new Set;
    decls = null;
}, go = class extends fo {
    constructor(e, t, s) { super(e, t, s), this.root = new hl(this); }
    kind = C.Host;
    fnSuffix = "HostBindings";
    root;
    get units() { return [this.root]; }
}, hl = class extends mo {
    job;
    constructor(e) { super(0), this.job = e; }
    attributes = null;
};
function yg(n) { for (let e of n.units)
    for (let t of e.ops())
        ce(t, Cg, z.None); }
function Cg(n) { if (n instanceof Ie && n.fn instanceof xe && n.fn.name === "$any") {
    if (n.args.length !== 1)
        throw new Error("The $any builtin function expects exactly one argument.");
    return n.args[0];
} return n; }
function Ag(n) { let e = new Map; for (let t of n.units)
    for (let s of t.create)
        s.kind === c.I18nContext && e.set(s.xref, s); for (let t of n.units)
    for (let s of t.update)
        s.kind === c.I18nExpression && _g(e, s) && w.insertAfter(sg(s.i18nOwner, s.handle, null), s); }
function _g(n, e) { if (e.next?.kind !== c.I18nExpression)
    return !0; let t = n.get(e.context), s = n.get(e.next.context); if (t === void 0)
    throw new Error("AssertionError: expected an I18nContextOp to exist for the I18nExpressionOp's context"); if (s === void 0)
    throw new Error("AssertionError: expected an I18nContextOp to exist for the next I18nExpressionOp's context"); return t.i18nBlock !== null ? t.i18nBlock !== s.i18nBlock : e.i18nOwner !== e.next.i18nOwner; }
function Tg(n) { for (let e of n.units) {
    let t = e.update.head, s = [], r = null;
    for (let i of e.create) {
        if (i.kind === c.I18nStart)
            r = { blockXref: i.xref, lastSlotConsumer: i.xref };
        else if (i.kind === c.I18nEnd) {
            for (let o of s)
                o.target = r.lastSlotConsumer, w.insertBefore(o, t);
            s.length = 0, r = null;
        }
        if (Ws(i))
            for (r !== null && (r.lastSlotConsumer = i.xref); t.next !== null;) {
                if (r !== null && t.kind === c.I18nExpression && t.usage === Hs.I18nText && t.i18nOwner === r.blockXref) {
                    let o = t;
                    t = t.next, w.remove(o), s.push(o);
                    continue;
                }
                if (ro(t) && t.target !== i.xref)
                    break;
                t = t.next;
            }
    }
} }
function Pu(n) { let e = new Map; for (let t of n.create)
    Ws(t) && (e.set(t.xref, t), t.kind === c.RepeaterCreate && t.emptyView !== null && e.set(t.emptyView, t)); return e; }
function bg(n) { for (let e of n.units) {
    let t = Pu(e);
    for (let s of e.ops())
        switch (s.kind) {
            case c.Attribute:
                kg(e, s, t);
                break;
            case c.Property:
                if (!s.isAnimationTrigger) {
                    let r;
                    s.i18nMessage !== null && s.templateKind === null ? r = I.I18n : s.isStructuralTemplateAttribute ? r = I.Template : r = I.Property, w.insertBefore(nt(s.target, r, null, s.name, null, null, null, s.securityContext), as(t, s.target));
                }
                break;
            case c.TwoWayProperty:
                w.insertBefore(nt(s.target, I.TwoWayProperty, null, s.name, null, null, null, s.securityContext), as(t, s.target));
                break;
            case c.StyleProp:
            case c.ClassProp:
                e.job.compatibility === Xe.TemplateDefinitionBuilder && s.expression instanceof zr && w.insertBefore(nt(s.target, I.Property, null, s.name, null, null, null, ee.STYLE), as(t, s.target));
                break;
            case c.Listener:
                if (!s.isAnimationListener) {
                    let r = nt(s.target, I.Property, null, s.name, null, null, null, ee.NONE);
                    if (n.kind === C.Host) {
                        if (n.compatibility)
                            break;
                        e.create.push(r);
                    }
                    else
                        w.insertBefore(r, as(t, s.target));
                }
                break;
            case c.TwoWayListener:
                if (n.kind !== C.Host) {
                    let r = nt(s.target, I.Property, null, s.name, null, null, null, ee.NONE);
                    w.insertBefore(r, as(t, s.target));
                }
                break;
        }
} }
function as(n, e) { let t = n.get(e); if (t === void 0)
    throw new Error("All attributes should have an element-like target."); return t; }
function kg(n, e, t) { if (e.expression instanceof le)
    return; let s = e.isTextAttribute || e.expression.isConstant(); if (n.job.compatibility === Xe.TemplateDefinitionBuilder && (s &&= e.isTextAttribute), s) {
    let r = nt(e.target, e.isStructuralTemplateAttribute ? I.Template : I.Attribute, e.namespace, e.name, e.expression, e.i18nContext, e.i18nMessage, e.securityContext);
    if (n.job.kind === C.Host)
        n.create.push(r);
    else {
        let i = as(t, e.target);
        w.insertBefore(r, i);
    }
    w.remove(e);
} }
function Ig(n, e) { let t = n.get(e); if (t === void 0)
    throw new Error("All attributes should have an element-like target."); return t; }
function Ng(n) { let e = new Map; for (let t of n.units)
    for (let s of t.create)
        wn(s) && e.set(s.xref, s); for (let t of n.units)
    for (let s of t.ops())
        if (s.kind === c.Binding)
            switch (s.bindingKind) {
                case I.Attribute:
                    if (s.name === "ngNonBindable") {
                        w.remove(s);
                        let r = Ig(e, s.target);
                        r.nonBindable = !0;
                    }
                    else {
                        let [r, i] = vt(s.name);
                        w.replace(s, Km(s.target, r, i, s.expression, s.securityContext, s.isTextAttribute, s.isStructuralTemplateAttribute, s.templateKind, s.i18nMessage, s.sourceSpan));
                    }
                    break;
                case I.Property:
                case I.Animation:
                    n.kind === C.Host ? w.replace(s, xg(s.name, s.expression, s.bindingKind === I.Animation, s.i18nContext, s.securityContext, s.sourceSpan)) : w.replace(s, Gm(s.target, s.name, s.expression, s.bindingKind === I.Animation, s.securityContext, s.isStructuralTemplateAttribute, s.templateKind, s.i18nContext, s.i18nMessage, s.sourceSpan));
                    break;
                case I.TwoWayProperty:
                    if (!(s.expression instanceof j))
                        throw new Error(`Expected value of two-way property binding "${s.name}" to be an expression`);
                    w.replace(s, Xm(s.target, s.name, s.expression, s.securityContext, s.isStructuralTemplateAttribute, s.templateKind, s.i18nContext, s.i18nMessage, s.sourceSpan));
                    break;
                case I.I18n:
                case I.ClassName:
                case I.StyleProperty: throw new Error(`Unhandled binding of kind ${I[s.bindingKind]}`);
            } }
var Dg = new Set([h.attribute, h.classProp, h.element, h.elementContainer, h.elementContainerEnd, h.elementContainerStart, h.elementEnd, h.elementStart, h.hostProperty, h.i18nExp, h.listener, h.listener, h.property, h.styleProp, h.stylePropInterpolate1, h.stylePropInterpolate2, h.stylePropInterpolate3, h.stylePropInterpolate4, h.stylePropInterpolate5, h.stylePropInterpolate6, h.stylePropInterpolate7, h.stylePropInterpolate8, h.stylePropInterpolateV, h.syntheticHostListener, h.syntheticHostProperty, h.templateCreate, h.twoWayProperty, h.twoWayListener, h.declareLet]), Pg = 256;
function Lg(n) { for (let e of n.units)
    gc(e.create), gc(e.update); }
function gc(n) { let e = null; for (let t of n) {
    if (t.kind !== c.Statement || !(t.statement instanceof Ge)) {
        e = null;
        continue;
    }
    if (!(t.statement.expr instanceof Ie) || !(t.statement.expr.fn instanceof jt)) {
        e = null;
        continue;
    }
    let s = t.statement.expr.fn.value;
    if (!Dg.has(s)) {
        e = null;
        continue;
    }
    if (e !== null && e.instruction === s && e.length < Pg) {
        let r = e.expression.callFn(t.statement.expr.args, t.statement.expr.sourceSpan, t.statement.expr.pure);
        e.expression = r, e.op.statement = r.toStmt(), e.length++, w.remove(t);
    }
    else
        e = { op: t, instruction: s, expression: t.statement.expr, length: 1 };
} }
function Bg(n) { for (let e of n.units)
    for (let t of e.update)
        t.kind === c.Attribute && t.expression instanceof le && t.expression.strings.length === 2 && t.expression.strings.every(r => r === "") && (t.expression = t.expression.expressions[0]); }
function Mg(n) { for (let e of n.units)
    for (let t of e.ops()) {
        if (t.kind !== c.Conditional)
            continue;
        let s, r = t.conditions.findIndex(o => o.expr === null);
        if (r >= 0) {
            let o = t.conditions.splice(r, 1)[0].targetSlot;
            s = new co(o);
        }
        else
            s = d(-1);
        let i = t.test == null ? null : new Et(t.test, n.allocateXrefId());
        for (let o = t.conditions.length - 1; o >= 0; o--) {
            let a = t.conditions[o];
            if (a.expr !== null) {
                if (i !== null) {
                    let l = o === 0 ? i : new Xt(i.xref);
                    a.expr = new W(b.Identical, l, a.expr);
                }
                else if (a.alias !== null) {
                    let l = n.allocateXrefId();
                    a.expr = new Et(a.expr, l), t.contextValue = new Xt(l);
                }
                s = new kt(a.expr, new co(a.targetSlot), s);
            }
        }
        t.processed = s, t.conditions = [];
    } }
var Rg = new Map([["&&", b.And], [">", b.Bigger], [">=", b.BiggerEquals], ["|", b.BitwiseOr], ["&", b.BitwiseAnd], ["/", b.Divide], ["==", b.Equals], ["===", b.Identical], ["<", b.Lower], ["<=", b.LowerEquals], ["-", b.Minus], ["%", b.Modulo], ["*", b.Multiply], ["!=", b.NotEquals], ["!==", b.NotIdentical], ["??", b.NullishCoalesce], ["||", b.Or], ["+", b.Plus]]);
function Bh(n) { let e = new Map([["svg", Ce.SVG], ["math", Ce.Math]]); return n === null ? Ce.HTML : e.get(n) ?? Ce.HTML; }
function Fg(n) { let e = new Map([["svg", Ce.SVG], ["math", Ce.Math]]); for (let [t, s] of e.entries())
    if (s === n)
        return t; return null; }
function $g(n, e) { return e === Ce.HTML ? n : `:${Fg(e)}:${n}`; }
function Ms(n) { return Array.isArray(n) ? B(n.map(Ms)) : d(n); }
function Og(n) { let e = new Map; for (let t of n.units)
    for (let s of t.create)
        if (s.kind === c.ExtractedAttribute) {
            let r = e.get(s.target) || new fl(n.compatibility);
            e.set(s.target, r), r.add(s.bindingKind, s.name, s.expression, s.namespace, s.trustedValueFn), w.remove(s);
        } if (n instanceof Xr) {
    for (let t of n.units)
        for (let s of t.create)
            if (s.kind == c.Projection) {
                let r = e.get(s.xref);
                if (r !== void 0) {
                    let i = dl(r);
                    i.entries.length > 0 && (s.attributes = i);
                }
            }
            else
                wn(s) && (s.attributes = vc(n, e, s.xref), s.kind === c.RepeaterCreate && s.emptyView !== null && (s.emptyAttributes = vc(n, e, s.emptyView)));
}
else if (n instanceof go)
    for (let [t, s] of e.entries()) {
        if (t !== n.root.xref)
            throw new Error("An attribute would be const collected into the host binding's template function, but is not associated with the root xref.");
        let r = dl(s);
        r.entries.length > 0 && (n.root.attributes = r);
    } }
function vc(n, e, t) { let s = e.get(t); if (s !== void 0) {
    let r = dl(s);
    if (r.entries.length > 0)
        return n.addConst(r);
} return null; }
var ns = Object.freeze([]), fl = class {
    compatibility;
    known = new Map;
    byKind = new Map;
    propertyBindings = null;
    projectAs = null;
    get attributes() { return this.byKind.get(I.Attribute) ?? ns; }
    get classes() { return this.byKind.get(I.ClassName) ?? ns; }
    get styles() { return this.byKind.get(I.StyleProperty) ?? ns; }
    get bindings() { return this.propertyBindings ?? ns; }
    get template() { return this.byKind.get(I.Template) ?? ns; }
    get i18n() { return this.byKind.get(I.I18n) ?? ns; }
    constructor(e) { this.compatibility = e; }
    isKnown(e, t) { let s = this.known.get(e) ?? new Set; return this.known.set(e, s), s.has(t) ? !0 : (s.add(t), !1); }
    add(e, t, s, r, i) { if (!(this.compatibility === Xe.TemplateDefinitionBuilder && (e === I.Attribute || e === I.ClassName || e === I.StyleProperty)) && this.isKnown(e, t))
        return; if (t === "ngProjectAs") {
        if (s === null || !(s instanceof ge) || s.value == null || typeof s.value?.toString() != "string")
            throw Error("ngProjectAs must have a string literal value");
        this.projectAs = s.value.toString();
    } let a = this.arrayFor(e); if (a.push(...Vg(r, t)), e === I.Attribute || e === I.StyleProperty) {
        if (s === null)
            throw Error("Attribute, i18n attribute, & style element attributes must have a value");
        if (i !== null) {
            if (!kh(s))
                throw Error("AssertionError: extracted attribute value should be string literal");
            a.push(Hp(i, new xs([new gr(s.value)], []), void 0, s.sourceSpan));
        }
        else
            a.push(s);
    } }
    arrayFor(e) { return e === I.Property || e === I.TwoWayProperty ? (this.propertyBindings ??= [], this.propertyBindings) : (this.byKind.has(e) || this.byKind.set(e, []), this.byKind.get(e)); }
};
function Vg(n, e) { let t = d(e); return n ? [d(0), d(n), t] : [t]; }
function dl({ attributes: n, bindings: e, classes: t, i18n: s, projectAs: r, styles: i, template: o }) { let a = [...n]; if (r !== null) {
    let l = $o(r)[0];
    a.push(d(5), Ms(l));
} return t.length > 0 && a.push(d(1), ...t), i.length > 0 && a.push(d(2), ...i), e.length > 0 && a.push(d(3), ...e), o.length > 0 && a.push(d(4), ...o), s.length > 0 && a.push(d(6), ...s), B(a); }
function qg(n) { let e = new Map; for (let t of n.units) {
    for (let s of t.create)
        s.kind === c.I18nAttributes && e.set(s.target, s);
    for (let s of t.update)
        switch (s.kind) {
            case c.Property:
            case c.Attribute:
                if (s.i18nContext === null || !(s.expression instanceof le))
                    continue;
                let r = e.get(s.target);
                if (r === void 0)
                    throw new Error("AssertionError: An i18n attribute binding instruction requires the owning element to have an I18nAttributes create instruction");
                if (r.target !== s.target)
                    throw new Error("AssertionError: Expected i18nAttributes target element to match binding target element");
                let i = [];
                for (let o = 0; o < s.expression.expressions.length; o++) {
                    let a = s.expression.expressions[o];
                    if (s.expression.i18nPlaceholders.length !== s.expression.expressions.length)
                        throw new Error(`AssertionError: An i18n attribute binding instruction requires the same number of expressions and placeholders, but found ${s.expression.i18nPlaceholders.length} placeholders and ${s.expression.expressions.length} expressions`);
                    i.push(bh(s.i18nContext, r.target, r.xref, r.handle, a, null, s.expression.i18nPlaceholders[o], Ur.Creation, Hs.I18nAttribute, s.name, s.sourceSpan));
                }
                w.replaceWithMany(s, i);
                break;
        }
} }
function Hg(n) { for (let e of n.units)
    for (let t of e.create)
        if (t.kind === c.Defer) {
            if (t.resolverFn !== null)
                continue;
            if (t.ownResolverFn !== null) {
                if (t.handle.slot === null)
                    throw new Error("AssertionError: slot must be assigned before extracting defer deps functions");
                let s = e.fnName?.replace("_Template", "");
                t.resolverFn = n.pool.getSharedFunctionReference(t.ownResolverFn, `${s}_Defer_${t.handle.slot}_DepsFn`, !1);
            }
        } }
function Ug(n) { let e = new Map; for (let r of n.units)
    for (let i of r.ops())
        switch (i.kind) {
            case c.Binding:
            case c.Property:
            case c.Attribute:
            case c.ExtractedAttribute:
                if (i.i18nMessage === null)
                    continue;
                if (!e.has(i.i18nMessage)) {
                    let o = ra(Nn.Attr, n.allocateXrefId(), null, i.i18nMessage, null);
                    r.create.push(o), e.set(i.i18nMessage, o.xref);
                }
                i.i18nContext = e.get(i.i18nMessage);
                break;
        } let t = new Map; for (let r of n.units)
    for (let i of r.create)
        switch (i.kind) {
            case c.I18nStart:
                if (i.xref === i.root) {
                    let o = ra(Nn.RootI18n, n.allocateXrefId(), i.xref, i.message, null);
                    r.create.push(o), i.context = o.xref, t.set(i.xref, o);
                }
                break;
        } for (let r of n.units)
    for (let i of r.create)
        if (i.kind === c.I18nStart && i.xref !== i.root) {
            let o = t.get(i.root);
            if (o === void 0)
                throw Error("AssertionError: Root i18n block i18n context should have been created.");
            i.context = o.xref, t.set(i.xref, o);
        } let s = null; for (let r of n.units)
    for (let i of r.create)
        switch (i.kind) {
            case c.I18nStart:
                s = i;
                break;
            case c.I18nEnd:
                s = null;
                break;
            case c.IcuStart:
                if (s === null)
                    throw Error("AssertionError: Unexpected ICU outside of an i18n block.");
                if (i.message.id !== s.message.id) {
                    let o = ra(Nn.Icu, n.allocateXrefId(), s.root, i.message, null);
                    r.create.push(o), i.context = o.xref;
                }
                else
                    i.context = s.context, t.get(s.xref).contextKind = Nn.Icu;
                break;
        } }
function Wg(n) { let e = new Map; for (let t of n.units)
    for (let s of t.update.reversed())
        if (s.kind === c.Binding && s.isTextAttribute) {
            let r = e.get(s.target) || new Set;
            r.has(s.name) && n.compatibility === Xe.TemplateDefinitionBuilder && (s.name === "style" || s.name === "class") && w.remove(s), r.add(s.name), e.set(s.target, r);
        } }
function jg(n) { for (let e of n.units)
    for (let t of e.create)
        t.kind === c.Defer && (t.placeholderMinimumTime !== null && (t.placeholderConfig = new Gr(Ms([t.placeholderMinimumTime]))), (t.loadingMinimumTime !== null || t.loadingAfterTime !== null) && (t.loadingConfig = new Gr(Ms([t.loadingMinimumTime, t.loadingAfterTime])))); }
function zg(n) { let e = new Map; function t(r) { if (e.has(r.xref))
    return e.get(r.xref); let i = new Gg; for (let o of r.create)
    if (!(!wn(o) || o.localRefs === null)) {
        if (!Array.isArray(o.localRefs))
            throw new Error("LocalRefs were already processed, but were needed to resolve defer targets.");
        for (let a of o.localRefs)
            a.target === "" && i.targets.set(a.name, { xref: o.xref, slot: o.handle });
    } return e.set(r.xref, i), i; } function s(r, i, o) { switch (i.trigger.kind) {
    case X.Idle:
    case X.Never:
    case X.Immediate:
    case X.Timer: return;
    case X.Hover:
    case X.Interaction:
    case X.Viewport:
        if (i.trigger.targetName === null) {
            if (o === null)
                throw new Error("defer on trigger with no target name must have a placeholder block");
            let u = n.views.get(o);
            if (u == null)
                throw new Error("AssertionError: could not find placeholder view for defer on trigger");
            for (let p of u.create)
                if (Ws(p) && (wn(p) || p.kind === c.Projection)) {
                    i.trigger.targetXref = p.xref, i.trigger.targetView = o, i.trigger.targetSlotViewSteps = -1, i.trigger.targetSlot = p.handle;
                    return;
                }
            return;
        }
        let a = o !== null ? n.views.get(o) : r, l = o !== null ? -1 : 0;
        for (; a !== null;) {
            let u = t(a);
            if (u.targets.has(i.trigger.targetName)) {
                let { xref: p, slot: f } = u.targets.get(i.trigger.targetName);
                i.trigger.targetXref = p, i.trigger.targetView = a.xref, i.trigger.targetSlotViewSteps = l, i.trigger.targetSlot = f;
                return;
            }
            a = a.parent !== null ? n.views.get(a.parent) : null, l++;
        }
        break;
    default: throw new Error(`Trigger kind ${i.trigger.kind} not handled`);
} } for (let r of n.units) {
    let i = new Map;
    for (let o of r.create)
        switch (o.kind) {
            case c.Defer:
                i.set(o.xref, o);
                break;
            case c.DeferOn:
                let a = i.get(o.defer);
                s(r, o, o.modifier === "hydrate" ? a.mainView : a.placeholderView);
                break;
        }
} }
var Gg = class {
    targets = new Map;
}, Xg = new Map([[c.ElementEnd, [c.ElementStart, c.Element]], [c.ContainerEnd, [c.ContainerStart, c.Container]], [c.I18nEnd, [c.I18nStart, c.I18n]]]), Yg = new Set([c.Pipe]);
function Qg(n) { for (let e of n.units)
    for (let t of e.create) {
        let s = Xg.get(t.kind);
        if (s === void 0)
            continue;
        let [r, i] = s, o = t.prev;
        for (; o !== null && Yg.has(o.kind);)
            o = o.prev;
        o !== null && o.kind === r && (o.kind = i, w.remove(t));
    } }
function Zg(n) { for (let e of n.units)
    for (let t of e.ops())
        ce(t, s => sv(s, { job: n }), z.None), ce(t, rv, z.None); }
function Qe(n) { return n instanceof hn ? Qe(n.expr) : n instanceof W ? Qe(n.lhs) || Qe(n.rhs) : n instanceof kt ? n.falseCase && Qe(n.falseCase) ? !0 : Qe(n.condition) || Qe(n.trueCase) : n instanceof ys ? Qe(n.condition) : n instanceof Et ? Qe(n.expr) : n instanceof Me ? Qe(n.receiver) : n instanceof It ? Qe(n.receiver) || Qe(n.index) : n instanceof Ie || n instanceof at || n instanceof gt || n instanceof Kn || n instanceof Ds; }
function Jg(n) { let e = new Set; return A(n, t => (t instanceof Et && e.add(t.xref), t), z.None), e; }
function Kg(n, e, t) { return A(n, s => { if (s instanceof Et && e.has(s.xref)) {
    let r = new Xt(s.xref);
    return t.job.compatibility === Xe.TemplateDefinitionBuilder ? new Et(r, r.xref) : r;
} return s; }, z.None), n; }
function ss(n, e, t) { let s; if (Qe(n)) {
    let r = t.job.allocateXrefId();
    s = [new Et(n, r), new Xt(r)];
}
else
    s = [n, n.clone()], Kg(s[1], Jg(s[0]), t); return new Bs(s[0], e(s[1])); }
function ev(n) { return n instanceof Ps || n instanceof Ls || n instanceof Kn; }
function tv(n) { return n instanceof Me || n instanceof It || n instanceof Ie; }
function Mh(n) { return ev(n) || tv(n); }
function nv(n) { if (Mh(n) && n.receiver instanceof Bs) {
    let e = n.receiver;
    for (; e.expr instanceof Bs;)
        e = e.expr;
    return e;
} return null; }
function sv(n, e) { if (!Mh(n))
    return n; let t = nv(n); if (t) {
    if (n instanceof Ie)
        return t.expr = t.expr.callFn(n.args), n.receiver;
    if (n instanceof Me)
        return t.expr = t.expr.prop(n.name), n.receiver;
    if (n instanceof It)
        return t.expr = t.expr.key(n.index), n.receiver;
    if (n instanceof Kn)
        return t.expr = ss(t.expr, s => s.callFn(n.args), e), n.receiver;
    if (n instanceof Ps)
        return t.expr = ss(t.expr, s => s.prop(n.name), e), n.receiver;
    if (n instanceof Ls)
        return t.expr = ss(t.expr, s => s.key(n.index), e), n.receiver;
}
else {
    if (n instanceof Kn)
        return ss(n.receiver, s => s.callFn(n.args), e);
    if (n instanceof Ps)
        return ss(n.receiver, s => s.prop(n.name), e);
    if (n instanceof Ls)
        return ss(n.receiver, s => s.key(n.index), e);
} return n; }
function rv(n) { return n instanceof Bs ? new kt(new W(b.Equals, n.guard, Wn), Wn, n.expr) : n; }
var wc = "\uFFFD", iv = "#", ov = "*", av = "/", lv = ":", uv = "[", cv = "]", pv = "|";
function hv(n) { let e = new Map, t = new Map, s = new Map; for (let i of n.units)
    for (let o of i.create)
        switch (o.kind) {
            case c.I18nContext:
                let a = fv(n, o);
                i.create.push(a), e.set(o.xref, a), s.set(o.xref, o);
                break;
            case c.I18nStart:
                t.set(o.xref, o);
                break;
        } let r = null; for (let i of n.units)
    for (let o of i.create)
        switch (o.kind) {
            case c.IcuStart:
                r = o, w.remove(o);
                let a = s.get(o.context);
                if (a.contextKind !== Nn.Icu)
                    continue;
                let l = t.get(a.i18nBlock);
                if (l.context === a.xref)
                    continue;
                let u = t.get(l.root), p = e.get(u.context);
                if (p === void 0)
                    throw Error("AssertionError: ICU sub-message should belong to a root message.");
                let f = e.get(a.xref);
                f.messagePlaceholder = o.messagePlaceholder, p.subMessages.push(f.xref);
                break;
            case c.IcuEnd:
                r = null, w.remove(o);
                break;
            case c.IcuPlaceholder:
                if (r === null || r.context == null)
                    throw Error("AssertionError: Unexpected ICU placeholder outside of i18n context");
                e.get(r.context).postprocessingParams.set(o.name, d(dv(o))), w.remove(o);
                break;
        } }
function fv(n, e, t) { let s = Ec(e.params), r = Ec(e.postprocessingParams), i = [...e.params.values()].some(o => o.length > 1); return gg(n.allocateXrefId(), e.xref, e.i18nBlock, e.message, null, s, r, i); }
function dv(n) { if (n.strings.length !== n.expressionPlaceholders.length + 1)
    throw Error(`AssertionError: Invalid ICU placeholder with ${n.strings.length} strings and ${n.expressionPlaceholders.length} expressions`); let e = n.expressionPlaceholders.map(fs); return n.strings.flatMap((t, s) => [t, e[s] || ""]).join(""); }
function Ec(n) { let e = new Map; for (let [t, s] of n) {
    let r = mv(s);
    r !== null && e.set(t, d(r));
} return e; }
function mv(n) { if (n.length === 0)
    return null; let e = n.map(t => fs(t)); return e.length === 1 ? e[0] : `${uv}${e.join(pv)}${cv}`; }
function fs(n) { if (n.flags & J.ElementTag && n.flags & J.TemplateTag) {
    if (typeof n.value != "object")
        throw Error("AssertionError: Expected i18n param value to have an element and template slot");
    let r = fs(ae(E({}, n), { value: n.value.element, flags: n.flags & ~J.TemplateTag })), i = fs(ae(E({}, n), { value: n.value.template, flags: n.flags & ~J.ElementTag }));
    return n.flags & J.OpenTag && n.flags & J.CloseTag ? `${i}${r}${i}` : n.flags & J.CloseTag ? `${r}${i}` : `${i}${r}`;
} if (n.flags & J.OpenTag && n.flags & J.CloseTag)
    return `${fs(ae(E({}, n), { flags: n.flags & ~J.CloseTag }))}${fs(ae(E({}, n), { flags: n.flags & ~J.OpenTag }))}`; if (n.flags === J.None)
    return `${n.value}`; let e = "", t = ""; n.flags & J.ElementTag ? e = iv : n.flags & J.TemplateTag && (e = ov), e !== "" && (t = n.flags & J.CloseTag ? av : ""); let s = n.subTemplateIndex === null ? "" : `${lv}${n.subTemplateIndex}`; return `${wc}${t}${e}${n.value}${s}${wc}`; }
function gv(n) { for (let e of n.units) {
    let t = new Map;
    for (let r of e.create) {
        if (Ws(r)) {
            if (r.handle.slot === null)
                throw new Error("AssertionError: expected slots to have been allocated before generating advance() calls");
        }
        else
            continue;
        t.set(r.xref, r.handle.slot);
    }
    let s = 0;
    for (let r of e.update) {
        let i = null;
        if (ro(r) ? i = r : _e(r, a => { i === null && ro(a) && (i = a); }), i === null)
            continue;
        if (!t.has(i.target))
            throw new Error(`AssertionError: reference to unknown slot for target ${i.target}`);
        let o = t.get(i.target);
        if (s !== o) {
            let a = o - s;
            if (a < 0)
                throw new Error("AssertionError: slot counter should never need to move backwards");
            w.insertBefore(eg(a, i.sourceSpan), r), s = o;
        }
    }
} }
function vv(n) { let e = n.compatibility === Xe.TemplateDefinitionBuilder, t = [], s = 0; for (let r of n.units)
    for (let i of r.create)
        i.kind === c.Projection && (t.push(i.selector), i.projectionSlotIndex = s++); if (t.length > 0) {
    let r = null;
    if (t.length > 1 || t[0] !== "*") {
        let i = t.map(o => o === "*" ? o : $o(o));
        r = n.pool.getConstLiteral(Ms(i), e);
    }
    n.contentSelectors = n.pool.getConstLiteral(Ms(t), e), n.root.create.prepend([hg(r)]);
} }
function wv(n) { tr(n.root, null); }
function tr(n, e) { let t = Ev(n, e); for (let s of n.create)
    switch (s.kind) {
        case c.Template:
            tr(n.job.views.get(s.xref), t);
            break;
        case c.Projection:
            s.fallbackView !== null && tr(n.job.views.get(s.fallbackView), t);
            break;
        case c.RepeaterCreate:
            tr(n.job.views.get(s.xref), t), s.emptyView && tr(n.job.views.get(s.emptyView), t), s.trackByOps !== null && s.trackByOps.prepend(xi(n, t, !1));
            break;
        case c.Listener:
        case c.TwoWayListener:
            s.handlerOps.prepend(xi(n, t, !0));
            break;
    } n.update.prepend(xi(n, t, !1)); }
function Ev(n, e) { let t = { view: n.xref, viewContextVariable: { kind: we.Context, name: null, view: n.xref }, contextVariables: new Map, aliases: n.aliases, references: [], letDeclarations: [], parent: e }; for (let s of n.contextVariables.keys())
    t.contextVariables.set(s, { kind: we.Identifier, name: null, identifier: s, local: !1 }); for (let s of n.create)
    switch (s.kind) {
        case c.ElementStart:
        case c.Template:
            if (!Array.isArray(s.localRefs))
                throw new Error("AssertionError: expected localRefs to be an array");
            for (let r = 0; r < s.localRefs.length; r++)
                t.references.push({ name: s.localRefs[r].name, targetId: s.xref, targetSlot: s.handle, offset: r, variable: { kind: we.Identifier, name: null, identifier: s.localRefs[r].name, local: !1 } });
            break;
        case c.DeclareLet:
            t.letDeclarations.push({ targetId: s.xref, targetSlot: s.handle, variable: { kind: we.Identifier, name: null, identifier: s.declaredName, local: !1 } });
            break;
    } return t; }
function xi(n, e, t) { let s = []; e.view !== n.xref && s.push(on(n.job.allocateXrefId(), e.viewContextVariable, new oo, tt.None)); let r = n.job.views.get(e.view); for (let [i, o] of r.contextVariables) {
    let a = new Gt(e.view), l = o === Lh ? a : new Me(a, o);
    s.push(on(n.job.allocateXrefId(), e.contextVariables.get(i), l, tt.None));
} for (let i of r.aliases)
    s.push(on(n.job.allocateXrefId(), i, i.expression.clone(), tt.AlwaysInline)); for (let i of e.references)
    s.push(on(n.job.allocateXrefId(), i.variable, new io(i.targetId, i.targetSlot, i.offset), tt.None)); if (e.view !== n.xref || t)
    for (let i of e.letDeclarations)
        s.push(on(n.job.allocateXrefId(), i.variable, new jr(i.targetId, i.targetSlot), tt.None)); return e.parent !== null && s.push(...xi(n, e.parent, !1)), s; }
function Sv(n) { for (let e of n.units)
    for (let t of e.ops())
        ce(t, s => s instanceof Gr ? d(n.addConst(s.expr)) : s, z.None); }
var Sc = "style.", xc = "class.", xv = "style!", yc = "class!", Cc = "!important";
function yv(n) { for (let e of n.root.update)
    if (e.kind === c.Binding && e.bindingKind === I.Property)
        if (e.name.endsWith(Cc) && (e.name = e.name.substring(0, e.name.length - Cc.length)), e.name.startsWith(Sc)) {
            e.bindingKind = I.StyleProperty, e.name = e.name.substring(Sc.length), Cv(e.name) || (e.name = Av(e.name));
            let { property: t, suffix: s } = ia(e.name);
            e.name = t, e.unit = s;
        }
        else
            e.name.startsWith(xv) ? (e.bindingKind = I.StyleProperty, e.name = "style") : e.name.startsWith(xc) ? (e.bindingKind = I.ClassName, e.name = ia(e.name.substring(xc.length)).property) : e.name.startsWith(yc) && (e.bindingKind = I.ClassName, e.name = ia(e.name.substring(yc.length)).property); }
function Cv(n) { return n.startsWith("--"); }
function Av(n) { return n.replace(/[a-z][A-Z]/g, e => e.charAt(0) + "-" + e.charAt(1)).toLowerCase(); }
function ia(n) { let e = n.indexOf("!important"); e !== -1 && (n = e > 0 ? n.substring(0, e) : ""); let t = null, s = n, r = n.lastIndexOf("."); return r > 0 && (t = n.slice(r + 1), s = n.substring(0, r)), { property: s, suffix: t }; }
function vo(n, e = !1) { return ue(Object.keys(n).map(t => ({ key: t, quoted: e, value: n[t] }))); }
var ml = class {
    visitText(e) { return e.value; }
    visitContainer(e) { return e.children.map(t => t.visit(this)).join(""); }
    visitIcu(e) { let t = Object.keys(e.cases).map(r => `${r} {${e.cases[r].visit(this)}}`); return `{${e.expressionPlaceholder}, ${e.type}, ${t.join(" ")}}`; }
    visitTagPlaceholder(e) { return e.isVoid ? this.formatPh(e.startName) : `${this.formatPh(e.startName)}${e.children.map(t => t.visit(this)).join("")}${this.formatPh(e.closeName)}`; }
    visitPlaceholder(e) { return this.formatPh(e.name); }
    visitBlockPlaceholder(e) { return `${this.formatPh(e.startName)}${e.children.map(t => t.visit(this)).join("")}${this.formatPh(e.closeName)}`; }
    visitIcuPlaceholder(e, t) { return this.formatPh(e.name); }
    formatPh(e) { return `{${oi(e, !1)}}`; }
}, _v = new ml;
function Rh(n) { return n.visit(_v); }
var En = class {
    sourceSpan;
    i18n;
    constructor(e, t) { this.sourceSpan = e, this.i18n = t; }
}, Yt = class extends En {
    value;
    tokens;
    constructor(e, t, s, r) { super(t, r), this.value = e, this.tokens = s; }
    visit(e, t) { return e.visitText(this, t); }
}, un = class extends En {
    switchValue;
    type;
    cases;
    switchValueSourceSpan;
    constructor(e, t, s, r, i, o) { super(r, o), this.switchValue = e, this.type = t, this.cases = s, this.switchValueSourceSpan = i; }
    visit(e, t) { return e.visitExpansion(this, t); }
}, Yr = class {
    value;
    expression;
    sourceSpan;
    valueSourceSpan;
    expSourceSpan;
    constructor(e, t, s, r, i) { this.value = e, this.expression = t, this.sourceSpan = s, this.valueSourceSpan = r, this.expSourceSpan = i; }
    visit(e, t) { return e.visitExpansionCase(this, t); }
}, Rs = class extends En {
    name;
    value;
    keySpan;
    valueSpan;
    valueTokens;
    constructor(e, t, s, r, i, o, a) { super(s, a), this.name = e, this.value = t, this.keySpan = r, this.valueSpan = i, this.valueTokens = o; }
    visit(e, t) { return e.visitAttribute(this, t); }
}, De = class extends En {
    name;
    attrs;
    children;
    startSourceSpan;
    endSourceSpan;
    constructor(e, t, s, r, i, o = null, a) { super(r, a), this.name = e, this.attrs = t, this.children = s, this.startSourceSpan = i, this.endSourceSpan = o; }
    visit(e, t) { return e.visitElement(this, t); }
}, Sn = class {
    value;
    sourceSpan;
    constructor(e, t) { this.value = e, this.sourceSpan = t; }
    visit(e, t) { return e.visitComment(this, t); }
}, Je = class extends En {
    name;
    parameters;
    children;
    nameSpan;
    startSourceSpan;
    endSourceSpan;
    constructor(e, t, s, r, i, o, a = null, l) { super(r, l), this.name = e, this.parameters = t, this.children = s, this.nameSpan = i, this.startSourceSpan = o, this.endSourceSpan = a; }
    visit(e, t) { return e.visitBlock(this, t); }
}, wo = class {
    expression;
    sourceSpan;
    constructor(e, t) { this.expression = e, this.sourceSpan = t; }
    visit(e, t) { return e.visitBlockParameter(this, t); }
}, Eo = class {
    name;
    value;
    sourceSpan;
    nameSpan;
    valueSpan;
    constructor(e, t, s, r, i) { this.name = e, this.value = t, this.sourceSpan = s, this.nameSpan = r, this.valueSpan = i; }
    visit(e, t) { return e.visitLetDeclaration(this, t); }
};
function D(n, e, t = null) { let s = [], r = n.visit ? i => n.visit(i, t) || i.visit(n, t) : i => i.visit(n, t); return e.forEach(i => { let o = r(i); o && s.push(o); }), s; }
var Ac = class {
    constructor() { }
    visitElement(e, t) { this.visitChildren(t, s => { s(e.attrs), s(e.children); }); }
    visitAttribute(e, t) { }
    visitText(e, t) { }
    visitComment(e, t) { }
    visitExpansion(e, t) { return this.visitChildren(t, s => { s(e.cases); }); }
    visitExpansionCase(e, t) { }
    visitBlock(e, t) { this.visitChildren(t, s => { s(e.parameters), s(e.children); }); }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    visitChildren(e, t) { let s = [], r = this; function i(o) { o && s.push(D(r, o, e)); } return t(i), Array.prototype.concat.apply([], s); }
}, Qr = { AElig: "\xC6", AMP: "&", amp: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\uD835\uDD04", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\uD835\uDD38", ApplyFunction: "\u2061", af: "\u2061", Aring: "\xC5", angst: "\xC5", Ascr: "\uD835\uDC9C", Assign: "\u2254", colone: "\u2254", coloneq: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", setminus: "\u2216", setmn: "\u2216", smallsetminus: "\u2216", ssetmn: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", doublebarwedge: "\u2306", Bcy: "\u0411", Because: "\u2235", becaus: "\u2235", because: "\u2235", Bernoullis: "\u212C", Bscr: "\u212C", bernou: "\u212C", Beta: "\u0392", Bfr: "\uD835\uDD05", Bopf: "\uD835\uDD39", Breve: "\u02D8", breve: "\u02D8", Bumpeq: "\u224E", HumpDownHump: "\u224E", bump: "\u224E", CHcy: "\u0427", COPY: "\xA9", copy: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", DD: "\u2145", Cayleys: "\u212D", Cfr: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", cedil: "\xB8", CenterDot: "\xB7", centerdot: "\xB7", middot: "\xB7", Chi: "\u03A7", CircleDot: "\u2299", odot: "\u2299", CircleMinus: "\u2296", ominus: "\u2296", CirclePlus: "\u2295", oplus: "\u2295", CircleTimes: "\u2297", otimes: "\u2297", ClockwiseContourIntegral: "\u2232", cwconint: "\u2232", CloseCurlyDoubleQuote: "\u201D", rdquo: "\u201D", rdquor: "\u201D", CloseCurlyQuote: "\u2019", rsquo: "\u2019", rsquor: "\u2019", Colon: "\u2237", Proportion: "\u2237", Colone: "\u2A74", Congruent: "\u2261", equiv: "\u2261", Conint: "\u222F", DoubleContourIntegral: "\u222F", ContourIntegral: "\u222E", conint: "\u222E", oint: "\u222E", Copf: "\u2102", complexes: "\u2102", Coproduct: "\u2210", coprod: "\u2210", CounterClockwiseContourIntegral: "\u2233", awconint: "\u2233", Cross: "\u2A2F", Cscr: "\uD835\uDC9E", Cup: "\u22D3", CupCap: "\u224D", asympeq: "\u224D", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", ddagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", DoubleLeftTee: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", nabla: "\u2207", Delta: "\u0394", Dfr: "\uD835\uDD07", DiacriticalAcute: "\xB4", acute: "\xB4", DiacriticalDot: "\u02D9", dot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", dblac: "\u02DD", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "\u02DC", tilde: "\u02DC", Diamond: "\u22C4", diam: "\u22C4", diamond: "\u22C4", DifferentialD: "\u2146", dd: "\u2146", Dopf: "\uD835\uDD3B", Dot: "\xA8", DoubleDot: "\xA8", die: "\xA8", uml: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", doteq: "\u2250", esdot: "\u2250", DoubleDownArrow: "\u21D3", Downarrow: "\u21D3", dArr: "\u21D3", DoubleLeftArrow: "\u21D0", Leftarrow: "\u21D0", lArr: "\u21D0", DoubleLeftRightArrow: "\u21D4", Leftrightarrow: "\u21D4", hArr: "\u21D4", iff: "\u21D4", DoubleLongLeftArrow: "\u27F8", Longleftarrow: "\u27F8", xlArr: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", Longleftrightarrow: "\u27FA", xhArr: "\u27FA", DoubleLongRightArrow: "\u27F9", Longrightarrow: "\u27F9", xrArr: "\u27F9", DoubleRightArrow: "\u21D2", Implies: "\u21D2", Rightarrow: "\u21D2", rArr: "\u21D2", DoubleRightTee: "\u22A8", vDash: "\u22A8", DoubleUpArrow: "\u21D1", Uparrow: "\u21D1", uArr: "\u21D1", DoubleUpDownArrow: "\u21D5", Updownarrow: "\u21D5", vArr: "\u21D5", DoubleVerticalBar: "\u2225", par: "\u2225", parallel: "\u2225", shortparallel: "\u2225", spar: "\u2225", DownArrow: "\u2193", ShortDownArrow: "\u2193", darr: "\u2193", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", duarr: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", leftharpoondown: "\u21BD", lhard: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", rhard: "\u21C1", rightharpoondown: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", top: "\u22A4", DownTeeArrow: "\u21A7", mapstodown: "\u21A7", Dscr: "\uD835\uDC9F", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\uD835\uDD08", Egrave: "\xC8", Element: "\u2208", in: "\u2208", isin: "\u2208", isinv: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\uD835\uDD3C", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", eqsim: "\u2242", esim: "\u2242", Equilibrium: "\u21CC", rightleftharpoons: "\u21CC", rlhar: "\u21CC", Escr: "\u2130", expectation: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", exist: "\u2203", ExponentialE: "\u2147", ee: "\u2147", exponentiale: "\u2147", Fcy: "\u0424", Ffr: "\uD835\uDD09", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", blacksquare: "\u25AA", squarf: "\u25AA", squf: "\u25AA", Fopf: "\uD835\uDD3D", ForAll: "\u2200", forall: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", gt: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\uD835\uDD0A", Gg: "\u22D9", ggg: "\u22D9", Gopf: "\uD835\uDD3E", GreaterEqual: "\u2265", ge: "\u2265", geq: "\u2265", GreaterEqualLess: "\u22DB", gel: "\u22DB", gtreqless: "\u22DB", GreaterFullEqual: "\u2267", gE: "\u2267", geqq: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", gl: "\u2277", gtrless: "\u2277", GreaterSlantEqual: "\u2A7E", geqslant: "\u2A7E", ges: "\u2A7E", GreaterTilde: "\u2273", gsim: "\u2273", gtrsim: "\u2273", Gscr: "\uD835\uDCA2", Gt: "\u226B", NestedGreaterGreater: "\u226B", gg: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", caron: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", Poincareplane: "\u210C", HilbertSpace: "\u210B", Hscr: "\u210B", hamilt: "\u210B", Hopf: "\u210D", quaternions: "\u210D", HorizontalLine: "\u2500", boxh: "\u2500", Hstrok: "\u0126", HumpEqual: "\u224F", bumpe: "\u224F", bumpeq: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Im: "\u2111", image: "\u2111", imagpart: "\u2111", Igrave: "\xCC", Imacr: "\u012A", ImaginaryI: "\u2148", ii: "\u2148", Int: "\u222C", Integral: "\u222B", int: "\u222B", Intersection: "\u22C2", bigcap: "\u22C2", xcap: "\u22C2", InvisibleComma: "\u2063", ic: "\u2063", InvisibleTimes: "\u2062", it: "\u2062", Iogon: "\u012E", Iopf: "\uD835\uDD40", Iota: "\u0399", Iscr: "\u2110", imagline: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\uD835\uDD0D", Jopf: "\uD835\uDD41", Jscr: "\uD835\uDCA5", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\uD835\uDD0E", Kopf: "\uD835\uDD42", Kscr: "\uD835\uDCA6", LJcy: "\u0409", LT: "<", lt: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Lscr: "\u2112", lagran: "\u2112", Larr: "\u219E", twoheadleftarrow: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", lang: "\u27E8", langle: "\u27E8", LeftArrow: "\u2190", ShortLeftArrow: "\u2190", larr: "\u2190", leftarrow: "\u2190", slarr: "\u2190", LeftArrowBar: "\u21E4", larrb: "\u21E4", LeftArrowRightArrow: "\u21C6", leftrightarrows: "\u21C6", lrarr: "\u21C6", LeftCeiling: "\u2308", lceil: "\u2308", LeftDoubleBracket: "\u27E6", lobrk: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", dharl: "\u21C3", downharpoonleft: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", lfloor: "\u230A", LeftRightArrow: "\u2194", harr: "\u2194", leftrightarrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", dashv: "\u22A3", LeftTeeArrow: "\u21A4", mapstoleft: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", vartriangleleft: "\u22B2", vltri: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", ltrie: "\u22B4", trianglelefteq: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", uharl: "\u21BF", upharpoonleft: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", leftharpoonup: "\u21BC", lharu: "\u21BC", LeftVectorBar: "\u2952", LessEqualGreater: "\u22DA", leg: "\u22DA", lesseqgtr: "\u22DA", LessFullEqual: "\u2266", lE: "\u2266", leqq: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", lg: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", leqslant: "\u2A7D", les: "\u2A7D", LessTilde: "\u2272", lesssim: "\u2272", lsim: "\u2272", Lfr: "\uD835\uDD0F", Ll: "\u22D8", Lleftarrow: "\u21DA", lAarr: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", longleftarrow: "\u27F5", xlarr: "\u27F5", LongLeftRightArrow: "\u27F7", longleftrightarrow: "\u27F7", xharr: "\u27F7", LongRightArrow: "\u27F6", longrightarrow: "\u27F6", xrarr: "\u27F6", Lopf: "\uD835\uDD43", LowerLeftArrow: "\u2199", swarr: "\u2199", swarrow: "\u2199", LowerRightArrow: "\u2198", searr: "\u2198", searrow: "\u2198", Lsh: "\u21B0", lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", NestedLessLess: "\u226A", ll: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mscr: "\u2133", phmmat: "\u2133", Mfr: "\uD835\uDD10", MinusPlus: "\u2213", mnplus: "\u2213", mp: "\u2213", Mopf: "\uD835\uDD44", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", ZeroWidthSpace: "\u200B", NewLine: `
`, Nfr: "\uD835\uDD11", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nbsp: "\xA0", Nopf: "\u2115", naturals: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", nequiv: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", npar: "\u2226", nparallel: "\u2226", nshortparallel: "\u2226", nspar: "\u2226", NotElement: "\u2209", notin: "\u2209", notinva: "\u2209", NotEqual: "\u2260", ne: "\u2260", NotEqualTilde: "\u2242\u0338", nesim: "\u2242\u0338", NotExists: "\u2204", nexist: "\u2204", nexists: "\u2204", NotGreater: "\u226F", ngt: "\u226F", ngtr: "\u226F", NotGreaterEqual: "\u2271", nge: "\u2271", ngeq: "\u2271", NotGreaterFullEqual: "\u2267\u0338", ngE: "\u2267\u0338", ngeqq: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", nGtv: "\u226B\u0338", NotGreaterLess: "\u2279", ntgl: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", NotGreaterTilde: "\u2275", ngsim: "\u2275", NotHumpDownHump: "\u224E\u0338", nbump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", nbumpe: "\u224F\u0338", NotLeftTriangle: "\u22EA", nltri: "\u22EA", ntriangleleft: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", nltrie: "\u22EC", ntrianglelefteq: "\u22EC", NotLess: "\u226E", nless: "\u226E", nlt: "\u226E", NotLessEqual: "\u2270", nle: "\u2270", nleq: "\u2270", NotLessGreater: "\u2278", ntlg: "\u2278", NotLessLess: "\u226A\u0338", nLtv: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", NotLessTilde: "\u2274", nlsim: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", npr: "\u2280", nprec: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", npre: "\u2AAF\u0338", npreceq: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", nprcue: "\u22E0", NotReverseElement: "\u220C", notni: "\u220C", notniva: "\u220C", NotRightTriangle: "\u22EB", nrtri: "\u22EB", ntriangleright: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", nrtrie: "\u22ED", ntrianglerighteq: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", nsqsube: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", nsqsupe: "\u22E3", NotSubset: "\u2282\u20D2", nsubset: "\u2282\u20D2", vnsub: "\u2282\u20D2", NotSubsetEqual: "\u2288", nsube: "\u2288", nsubseteq: "\u2288", NotSucceeds: "\u2281", nsc: "\u2281", nsucc: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", nsce: "\u2AB0\u0338", nsucceq: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", nsccue: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", nsupset: "\u2283\u20D2", vnsup: "\u2283\u20D2", NotSupersetEqual: "\u2289", nsupe: "\u2289", nsupseteq: "\u2289", NotTilde: "\u2241", nsim: "\u2241", NotTildeEqual: "\u2244", nsime: "\u2244", nsimeq: "\u2244", NotTildeFullEqual: "\u2247", ncong: "\u2247", NotTildeTilde: "\u2249", nap: "\u2249", napprox: "\u2249", NotVerticalBar: "\u2224", nmid: "\u2224", nshortmid: "\u2224", nsmid: "\u2224", Nscr: "\uD835\uDCA9", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\uD835\uDD12", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", ohm: "\u03A9", Omicron: "\u039F", Oopf: "\uD835\uDD46", OpenCurlyDoubleQuote: "\u201C", ldquo: "\u201C", OpenCurlyQuote: "\u2018", lsquo: "\u2018", Or: "\u2A54", Oscr: "\uD835\uDCAA", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", oline: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", tbrk: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", part: "\u2202", Pcy: "\u041F", Pfr: "\uD835\uDD13", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", plusmn: "\xB1", pm: "\xB1", Popf: "\u2119", primes: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", pr: "\u227A", prec: "\u227A", PrecedesEqual: "\u2AAF", pre: "\u2AAF", preceq: "\u2AAF", PrecedesSlantEqual: "\u227C", prcue: "\u227C", preccurlyeq: "\u227C", PrecedesTilde: "\u227E", precsim: "\u227E", prsim: "\u227E", Prime: "\u2033", Product: "\u220F", prod: "\u220F", Proportional: "\u221D", prop: "\u221D", propto: "\u221D", varpropto: "\u221D", vprop: "\u221D", Pscr: "\uD835\uDCAB", Psi: "\u03A8", QUOT: "\"", quot: "\"", Qfr: "\uD835\uDD14", Qopf: "\u211A", rationals: "\u211A", Qscr: "\uD835\uDCAC", RBarr: "\u2910", drbkarow: "\u2910", REG: "\xAE", circledR: "\xAE", reg: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", twoheadrightarrow: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", Rfr: "\u211C", real: "\u211C", realpart: "\u211C", ReverseElement: "\u220B", SuchThat: "\u220B", ni: "\u220B", niv: "\u220B", ReverseEquilibrium: "\u21CB", leftrightharpoons: "\u21CB", lrhar: "\u21CB", ReverseUpEquilibrium: "\u296F", duhar: "\u296F", Rho: "\u03A1", RightAngleBracket: "\u27E9", rang: "\u27E9", rangle: "\u27E9", RightArrow: "\u2192", ShortRightArrow: "\u2192", rarr: "\u2192", rightarrow: "\u2192", srarr: "\u2192", RightArrowBar: "\u21E5", rarrb: "\u21E5", RightArrowLeftArrow: "\u21C4", rightleftarrows: "\u21C4", rlarr: "\u21C4", RightCeiling: "\u2309", rceil: "\u2309", RightDoubleBracket: "\u27E7", robrk: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", dharr: "\u21C2", downharpoonright: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rfloor: "\u230B", RightTee: "\u22A2", vdash: "\u22A2", RightTeeArrow: "\u21A6", map: "\u21A6", mapsto: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", vartriangleright: "\u22B3", vrtri: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", rtrie: "\u22B5", trianglerighteq: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", uharr: "\u21BE", upharpoonright: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", rharu: "\u21C0", rightharpoonup: "\u21C0", RightVectorBar: "\u2953", Ropf: "\u211D", reals: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", rAarr: "\u21DB", Rscr: "\u211B", realine: "\u211B", Rsh: "\u21B1", rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\uD835\uDD16", ShortUpArrow: "\u2191", UpArrow: "\u2191", uarr: "\u2191", uparrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", compfn: "\u2218", Sopf: "\uD835\uDD4A", Sqrt: "\u221A", radic: "\u221A", Square: "\u25A1", squ: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", sqcap: "\u2293", SquareSubset: "\u228F", sqsub: "\u228F", sqsubset: "\u228F", SquareSubsetEqual: "\u2291", sqsube: "\u2291", sqsubseteq: "\u2291", SquareSuperset: "\u2290", sqsup: "\u2290", sqsupset: "\u2290", SquareSupersetEqual: "\u2292", sqsupe: "\u2292", sqsupseteq: "\u2292", SquareUnion: "\u2294", sqcup: "\u2294", Sscr: "\uD835\uDCAE", Star: "\u22C6", sstarf: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", sube: "\u2286", subseteq: "\u2286", Succeeds: "\u227B", sc: "\u227B", succ: "\u227B", SucceedsEqual: "\u2AB0", sce: "\u2AB0", succeq: "\u2AB0", SucceedsSlantEqual: "\u227D", sccue: "\u227D", succcurlyeq: "\u227D", SucceedsTilde: "\u227F", scsim: "\u227F", succsim: "\u227F", Sum: "\u2211", sum: "\u2211", Sup: "\u22D1", Supset: "\u22D1", Superset: "\u2283", sup: "\u2283", supset: "\u2283", SupersetEqual: "\u2287", supe: "\u2287", supseteq: "\u2287", THORN: "\xDE", TRADE: "\u2122", trade: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "\t", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\uD835\uDD17", Therefore: "\u2234", there4: "\u2234", therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", Tilde: "\u223C", sim: "\u223C", thicksim: "\u223C", thksim: "\u223C", TildeEqual: "\u2243", sime: "\u2243", simeq: "\u2243", TildeFullEqual: "\u2245", cong: "\u2245", TildeTilde: "\u2248", ap: "\u2248", approx: "\u2248", asymp: "\u2248", thickapprox: "\u2248", thkap: "\u2248", Topf: "\uD835\uDD4B", TripleDot: "\u20DB", tdot: "\u20DB", Tscr: "\uD835\uDCAF", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\uD835\uDD18", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", lowbar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", bbrk: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", bigcup: "\u22C3", xcup: "\u22C3", UnionPlus: "\u228E", uplus: "\u228E", Uogon: "\u0172", Uopf: "\uD835\uDD4C", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", udarr: "\u21C5", UpDownArrow: "\u2195", updownarrow: "\u2195", varr: "\u2195", UpEquilibrium: "\u296E", udhar: "\u296E", UpTee: "\u22A5", bot: "\u22A5", bottom: "\u22A5", perp: "\u22A5", UpTeeArrow: "\u21A5", mapstoup: "\u21A5", UpperLeftArrow: "\u2196", nwarr: "\u2196", nwarrow: "\u2196", UpperRightArrow: "\u2197", nearr: "\u2197", nearrow: "\u2197", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\uD835\uDCB0", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", bigvee: "\u22C1", xvee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", mid: "\u2223", shortmid: "\u2223", smid: "\u2223", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", wr: "\u2240", wreath: "\u2240", VeryThinSpace: "\u200A", hairsp: "\u200A", Vfr: "\uD835\uDD19", Vopf: "\uD835\uDD4D", Vscr: "\uD835\uDCB1", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", bigwedge: "\u22C0", xwedge: "\u22C0", Wfr: "\uD835\uDD1A", Wopf: "\uD835\uDD4E", Wscr: "\uD835\uDCB2", Xfr: "\uD835\uDD1B", Xi: "\u039E", Xopf: "\uD835\uDD4F", Xscr: "\uD835\uDCB3", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\uD835\uDD1C", Yopf: "\uD835\uDD50", Yscr: "\uD835\uDCB4", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", Zeta: "\u0396", Zfr: "\u2128", zeetrf: "\u2128", Zopf: "\u2124", integers: "\u2124", Zscr: "\uD835\uDCB5", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", mstpos: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acy: "\u0430", aelig: "\xE6", afr: "\uD835\uDD1E", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", and: "\u2227", wedge: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", angle: "\u2220", ange: "\u29A4", angmsd: "\u2221", measuredangle: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angzarr: "\u237C", aogon: "\u0105", aopf: "\uD835\uDD52", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", approxeq: "\u224A", apid: "\u224B", apos: "'", aring: "\xE5", ascr: "\uD835\uDCB6", ast: "*", midast: "*", atilde: "\xE3", auml: "\xE4", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", bcong: "\u224C", backepsilon: "\u03F6", bepsi: "\u03F6", backprime: "\u2035", bprime: "\u2035", backsim: "\u223D", bsim: "\u223D", backsimeq: "\u22CD", bsime: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrktbrk: "\u23B6", bcy: "\u0431", bdquo: "\u201E", ldquor: "\u201E", bemptyv: "\u29B0", beta: "\u03B2", beth: "\u2136", between: "\u226C", twixt: "\u226C", bfr: "\uD835\uDD1F", bigcirc: "\u25EF", xcirc: "\u25EF", bigodot: "\u2A00", xodot: "\u2A00", bigoplus: "\u2A01", xoplus: "\u2A01", bigotimes: "\u2A02", xotime: "\u2A02", bigsqcup: "\u2A06", xsqcup: "\u2A06", bigstar: "\u2605", starf: "\u2605", bigtriangledown: "\u25BD", xdtri: "\u25BD", bigtriangleup: "\u25B3", xutri: "\u25B3", biguplus: "\u2A04", xuplus: "\u2A04", bkarow: "\u290D", rbarr: "\u290D", blacklozenge: "\u29EB", lozf: "\u29EB", blacktriangle: "\u25B4", utrif: "\u25B4", blacktriangledown: "\u25BE", dtrif: "\u25BE", blacktriangleleft: "\u25C2", ltrif: "\u25C2", blacktriangleright: "\u25B8", rtrif: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\uD835\uDD53", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", minusb: "\u229F", boxplus: "\u229E", plusb: "\u229E", boxtimes: "\u22A0", timesb: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", brvbar: "\xA6", bscr: "\uD835\uDCB7", bsemi: "\u204F", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bumpE: "\u2AAE", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cemptyv: "\u29B2", cent: "\xA2", cfr: "\uD835\uDD20", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", cire: "\u2257", circlearrowleft: "\u21BA", olarr: "\u21BA", circlearrowright: "\u21BB", orarr: "\u21BB", circledS: "\u24C8", oS: "\u24C8", circledast: "\u229B", oast: "\u229B", circledcirc: "\u229A", ocir: "\u229A", circleddash: "\u229D", odash: "\u229D", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", comma: ",", commat: "@", comp: "\u2201", complement: "\u2201", congdot: "\u2A6D", copf: "\uD835\uDD54", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\uD835\uDCB8", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", curlyeqprec: "\u22DE", cuesc: "\u22DF", curlyeqsucc: "\u22DF", cularr: "\u21B6", curvearrowleft: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curvearrowright: "\u21B7", curarrm: "\u293C", curlyvee: "\u22CE", cuvee: "\u22CE", curlywedge: "\u22CF", cuwed: "\u22CF", curren: "\xA4", cwint: "\u2231", cylcty: "\u232D", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", dash: "\u2010", hyphen: "\u2010", dbkarow: "\u290F", rBarr: "\u290F", dcaron: "\u010F", dcy: "\u0434", ddarr: "\u21CA", downdownarrows: "\u21CA", ddotseq: "\u2A77", eDDot: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", diamondsuit: "\u2666", diams: "\u2666", digamma: "\u03DD", gammad: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", llcorner: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", doteqdot: "\u2251", eDot: "\u2251", dotminus: "\u2238", minusd: "\u2238", dotplus: "\u2214", plusdo: "\u2214", dotsquare: "\u22A1", sdotb: "\u22A1", drcorn: "\u231F", lrcorner: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", triangledown: "\u25BF", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", eqcirc: "\u2256", ecirc: "\xEA", ecolon: "\u2255", eqcolon: "\u2255", ecy: "\u044D", edot: "\u0117", efDot: "\u2252", fallingdotseq: "\u2252", efr: "\uD835\uDD22", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", eqslantgtr: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", eqslantless: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", varnothing: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\uD835\uDD56", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", straightepsilon: "\u03F5", varepsilon: "\u03F5", equals: "=", equest: "\u225F", questeq: "\u225F", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", risingdotseq: "\u2253", erarr: "\u2971", escr: "\u212F", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", fork: "\u22D4", pitchfork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", half: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", sfrown: "\u2322", fscr: "\uD835\uDCBB", gEl: "\u2A8C", gtreqqless: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gap: "\u2A86", gtrapprox: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", gimel: "\u2137", gjcy: "\u0453", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gneqq: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gnsim: "\u22E7", gopf: "\uD835\uDD58", gscr: "\u210A", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtrdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrarr: "\u2978", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hardcy: "\u044A", harrcir: "\u2948", harrw: "\u21AD", leftrightsquigarrow: "\u21AD", hbar: "\u210F", hslash: "\u210F", planck: "\u210F", plankv: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", mldr: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", hksearow: "\u2925", searhk: "\u2925", hkswarow: "\u2926", swarhk: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", larrhk: "\u21A9", hookrightarrow: "\u21AA", rarrhk: "\u21AA", hopf: "\uD835\uDD59", horbar: "\u2015", hscr: "\uD835\uDCBD", hstrok: "\u0127", hybull: "\u2043", iacute: "\xED", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", ifr: "\uD835\uDD26", igrave: "\xEC", iiiint: "\u2A0C", qint: "\u2A0C", iiint: "\u222D", tint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", imath: "\u0131", inodot: "\u0131", imof: "\u22B7", imped: "\u01B5", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", intcal: "\u22BA", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\uD835\uDD5A", iota: "\u03B9", iquest: "\xBF", iscr: "\uD835\uDCBE", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\uD835\uDD27", jmath: "\u0237", jopf: "\uD835\uDD5B", jscr: "\uD835\uDCBF", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", varkappa: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\uD835\uDD28", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\uD835\uDD5C", kscr: "\uD835\uDCC0", lAtail: "\u291B", lBarr: "\u290E", lEg: "\u2A8B", lesseqqgtr: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lambda: "\u03BB", langd: "\u2991", lap: "\u2A85", lessapprox: "\u2A85", laquo: "\xAB", larrbfs: "\u291F", larrfs: "\u291D", larrlp: "\u21AB", looparrowleft: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", leftarrowtail: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lcy: "\u043B", ldca: "\u2936", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leq: "\u2264", leftleftarrows: "\u21C7", llarr: "\u21C7", leftthreetimes: "\u22CB", lthree: "\u22CB", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessdot: "\u22D6", ltdot: "\u22D6", lfisht: "\u297C", lfr: "\uD835\uDD29", lgE: "\u2A91", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lneqq: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", longmapsto: "\u27FC", xmap: "\u27FC", looparrowright: "\u21AC", rarrlp: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", loz: "\u25CA", lozenge: "\u25CA", lpar: "(", lparlt: "\u2993", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", lsime: "\u2A8D", lsimg: "\u2A8F", lsquor: "\u201A", sbquo: "\u201A", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", triangleleft: "\u25C3", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", strns: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", mfr: "\uD835\uDD2A", mho: "\u2127", micro: "\xB5", midcir: "\u2AF0", minus: "\u2212", minusdu: "\u2A2A", mlcp: "\u2ADB", models: "\u22A7", mopf: "\uD835\uDD5E", mscr: "\uD835\uDCC2", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nLeftarrow: "\u21CD", nlArr: "\u21CD", nLeftrightarrow: "\u21CE", nhArr: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nRightarrow: "\u21CF", nrArr: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nacute: "\u0144", nang: "\u2220\u20D2", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", natur: "\u266E", natural: "\u266E", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", neArr: "\u21D7", nearhk: "\u2924", nedot: "\u2250\u0338", nesear: "\u2928", toea: "\u2928", nfr: "\uD835\uDD2B", nharr: "\u21AE", nleftrightarrow: "\u21AE", nhpar: "\u2AF2", nis: "\u22FC", nisd: "\u22FA", njcy: "\u045A", nlE: "\u2266\u0338", nleqq: "\u2266\u0338", nlarr: "\u219A", nleftarrow: "\u219A", nldr: "\u2025", nopf: "\uD835\uDD5F", not: "\xAC", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinvb: "\u22F7", notinvc: "\u22F6", notnivb: "\u22FE", notnivc: "\u22FD", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", nrarr: "\u219B", nrightarrow: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nscr: "\uD835\uDCC3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsubseteqq: "\u2AC5\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupseteqq: "\u2AC6\u0338", ntilde: "\xF1", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwnear: "\u2927", oacute: "\xF3", ocirc: "\xF4", ocy: "\u043E", odblac: "\u0151", odiv: "\u2A38", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\uD835\uDD2C", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", olcir: "\u29BE", olcross: "\u29BB", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", oopf: "\uD835\uDD60", opar: "\u29B7", operp: "\u29B9", or: "\u2228", vee: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", oscr: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", para: "\xB6", parsim: "\u2AF3", parsl: "\u2AFD", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", pertenk: "\u2031", pfr: "\uD835\uDD2D", phi: "\u03C6", phiv: "\u03D5", straightphi: "\u03D5", varphi: "\u03D5", phone: "\u260E", pi: "\u03C0", piv: "\u03D6", varpi: "\u03D6", planckh: "\u210E", plus: "+", plusacir: "\u2A23", pluscir: "\u2A22", plusdu: "\u2A25", pluse: "\u2A72", plussim: "\u2A26", plustwo: "\u2A27", pointint: "\u2A15", popf: "\uD835\uDD61", pound: "\xA3", prE: "\u2AB3", prap: "\u2AB7", precapprox: "\u2AB7", precnapprox: "\u2AB9", prnap: "\u2AB9", precneqq: "\u2AB5", prnE: "\u2AB5", precnsim: "\u22E8", prnsim: "\u22E8", prime: "\u2032", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prurel: "\u22B0", pscr: "\uD835\uDCC5", psi: "\u03C8", puncsp: "\u2008", qfr: "\uD835\uDD2E", qopf: "\uD835\uDD62", qprime: "\u2057", qscr: "\uD835\uDCC6", quatint: "\u2A16", quest: "?", rAtail: "\u291C", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", raemptyv: "\u29B3", rangd: "\u2992", range: "\u29A5", raquo: "\xBB", rarrap: "\u2975", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rightarrowtail: "\u21A3", rarrw: "\u219D", rightsquigarrow: "\u219D", ratail: "\u291A", ratio: "\u2236", rbbrk: "\u2773", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdsh: "\u21B3", rect: "\u25AD", rfisht: "\u297D", rfr: "\uD835\uDD2F", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", varrho: "\u03F1", rightrightarrows: "\u21C9", rrarr: "\u21C9", rightthreetimes: "\u22CC", rthree: "\u22CC", ring: "\u02DA", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", ropar: "\u2986", ropf: "\uD835\uDD63", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rsaquo: "\u203A", rscr: "\uD835\uDCC7", rtimes: "\u22CA", rtri: "\u25B9", triangleright: "\u25B9", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", scE: "\u2AB4", scap: "\u2AB8", succapprox: "\u2AB8", scaron: "\u0161", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", succneqq: "\u2AB6", scnap: "\u2ABA", succnapprox: "\u2ABA", scnsim: "\u22E9", succnsim: "\u22E9", scpolint: "\u2A13", scy: "\u0441", sdot: "\u22C5", sdote: "\u2A66", seArr: "\u21D8", sect: "\xA7", semi: ";", seswar: "\u2929", tosa: "\u2929", sext: "\u2736", sfr: "\uD835\uDD30", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", varsigma: "\u03C2", simdot: "\u2A6A", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", smashp: "\u2A33", smeparsl: "\u29E4", smile: "\u2323", ssmile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", spades: "\u2660", spadesuit: "\u2660", sqcaps: "\u2293\uFE00", sqcups: "\u2294\uFE00", sscr: "\uD835\uDCC8", star: "\u2606", sub: "\u2282", subset: "\u2282", subE: "\u2AC5", subseteqq: "\u2AC5", subdot: "\u2ABD", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subsetneqq: "\u2ACB", subne: "\u228A", subsetneq: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supseteqq: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supsetneqq: "\u2ACC", supne: "\u228B", supsetneq: "\u228B", supplus: "\u2AC0", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", telrec: "\u2315", tfr: "\uD835\uDD31", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", vartheta: "\u03D1", thorn: "\xFE", times: "\xD7", timesbar: "\u2A31", timesd: "\u2A30", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", topfork: "\u2ADA", tprime: "\u2034", triangle: "\u25B5", utri: "\u25B5", triangleq: "\u225C", trie: "\u225C", tridot: "\u25EC", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", uHar: "\u2963", uacute: "\xFA", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udblac: "\u0171", ufisht: "\u297E", ufr: "\uD835\uDD32", ugrave: "\xF9", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uogon: "\u0173", uopf: "\uD835\uDD66", upsi: "\u03C5", upsilon: "\u03C5", upuparrows: "\u21C8", uuarr: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\uD835\uDCCA", utdot: "\u22F0", utilde: "\u0169", uuml: "\xFC", uwangle: "\u29A7", vBar: "\u2AE8", vBarv: "\u2AE9", vangrt: "\u299C", varsubsetneq: "\u228A\uFE00", vsubne: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", vsubnE: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", vsupne: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vsupnE: "\u2ACC\uFE00", vcy: "\u0432", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", vfr: "\uD835\uDD33", vopf: "\uD835\uDD67", vscr: "\uD835\uDCCB", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedgeq: "\u2259", weierp: "\u2118", wp: "\u2118", wfr: "\uD835\uDD34", wopf: "\uD835\uDD68", wscr: "\uD835\uDCCC", xfr: "\uD835\uDD35", xi: "\u03BE", xnis: "\u22FB", xopf: "\uD835\uDD69", xscr: "\uD835\uDCCD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\uD835\uDD36", yicy: "\u0457", yopf: "\uD835\uDD6A", yscr: "\uD835\uDCCE", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeta: "\u03B6", zfr: "\uD835\uDD37", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", zscr: "\uD835\uDCCF", zwj: "\u200D", zwnj: "\u200C" }, Fh = "\uE500";
Qr.ngsp = Fh;
var lr = class extends L {
    tokenType;
    constructor(e, t, s) { super(s, e), this.tokenType = t; }
}, gl = class {
    tokens;
    errors;
    nonNormalizedIcuExpressions;
    constructor(e, t, s) { this.tokens = e, this.errors = t, this.nonNormalizedIcuExpressions = s; }
};
function Tv(n, e, t, s = {}) { let r = new wl(new qr(n, e), t, s); return r.tokenize(), new gl(Mv(r.tokens), r.errors, r.nonNormalizedIcuExpressions); }
var bv = /\r\n?/g;
function Qs(n) { return `Unexpected character "${n === Se ? "EOF" : String.fromCharCode(n)}"`; }
function _c(n) { return `Unknown entity "${n}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`; }
function kv(n, e) { return `Unable to parse entity "${e}" - ${n} character reference entities must end with ";"`; }
var vl = function (n) { return n.HEX = "hexadecimal", n.DEC = "decimal", n; }(vl || {}), ur = class {
    error;
    constructor(e) { this.error = e; }
}, wl = class {
    _getTagDefinition;
    _cursor;
    _tokenizeIcu;
    _interpolationConfig;
    _leadingTriviaCodePoints;
    _currentTokenStart = null;
    _currentTokenType = null;
    _expansionCaseStack = [];
    _inInterpolation = !1;
    _preserveLineEndings;
    _i18nNormalizeLineEndingsInICUs;
    _tokenizeBlocks;
    _tokenizeLet;
    tokens = [];
    errors = [];
    nonNormalizedIcuExpressions = [];
    constructor(e, t, s) { this._getTagDefinition = t, this._tokenizeIcu = s.tokenizeExpansionForms || !1, this._interpolationConfig = s.interpolationConfig || et, this._leadingTriviaCodePoints = s.leadingTriviaChars && s.leadingTriviaChars.map(i => i.codePointAt(0) || 0); let r = s.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 }; this._cursor = s.escapedString ? new El(e, r) : new So(e, r), this._preserveLineEndings = s.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = s.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = s.tokenizeBlocks ?? !0, this._tokenizeLet = s.tokenizeLet ?? !0; try {
        this._cursor.init();
    }
    catch (i) {
        this.handleError(i);
    } }
    _processCarriageReturns(e) {
        return this._preserveLineEndings ? e : e.replace(bv, `
`);
    }
    tokenize() { for (; this._cursor.peek() !== Se;) {
        let e = this._cursor.clone();
        try {
            this._attemptCharCode(cs) ? this._attemptCharCode(tl) ? this._attemptCharCode(ms) ? this._consumeCdata(e) : this._attemptCharCode(eo) ? this._consumeComment(e) : this._consumeDocType(e) : this._attemptCharCode($t) ? this._consumeTagClose(e) : this._consumeTagOpen(e) : this._tokenizeLet && this._cursor.peek() === Jo && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._attemptCharCode(Jo) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(Pe) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
        }
        catch (t) {
            this.handleError(t);
        }
    } this._beginToken(33), this._endToken([]); }
    _getBlockName() { let e = !1, t = this._cursor.clone(); return this._attemptCharCodeUntilFn(s => Or(s) ? !e : Bv(s) ? (e = !0, !1) : !0), this._cursor.getChars(t).trim(); }
    _consumeBlockStart(e) { this._beginToken(24, e); let t = this._endToken([this._getBlockName()]); if (this._cursor.peek() === Ut)
        if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(pe), this._attemptCharCode(ft))
            this._attemptCharCodeUntilFn(pe);
        else {
            t.type = 28;
            return;
        } this._attemptCharCode(pt) ? (this._beginToken(25), this._endToken([])) : t.type = 28; }
    _consumeBlockEnd(e) { this._beginToken(26, e), this._endToken([]); }
    _consumeBlockParameters() { for (this._attemptCharCodeUntilFn(kc); this._cursor.peek() !== ft && this._cursor.peek() !== Se;) {
        this._beginToken(27);
        let e = this._cursor.clone(), t = null, s = 0;
        for (; this._cursor.peek() !== $e && this._cursor.peek() !== Se || t !== null;) {
            let r = this._cursor.peek();
            if (r === gs)
                this._cursor.advance();
            else if (r === t)
                t = null;
            else if (t === null && or(r))
                t = r;
            else if (r === Ut && t === null)
                s++;
            else if (r === ft && t === null) {
                if (s === 0)
                    break;
                s > 0 && s--;
            }
            this._cursor.advance();
        }
        this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(kc);
    } }
    _consumeLetDeclaration(e) { if (this._beginToken(29, e), Or(this._cursor.peek()))
        this._attemptCharCodeUntilFn(pe);
    else {
        let r = this._endToken([this._cursor.getChars(e)]);
        r.type = 32;
        return;
    } let t = this._endToken([this._getLetDeclarationName()]); if (this._attemptCharCodeUntilFn(pe), !this._attemptCharCode(In)) {
        t.type = 32;
        return;
    } this._attemptCharCodeUntilFn(r => pe(r) && !ku(r)), this._consumeLetDeclarationValue(), this._cursor.peek() === $e ? (this._beginToken(31), this._endToken([]), this._cursor.advance()) : (t.type = 32, t.sourceSpan = this._cursor.getSpan(e)); }
    _getLetDeclarationName() { let e = this._cursor.clone(), t = !1; return this._attemptCharCodeUntilFn(s => Vr(s) || s === Wo || s === ai || t && Ct(s) ? (t = !0, !1) : !0), this._cursor.getChars(e).trim(); }
    _consumeLetDeclarationValue() { let e = this._cursor.clone(); for (this._beginToken(30, e); this._cursor.peek() !== Se;) {
        let t = this._cursor.peek();
        if (t === $e)
            break;
        or(t) && (this._cursor.advance(), this._attemptCharCodeUntilFn(s => s === gs ? (this._cursor.advance(), !1) : s === t)), this._cursor.advance();
    } this._endToken([this._cursor.getChars(e)]); }
    _tokenizeExpansionForm() { if (this.isExpansionFormStart())
        return this._consumeExpansionFormStart(), !0; if (Pv(this._cursor.peek()) && this._isInExpansionForm())
        return this._consumeExpansionCaseStart(), !0; if (this._cursor.peek() === Pe) {
        if (this._isInExpansionCase())
            return this._consumeExpansionCaseEnd(), !0;
        if (this._isInExpansionForm())
            return this._consumeExpansionFormEnd(), !0;
    } return !1; }
    _beginToken(e, t = this._cursor.clone()) { this._currentTokenStart = t, this._currentTokenType = e; }
    _endToken(e, t) { if (this._currentTokenStart === null)
        throw new lr("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t)); if (this._currentTokenType === null)
        throw new lr("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart)); let s = { type: this._currentTokenType, parts: e, sourceSpan: (t ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) }; return this.tokens.push(s), this._currentTokenStart = null, this._currentTokenType = null, s; }
    _createError(e, t) { this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`); let s = new lr(e, this._currentTokenType, t); return this._currentTokenStart = null, this._currentTokenType = null, new ur(s); }
    handleError(e) { if (e instanceof Zr && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof ur)
        this.errors.push(e.error);
    else
        throw e; }
    _attemptCharCode(e) { return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1; }
    _attemptCharCodeCaseInsensitive(e) { return Lv(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1; }
    _requireCharCode(e) { let t = this._cursor.clone(); if (!this._attemptCharCode(e))
        throw this._createError(Qs(this._cursor.peek()), this._cursor.getSpan(t)); }
    _attemptStr(e) { let t = e.length; if (this._cursor.charsLeft() < t)
        return !1; let s = this._cursor.clone(); for (let r = 0; r < t; r++)
        if (!this._attemptCharCode(e.charCodeAt(r)))
            return this._cursor = s, !1; return !0; }
    _attemptStrCaseInsensitive(e) { for (let t = 0; t < e.length; t++)
        if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t)))
            return !1; return !0; }
    _requireStr(e) { let t = this._cursor.clone(); if (!this._attemptStr(e))
        throw this._createError(Qs(this._cursor.peek()), this._cursor.getSpan(t)); }
    _attemptCharCodeUntilFn(e) { for (; !e(this._cursor.peek());)
        this._cursor.advance(); }
    _requireCharCodeUntilFn(e, t) { let s = this._cursor.clone(); if (this._attemptCharCodeUntilFn(e), this._cursor.diff(s) < t)
        throw this._createError(Qs(this._cursor.peek()), this._cursor.getSpan(s)); }
    _attemptUntilChar(e) { for (; this._cursor.peek() !== e;)
        this._cursor.advance(); }
    _readChar() { let e = String.fromCodePoint(this._cursor.peek()); return this._cursor.advance(), e; }
    _consumeEntity(e) { this._beginToken(9); let t = this._cursor.clone(); if (this._cursor.advance(), this._attemptCharCode(oh)) {
        let s = this._attemptCharCode(dh) || this._attemptCharCode(sm), r = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(Nv), this._cursor.peek() != $e) {
            this._cursor.advance();
            let o = s ? vl.HEX : vl.DEC;
            throw this._createError(kv(o, this._cursor.getChars(t)), this._cursor.getSpan());
        }
        let i = this._cursor.getChars(r);
        this._cursor.advance();
        try {
            let o = parseInt(i, s ? 16 : 10);
            this._endToken([String.fromCharCode(o), this._cursor.getChars(t)]);
        }
        catch {
            throw this._createError(_c(this._cursor.getChars(t)), this._cursor.getSpan());
        }
    }
    else {
        let s = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(Dv), this._cursor.peek() != $e)
            this._beginToken(e, t), this._cursor = s, this._endToken(["&"]);
        else {
            let r = this._cursor.getChars(s);
            this._cursor.advance();
            let i = Qr.hasOwnProperty(r) && Qr[r];
            if (!i)
                throw this._createError(_c(r), this._cursor.getSpan(t));
            this._endToken([i, `&${r};`]);
        }
    } }
    _consumeRawText(e, t) { this._beginToken(e ? 6 : 7); let s = []; for (;;) {
        let r = this._cursor.clone(), i = t();
        if (this._cursor = r, i)
            break;
        e && this._cursor.peek() === Ki ? (this._endToken([this._processCarriageReturns(s.join(""))]), s.length = 0, this._consumeEntity(6), this._beginToken(6)) : s.push(this._readChar());
    } this._endToken([this._processCarriageReturns(s.join(""))]); }
    _consumeComment(e) { this._beginToken(10, e), this._requireCharCode(eo), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]); }
    _consumeCdata(e) { this._beginToken(12, e), this._requireStr("CDATA["), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]); }
    _consumeDocType(e) { this._beginToken(18, e); let t = this._cursor.clone(); this._attemptUntilChar(tn); let s = this._cursor.getChars(t); this._cursor.advance(), this._endToken([s]); }
    _consumePrefixAndName() { let e = this._cursor.clone(), t = ""; for (; this._cursor.peek() !== rn && !Iv(this._cursor.peek());)
        this._cursor.advance(); let s; this._cursor.peek() === rn ? (t = this._cursor.getChars(e), this._cursor.advance(), s = this._cursor.clone()) : s = e, this._requireCharCodeUntilFn(Tc, t === "" ? 0 : 1); let r = this._cursor.getChars(s); return [t, r]; }
    _consumeTagOpen(e) { let t, s, r; try {
        if (!Vr(this._cursor.peek()))
            throw this._createError(Qs(this._cursor.peek()), this._cursor.getSpan(e));
        for (r = this._consumeTagOpenStart(e), s = r.parts[0], t = r.parts[1], this._attemptCharCodeUntilFn(pe); this._cursor.peek() !== $t && this._cursor.peek() !== tn && this._cursor.peek() !== cs && this._cursor.peek() !== Se;)
            this._consumeAttributeName(), this._attemptCharCodeUntilFn(pe), this._attemptCharCode(In) && (this._attemptCharCodeUntilFn(pe), this._consumeAttributeValue()), this._attemptCharCodeUntilFn(pe);
        this._consumeTagOpenEnd();
    }
    catch (o) {
        if (o instanceof ur) {
            r ? r.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
            return;
        }
        throw o;
    } let i = this._getTagDefinition(t).getContentType(s); i === _t.RAW_TEXT ? this._consumeRawTextWithTagClose(s, t, !1) : i === _t.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(s, t, !0); }
    _consumeRawTextWithTagClose(e, t, s) { this._consumeRawText(s, () => !this._attemptCharCode(cs) || !this._attemptCharCode($t) || (this._attemptCharCodeUntilFn(pe), !this._attemptStrCaseInsensitive(t)) ? !1 : (this._attemptCharCodeUntilFn(pe), this._attemptCharCode(tn))), this._beginToken(3), this._requireCharCodeUntilFn(r => r === tn, 3), this._cursor.advance(), this._endToken([e, t]); }
    _consumeTagOpenStart(e) { this._beginToken(0, e); let t = this._consumePrefixAndName(); return this._endToken(t); }
    _consumeAttributeName() { let e = this._cursor.peek(); if (e === $r || e === Fr)
        throw this._createError(Qs(e), this._cursor.getSpan()); this._beginToken(14); let t = this._consumePrefixAndName(); this._endToken(t); }
    _consumeAttributeValue() { if (this._cursor.peek() === $r || this._cursor.peek() === Fr) {
        let e = this._cursor.peek();
        this._consumeQuote(e);
        let t = () => this._cursor.peek() === e;
        this._consumeWithInterpolation(16, 17, t, t), this._consumeQuote(e);
    }
    else {
        let e = () => Tc(this._cursor.peek());
        this._consumeWithInterpolation(16, 17, e, e);
    } }
    _consumeQuote(e) { this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]); }
    _consumeTagOpenEnd() { let e = this._attemptCharCode($t) ? 2 : 1; this._beginToken(e), this._requireCharCode(tn), this._endToken([]); }
    _consumeTagClose(e) { this._beginToken(3, e), this._attemptCharCodeUntilFn(pe); let t = this._consumePrefixAndName(); this._attemptCharCodeUntilFn(pe), this._requireCharCode(tn), this._endToken(t); }
    _consumeExpansionFormStart() { this._beginToken(19), this._requireCharCode(pt), this._endToken([]), this._expansionCaseStack.push(19), this._beginToken(7); let e = this._readUntil(st), t = this._processCarriageReturns(e); if (this._i18nNormalizeLineEndingsInICUs)
        this._endToken([t]);
    else {
        let r = this._endToken([e]);
        t !== e && this.nonNormalizedIcuExpressions.push(r);
    } this._requireCharCode(st), this._attemptCharCodeUntilFn(pe), this._beginToken(7); let s = this._readUntil(st); this._endToken([s]), this._requireCharCode(st), this._attemptCharCodeUntilFn(pe); }
    _consumeExpansionCaseStart() { this._beginToken(20); let e = this._readUntil(pt).trim(); this._endToken([e]), this._attemptCharCodeUntilFn(pe), this._beginToken(21), this._requireCharCode(pt), this._endToken([]), this._attemptCharCodeUntilFn(pe), this._expansionCaseStack.push(21); }
    _consumeExpansionCaseEnd() { this._beginToken(22), this._requireCharCode(Pe), this._endToken([]), this._attemptCharCodeUntilFn(pe), this._expansionCaseStack.pop(); }
    _consumeExpansionFormEnd() { this._beginToken(23), this._requireCharCode(Pe), this._endToken([]), this._expansionCaseStack.pop(); }
    _consumeWithInterpolation(e, t, s, r) { this._beginToken(e); let i = []; for (; !s();) {
        let o = this._cursor.clone();
        this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o), i.length = 0, this._consumeInterpolation(t, o, r), this._beginToken(e)) : this._cursor.peek() === Ki ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e), this._beginToken(e)) : i.push(this._readChar());
    } this._inInterpolation = !1, this._endToken([this._processCarriageReturns(i.join(""))]); }
    _consumeInterpolation(e, t, s) { let r = []; this._beginToken(e, t), r.push(this._interpolationConfig.start); let i = this._cursor.clone(), o = null, a = !1; for (; this._cursor.peek() !== Se && (s === null || !s());) {
        let l = this._cursor.clone();
        if (this._isTagStart()) {
            this._cursor = l, r.push(this._getProcessedChars(i, l)), this._endToken(r);
            return;
        }
        if (o === null)
            if (this._attemptStr(this._interpolationConfig.end)) {
                r.push(this._getProcessedChars(i, l)), r.push(this._interpolationConfig.end), this._endToken(r);
                return;
            }
            else
                this._attemptStr("//") && (a = !0);
        let u = this._cursor.peek();
        this._cursor.advance(), u === gs ? this._cursor.advance() : u === o ? o = null : !a && o === null && or(u) && (o = u);
    } r.push(this._getProcessedChars(i, this._cursor)), this._endToken(r); }
    _getProcessedChars(e, t) { return this._processCarriageReturns(t.getChars(e)); }
    _isTextEnd() { return !!(this._isTagStart() || this._cursor.peek() === Se || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === Pe && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._cursor.peek() === Jo || this._cursor.peek() === Pe)); }
    _isTagStart() { if (this._cursor.peek() === cs) {
        let e = this._cursor.clone();
        e.advance();
        let t = e.peek();
        if (Yn <= t && t <= li || qs <= t && t <= jo || t === $t || t === tl)
            return !0;
    } return !1; }
    _readUntil(e) { let t = this._cursor.clone(); return this._attemptUntilChar(e), this._cursor.getChars(t); }
    _isInExpansion() { return this._isInExpansionCase() || this._isInExpansionForm(); }
    _isInExpansionCase() { return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21; }
    _isInExpansionForm() { return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19; }
    isExpansionFormStart() { if (this._cursor.peek() !== pt)
        return !1; if (this._interpolationConfig) {
        let e = this._cursor.clone(), t = this._attemptStr(this._interpolationConfig.start);
        return this._cursor = e, !t;
    } return !0; }
};
function pe(n) { return !Or(n) || n === Se; }
function Tc(n) { return Or(n) || n === tn || n === cs || n === $t || n === $r || n === Fr || n === In || n === Se; }
function Iv(n) { return (n < Yn || li < n) && (n < qs || jo < n) && (n < Tu || n > lh); }
function Nv(n) { return n === $e || n === Se || !am(n); }
function Dv(n) { return n === $e || n === Se || !Vr(n); }
function Pv(n) { return n !== Pe; }
function Lv(n, e) { return bc(n) === bc(e); }
function bc(n) { return n >= Yn && n <= li ? n - Yn + qs : n; }
function Bv(n) { return Vr(n) || Ct(n) || n === ai; }
function kc(n) { return n !== $e && pe(n); }
function Mv(n) { let e = [], t; for (let s = 0; s < n.length; s++) {
    let r = n[s];
    t && t.type === 5 && r.type === 5 || t && t.type === 16 && r.type === 16 ? (t.parts[0] += r.parts[0], t.sourceSpan.end = r.sourceSpan.end) : (t = r, e.push(t));
} return e; }
var So = class n {
    state;
    file;
    input;
    end;
    constructor(e, t) { if (e instanceof n) {
        this.file = e.file, this.input = e.input, this.end = e.end;
        let s = e.state;
        this.state = { peek: s.peek, offset: s.offset, line: s.line, column: s.column };
    }
    else {
        if (!t)
            throw new Error("Programming error: the range argument must be provided with a file argument.");
        this.file = e, this.input = e.content, this.end = t.endPos, this.state = { peek: -1, offset: t.startPos, line: t.startLine, column: t.startCol };
    } }
    clone() { return new n(this); }
    peek() { return this.state.peek; }
    charsLeft() { return this.end - this.state.offset; }
    diff(e) { return this.state.offset - e.state.offset; }
    advance() { this.advanceState(this.state); }
    init() { this.updatePeek(this.state); }
    getSpan(e, t) { e = e || this; let s = e; if (t)
        for (; this.diff(e) > 0 && t.indexOf(e.peek()) !== -1;)
            s === e && (e = e.clone()), e.advance(); let r = this.locationFromCursor(e), i = this.locationFromCursor(this), o = s !== e ? this.locationFromCursor(s) : r; return new R(r, i, o); }
    getChars(e) { return this.input.substring(e.state.offset, this.state.offset); }
    charAt(e) { return this.input.charCodeAt(e); }
    advanceState(e) { if (e.offset >= this.end)
        throw this.state = e, new Zr("Unexpected character \"EOF\"", this); let t = this.charAt(e.offset); t === Bn ? (e.line++, e.column = 0) : ku(t) || e.column++, e.offset++, this.updatePeek(e); }
    updatePeek(e) { e.peek = e.offset >= this.end ? Se : this.charAt(e.offset); }
    locationFromCursor(e) { return new Qn(e.file, e.state.offset, e.state.line, e.state.column); }
}, El = class n extends So {
    internalState;
    constructor(e, t) { e instanceof n ? (super(e), this.internalState = E({}, e.internalState)) : (super(e, t), this.internalState = this.state); }
    advance() { this.state = this.internalState, super.advance(), this.processEscapeSequence(); }
    init() { super.init(), this.processEscapeSequence(); }
    clone() { return new n(this); }
    getChars(e) { let t = e.clone(), s = ""; for (; t.internalState.offset < this.internalState.offset;)
        s += String.fromCodePoint(t.peek()), t.advance(); return s; }
    processEscapeSequence() { let e = () => this.internalState.peek; if (e() === gs)
        if (this.internalState = E({}, this.state), this.advanceState(this.internalState), e() === uh)
            this.state.peek = Bn;
        else if (e() === ch)
            this.state.peek = _u;
        else if (e() === fh)
            this.state.peek = sh;
        else if (e() === ph)
            this.state.peek = Au;
        else if (e() === im)
            this.state.peek = Zd;
        else if (e() === bu)
            this.state.peek = rh;
        else if (e() === hh) {
            if (this.advanceState(this.internalState), e() === pt) {
                this.advanceState(this.internalState);
                let t = this.clone(), s = 0;
                for (; e() !== Pe;)
                    this.advanceState(this.internalState), s++;
                this.state.peek = this.decodeHexDigits(t, s);
            }
            else {
                let t = this.clone();
                this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(t, 4);
            }
        }
        else if (e() === dh) {
            this.advanceState(this.internalState);
            let t = this.clone();
            this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(t, 2);
        }
        else if (ac(e())) {
            let t = "", s = 0, r = this.clone();
            for (; ac(e()) && s < 3;)
                r = this.clone(), t += String.fromCodePoint(e()), this.advanceState(this.internalState), s++;
            this.state.peek = parseInt(t, 8), this.internalState = r.internalState;
        }
        else
            ku(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek; }
    decodeHexDigits(e, t) { let s = this.input.slice(e.internalState.offset, e.internalState.offset + t), r = parseInt(s, 16); if (isNaN(r))
        throw e.state = e.internalState, new Zr("Invalid hexadecimal escape sequence", e); return r; }
}, Zr = class {
    msg;
    cursor;
    constructor(e, t) { this.msg = e, this.cursor = t; }
}, Ee = class n extends L {
    elementName;
    static create(e, t, s) { return new n(e, t, s); }
    constructor(e, t, s) { super(t, s), this.elementName = e; }
}, Fs = class {
    rootNodes;
    errors;
    constructor(e, t) { this.rootNodes = e, this.errors = t; }
}, $h = class {
    getTagDefinition;
    constructor(e) { this.getTagDefinition = e; }
    parse(e, t, s) { let r = Tv(e, t, this.getTagDefinition, s), i = new Sl(r.tokens, this.getTagDefinition); return i.build(), new Fs(i.rootNodes, r.errors.concat(i.errors)); }
}, Sl = class n {
    tokens;
    getTagDefinition;
    _index = -1;
    _peek;
    _containerStack = [];
    rootNodes = [];
    errors = [];
    constructor(e, t) { this.tokens = e, this.getTagDefinition = t, this._advance(); }
    build() { for (; this._peek.type !== 33;)
        this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? this._consumeEndTag(this._advance()) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 19 ? this._consumeExpansion(this._advance()) : this._peek.type === 24 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 26 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 28 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 32 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance(); for (let e of this._containerStack)
        e instanceof Je && this.errors.push(Ee.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`)); }
    _advance() { let e = this._peek; return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e; }
    _advanceIf(e) { return this._peek.type === e ? this._advance() : null; }
    _consumeCdata(e) { this._consumeText(this._advance()), this._advanceIf(13); }
    _consumeComment(e) { let t = this._advanceIf(7), s = this._advanceIf(11), r = t != null ? t.parts[0].trim() : null, i = s == null ? e.sourceSpan : new R(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart); this._addToParent(new Sn(r, i)); }
    _consumeExpansion(e) { let t = this._advance(), s = this._advance(), r = []; for (; this._peek.type === 20;) {
        let o = this._parseExpansionCase();
        if (!o)
            return;
        r.push(o);
    } if (this._peek.type !== 23) {
        this.errors.push(Ee.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
        return;
    } let i = new R(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart); this._addToParent(new un(t.parts[0], s.parts[0], r, i, t.sourceSpan)), this._advance(); }
    _parseExpansionCase() { let e = this._advance(); if (this._peek.type !== 21)
        return this.errors.push(Ee.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null; let t = this._advance(), s = this._collectExpansionExpTokens(t); if (!s)
        return null; let r = this._advance(); s.push({ type: 33, parts: [], sourceSpan: r.sourceSpan }); let i = new n(s, this.getTagDefinition); if (i.build(), i.errors.length > 0)
        return this.errors = this.errors.concat(i.errors), null; let o = new R(e.sourceSpan.start, r.sourceSpan.end, e.sourceSpan.fullStart), a = new R(t.sourceSpan.start, r.sourceSpan.end, t.sourceSpan.fullStart); return new Yr(e.parts[0], i.rootNodes, o, e.sourceSpan, a); }
    _collectExpansionExpTokens(e) { let t = [], s = [21]; for (;;) {
        if ((this._peek.type === 19 || this._peek.type === 21) && s.push(this._peek.type), this._peek.type === 22)
            if (Ic(s, 21)) {
                if (s.pop(), s.length === 0)
                    return t;
            }
            else
                return this.errors.push(Ee.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (this._peek.type === 23)
            if (Ic(s, 19))
                s.pop();
            else
                return this.errors.push(Ee.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (this._peek.type === 33)
            return this.errors.push(Ee.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        t.push(this._advance());
    } }
    _consumeText(e) {
        let t = [e], s = e.sourceSpan, r = e.parts[0];
        if (r.length > 0 && r[0] === `
`) {
            let i = this._getContainer();
            i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (r = r.substring(1), t[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [r] });
        }
        for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9;)
            e = this._advance(), t.push(e), e.type === 8 ? r += e.parts.join("").replace(/&([^;]+);/g, Nc) : e.type === 9 ? r += e.parts[0] : r += e.parts.join("");
        if (r.length > 0) {
            let i = e.sourceSpan;
            this._addToParent(new Yt(r, new R(s.start, i.end, s.fullStart, s.details), t));
        }
    }
    _closeVoidElement() { let e = this._getContainer(); e instanceof De && this.getTagDefinition(e.name).isVoid && this._containerStack.pop(); }
    _consumeStartTag(e) { let [t, s] = e.parts, r = []; for (; this._peek.type === 14;)
        r.push(this._consumeAttr(this._advance())); let i = this._getElementFullName(t, s, this._getClosestParentElement()), o = !1; if (this._peek.type === 2) {
        this._advance(), o = !0;
        let g = this.getTagDefinition(i);
        g.canSelfClose || $a(i) !== null || g.isVoid || this.errors.push(Ee.create(i, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    }
    else
        this._peek.type === 1 && (this._advance(), o = !1); let a = this._peek.sourceSpan.fullStart, l = new R(e.sourceSpan.start, a, e.sourceSpan.fullStart), u = new R(e.sourceSpan.start, a, e.sourceSpan.fullStart), p = new De(i, r, [], l, u, void 0), f = this._getContainer(); this._pushContainer(p, f instanceof De && this.getTagDefinition(f.name).isClosedByChild(p.name)), o ? this._popContainer(i, De, l) : e.type === 4 && (this._popContainer(i, De, null), this.errors.push(Ee.create(i, l, `Opening tag "${i}" not terminated.`))); }
    _pushContainer(e, t) { t && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e); }
    _consumeEndTag(e) { let t = this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement()); if (this.getTagDefinition(t).isVoid)
        this.errors.push(Ee.create(t, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(t, De, e.sourceSpan)) {
        let s = `Unexpected closing tag "${t}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
        this.errors.push(Ee.create(t, e.sourceSpan, s));
    } }
    _popContainer(e, t, s) { let r = !1; for (let i = this._containerStack.length - 1; i >= 0; i--) {
        let o = this._containerStack[i];
        if ((o.name === e || e === null) && o instanceof t)
            return o.endSourceSpan = s, o.sourceSpan.end = s !== null ? s.end : o.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !r;
        (o instanceof Je || o instanceof De && !this.getTagDefinition(o.name).closedByParent) && (r = !0);
    } return !1; }
    _consumeAttr(e) { let t = Oa(e.parts[0], e.parts[1]), s = e.sourceSpan.end; this._peek.type === 15 && this._advance(); let r = "", i = [], o, a; if (this._peek.type === 16)
        for (o = this._peek.sourceSpan, a = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9;) {
            let p = this._advance();
            i.push(p), p.type === 17 ? r += p.parts.join("").replace(/&([^;]+);/g, Nc) : p.type === 9 ? r += p.parts[0] : r += p.parts.join(""), a = s = p.sourceSpan.end;
        } this._peek.type === 15 && (s = this._advance().sourceSpan.end); let u = o && a && new R(o.start, a, o.fullStart); return new Rs(t, r, new R(e.sourceSpan.start, s, e.sourceSpan.fullStart), e.sourceSpan, u, i.length > 0 ? i : void 0, void 0); }
    _consumeBlockOpen(e) { let t = []; for (; this._peek.type === 27;) {
        let a = this._advance();
        t.push(new wo(a.parts[0], a.sourceSpan));
    } this._peek.type === 25 && this._advance(); let s = this._peek.sourceSpan.fullStart, r = new R(e.sourceSpan.start, s, e.sourceSpan.fullStart), i = new R(e.sourceSpan.start, s, e.sourceSpan.fullStart), o = new Je(e.parts[0], t, [], r, e.sourceSpan, i); this._pushContainer(o, !1); }
    _consumeBlockClose(e) { this._popContainer(null, Je, e.sourceSpan) || this.errors.push(Ee.create(null, e.sourceSpan, "Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the \"&#125;\" HTML entity instead.")); }
    _consumeIncompleteBlock(e) { let t = []; for (; this._peek.type === 27;) {
        let a = this._advance();
        t.push(new wo(a.parts[0], a.sourceSpan));
    } let s = this._peek.sourceSpan.fullStart, r = new R(e.sourceSpan.start, s, e.sourceSpan.fullStart), i = new R(e.sourceSpan.start, s, e.sourceSpan.fullStart), o = new Je(e.parts[0], t, [], r, e.sourceSpan, i); this._pushContainer(o, !1), this._popContainer(null, Je, null), this.errors.push(Ee.create(e.parts[0], r, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`)); }
    _consumeLet(e) { let t = e.parts[0], s, r; if (this._peek.type !== 30) {
        this.errors.push(Ee.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${t}". Declaration must have a value.`));
        return;
    }
    else
        s = this._advance(); if (this._peek.type !== 31) {
        this.errors.push(Ee.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${t}". Declaration must be terminated with a semicolon.`));
        return;
    }
    else
        r = this._advance(); let i = r.sourceSpan.fullStart, o = new R(e.sourceSpan.start, i, e.sourceSpan.fullStart), a = e.sourceSpan.toString().lastIndexOf(t), l = e.sourceSpan.start.moveBy(a), u = new R(l, e.sourceSpan.end), p = new Eo(t, s.parts[0], o, u, s.sourceSpan); this._addToParent(p); }
    _consumeIncompleteLet(e) { let t = e.parts[0] ?? "", s = t ? ` "${t}"` : ""; if (t.length > 0) {
        let r = e.sourceSpan.toString().lastIndexOf(t), i = e.sourceSpan.start.moveBy(r), o = new R(i, e.sourceSpan.end), a = new R(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)), l = new Eo(t, "", e.sourceSpan, o, a);
        this._addToParent(l);
    } this.errors.push(Ee.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${s}. @let declarations must be written as \`@let <name> = <value>;\``)); }
    _getContainer() { return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null; }
    _getClosestParentElement() { for (let e = this._containerStack.length - 1; e > -1; e--)
        if (this._containerStack[e] instanceof De)
            return this._containerStack[e]; return null; }
    _addToParent(e) { let t = this._getContainer(); t === null ? this.rootNodes.push(e) : t.children.push(e); }
    _getElementFullName(e, t, s) { if (e === "" && (e = this.getTagDefinition(t).implicitNamespacePrefix || "", e === "" && s != null)) {
        let r = vt(s.name)[1];
        this.getTagDefinition(r).preventNamespaceInheritance || (e = $a(s.name));
    } return Oa(e, t); }
};
function Ic(n, e) { return n.length > 0 && n[n.length - 1] === e; }
function Nc(n, e) { return Qr[e] !== void 0 ? Qr[e] || n : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : n; }
var Oh = "ngPreserveWhitespaces", Rv = new Set(["pre", "template", "textarea", "script", "style"]), Vh = ` \f
\r	\v\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`, Fv = new RegExp(`[^${Vh}]`), $v = new RegExp(`[${Vh}]{2,}`, "g");
function Ov(n) { return n.some(e => e.name === Oh); }
function qh(n) { return n.replace(new RegExp(Fh, "g"), " "); }
var Jr = class {
    preserveSignificantWhitespace;
    originalNodeMap;
    requireContext;
    icuExpansionDepth = 0;
    constructor(e, t, s = !0) { this.preserveSignificantWhitespace = e, this.originalNodeMap = t, this.requireContext = s; }
    visitElement(e, t) { if (Rv.has(e.name) || Ov(e.attrs)) {
        let r = new De(e.name, _n(this, e.attrs), e.children, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n);
        return this.originalNodeMap?.set(r, e), r;
    } let s = new De(e.name, e.attrs, _n(this, e.children), e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n); return this.originalNodeMap?.set(s, e), s; }
    visitAttribute(e, t) { return e.name !== Oh ? e : null; }
    visitText(e, t) { let s = e.value.match(Fv), r = t && (t.prev instanceof un || t.next instanceof un); if (this.icuExpansionDepth > 0 && this.preserveSignificantWhitespace)
        return e; if (s || r) {
        let o = e.tokens.map(p => p.type === 5 ? Uv(p) : p);
        if (!this.preserveSignificantWhitespace && o.length > 0) {
            let p = o[0];
            o.splice(0, 1, Vv(p, t));
            let f = o[o.length - 1];
            o.splice(o.length - 1, 1, qv(f, t));
        }
        let a = Uh(e.value), l = this.preserveSignificantWhitespace ? a : Hv(a, t), u = new Yt(l, e.sourceSpan, o, e.i18n);
        return this.originalNodeMap?.set(u, e), u;
    } return null; }
    visitComment(e, t) { return e; }
    visitExpansion(e, t) { this.icuExpansionDepth++; let s; try {
        s = new un(e.switchValue, e.type, _n(this, e.cases), e.sourceSpan, e.switchValueSourceSpan, e.i18n);
    }
    finally {
        this.icuExpansionDepth--;
    } return this.originalNodeMap?.set(s, e), s; }
    visitExpansionCase(e, t) { let s = new Yr(e.value, _n(this, e.expression), e.sourceSpan, e.valueSourceSpan, e.expSourceSpan); return this.originalNodeMap?.set(s, e), s; }
    visitBlock(e, t) { let s = new Je(e.name, e.parameters, _n(this, e.children), e.sourceSpan, e.nameSpan, e.startSourceSpan, e.endSourceSpan); return this.originalNodeMap?.set(s, e), s; }
    visitBlockParameter(e, t) { return e; }
    visitLetDeclaration(e, t) { return e; }
    visit(e, t) { if (this.requireContext && !t)
        throw new Error("WhitespaceVisitor requires context. Visit via `visitAllWithSiblings` to get this context."); return !1; }
};
function Vv(n, e) { return n.type !== 5 || !!e?.prev ? n : Hh(n, s => s.trimStart()); }
function qv(n, e) { return n.type !== 5 || !!e?.next ? n : Hh(n, s => s.trimEnd()); }
function Hv(n, e) { let t = !e?.prev, s = !e?.next, r = t ? n.trimStart() : n; return s ? r.trimEnd() : r; }
function Uv({ type: n, parts: e, sourceSpan: t }) { return { type: n, parts: [Uh(e[0])], sourceSpan: t }; }
function Hh({ type: n, parts: e, sourceSpan: t }, s) { return { type: n, parts: [s(e[0])], sourceSpan: t }; }
function Uh(n) { return qh(n).replace($v, " "); }
function _n(n, e) { let t = []; return e.forEach((s, r) => { let i = { prev: e[r - 1], next: e[r + 1] }, o = s.visit(n, i); o && t.push(o); }), t; }
var q = function (n) { return n[n.Character = 0] = "Character", n[n.Identifier = 1] = "Identifier", n[n.PrivateIdentifier = 2] = "PrivateIdentifier", n[n.Keyword = 3] = "Keyword", n[n.String = 4] = "String", n[n.Operator = 5] = "Operator", n[n.Number = 6] = "Number", n[n.Error = 7] = "Error", n; }(q || {}), Rn = function (n) { return n[n.Plain = 0] = "Plain", n[n.TemplateLiteralPart = 1] = "TemplateLiteralPart", n[n.TemplateLiteralEnd = 2] = "TemplateLiteralEnd", n; }(Rn || {}), Wv = ["var", "let", "as", "null", "undefined", "true", "false", "if", "else", "this", "typeof"], Kr = class {
    tokenize(e) { return new xl(e).scan(); }
}, St = class {
    index;
    end;
    type;
    numValue;
    strValue;
    constructor(e, t, s, r, i) { this.index = e, this.end = t, this.type = s, this.numValue = r, this.strValue = i; }
    isCharacter(e) { return this.type === q.Character && this.numValue === e; }
    isNumber() { return this.type === q.Number; }
    isString() { return this.type === q.String; }
    isOperator(e) { return this.type === q.Operator && this.strValue === e; }
    isIdentifier() { return this.type === q.Identifier; }
    isPrivateIdentifier() { return this.type === q.PrivateIdentifier; }
    isKeyword() { return this.type === q.Keyword; }
    isKeywordLet() { return this.type === q.Keyword && this.strValue === "let"; }
    isKeywordAs() { return this.type === q.Keyword && this.strValue === "as"; }
    isKeywordNull() { return this.type === q.Keyword && this.strValue === "null"; }
    isKeywordUndefined() { return this.type === q.Keyword && this.strValue === "undefined"; }
    isKeywordTrue() { return this.type === q.Keyword && this.strValue === "true"; }
    isKeywordFalse() { return this.type === q.Keyword && this.strValue === "false"; }
    isKeywordThis() { return this.type === q.Keyword && this.strValue === "this"; }
    isKeywordTypeof() { return this.type === q.Keyword && this.strValue === "typeof"; }
    isError() { return this.type === q.Error; }
    toNumber() { return this.type === q.Number ? this.numValue : -1; }
    isTemplateLiteralPart() { return this.isString() && this.kind === Rn.TemplateLiteralPart; }
    isTemplateLiteralEnd() { return this.isString() && this.kind === Rn.TemplateLiteralEnd; }
    isTemplateLiteralInterpolationStart() { return this.isOperator("${"); }
    isTemplateLiteralInterpolationEnd() { return this.isOperator("}"); }
    toString() { switch (this.type) {
        case q.Character:
        case q.Identifier:
        case q.Keyword:
        case q.Operator:
        case q.PrivateIdentifier:
        case q.String:
        case q.Error: return this.strValue;
        case q.Number: return this.numValue.toString();
        default: return null;
    } }
}, cr = class extends St {
    kind;
    constructor(e, t, s, r) { super(e, t, q.String, 0, s), this.kind = r; }
};
function hi(n, e, t) { return new St(n, e, q.Character, t, String.fromCharCode(t)); }
function jv(n, e, t) { return new St(n, e, q.Identifier, 0, t); }
function zv(n, e, t) { return new St(n, e, q.PrivateIdentifier, 0, t); }
function Gv(n, e, t) { return new St(n, e, q.Keyword, 0, t); }
function Zs(n, e, t) { return new St(n, e, q.Operator, 0, t); }
function Xv(n, e, t) { return new St(n, e, q.Number, t, ""); }
function Yv(n, e, t) { return new St(n, e, q.Error, 0, t); }
var fi = new St(-1, -1, q.Character, 0, ""), xl = class {
    input;
    tokens = [];
    length;
    peek = 0;
    index = -1;
    braceStack = [];
    constructor(e) { this.input = e, this.length = e.length, this.advance(); }
    scan() { let e = this.scanToken(); for (; e !== null;)
        this.tokens.push(e), e = this.scanToken(); return this.tokens; }
    advance() { this.peek = ++this.index >= this.length ? Se : this.input.charCodeAt(this.index); }
    scanToken() { let e = this.input, t = this.length, s = this.peek, r = this.index; for (; s <= ih;)
        if (++r >= t) {
            s = Se;
            break;
        }
        else
            s = e.charCodeAt(r); if (this.peek = s, this.index = r, r >= t)
        return null; if (Dc(s))
        return this.scanIdentifier(); if (Ct(s))
        return this.scanNumber(r); let i = r; switch (s) {
        case os: return this.advance(), Ct(this.peek) ? this.scanNumber(i) : hi(i, this.index, os);
        case Ut:
        case ft:
        case ms:
        case ps:
        case st:
        case rn:
        case $e: return this.scanCharacter(i, s);
        case pt: return this.scanOpenBrace(i, s);
        case Pe: return this.scanCloseBrace(i, s);
        case $r:
        case Fr: return this.scanString();
        case nl: return this.advance(), this.scanTemplateLiteralPart(i);
        case oh: return this.scanPrivateIdentifier();
        case ah:
        case eo:
        case Kd:
        case $t:
        case Jd:
        case rm: return this.scanOperator(i, String.fromCharCode(s));
        case ic: return this.scanQuestion(i);
        case cs:
        case tn: return this.scanComplexOperator(i, String.fromCharCode(s), In, "=");
        case tl:
        case In: return this.scanComplexOperator(i, String.fromCharCode(s), In, "=", In, "=");
        case Ki: return this.scanComplexOperator(i, "&", Ki, "&");
        case oc: return this.scanComplexOperator(i, "|", oc, "|");
        case mh:
            for (; Or(this.peek);)
                this.advance();
            return this.scanToken();
    } return this.advance(), this.error(`Unexpected character [${String.fromCharCode(s)}]`, 0); }
    scanCharacter(e, t) { return this.advance(), hi(e, this.index, t); }
    scanOperator(e, t) { return this.advance(), Zs(e, this.index, t); }
    scanOpenBrace(e, t) { return this.braceStack.push("expression"), this.advance(), hi(e, this.index, t); }
    scanCloseBrace(e, t) { return this.advance(), this.braceStack.pop() === "interpolation" ? (this.tokens.push(Zs(e, this.index, "}")), this.scanTemplateLiteralPart(this.index)) : hi(e, this.index, t); }
    scanComplexOperator(e, t, s, r, i, o) { this.advance(); let a = t; return this.peek == s && (this.advance(), a += r), i != null && this.peek == i && (this.advance(), a += o), Zs(e, this.index, a); }
    scanIdentifier() { let e = this.index; for (this.advance(); Pc(this.peek);)
        this.advance(); let t = this.input.substring(e, this.index); return Wv.indexOf(t) > -1 ? Gv(e, this.index, t) : jv(e, this.index, t); }
    scanPrivateIdentifier() { let e = this.index; if (this.advance(), !Dc(this.peek))
        return this.error("Invalid character [#]", -1); for (; Pc(this.peek);)
        this.advance(); let t = this.input.substring(e, this.index); return zv(e, this.index, t); }
    scanNumber(e) { let t = this.index === e, s = !1; for (this.advance();;) {
        if (!Ct(this.peek))
            if (this.peek === ai) {
                if (!Ct(this.input.charCodeAt(this.index - 1)) || !Ct(this.input.charCodeAt(this.index + 1)))
                    return this.error("Invalid numeric separator", 0);
                s = !0;
            }
            else if (this.peek === os)
                t = !1;
            else if (Qv(this.peek)) {
                if (this.advance(), Zv(this.peek) && this.advance(), !Ct(this.peek))
                    return this.error("Invalid exponent", -1);
                t = !1;
            }
            else
                break;
        this.advance();
    } let r = this.input.substring(e, this.index); s && (r = r.replace(/_/g, "")); let i = t ? Kv(r) : parseFloat(r); return Xv(e, this.index, i); }
    scanString() { let e = this.index, t = this.peek; this.advance(); let s = "", r = this.index, i = this.input; for (; this.peek != t;)
        if (this.peek == gs) {
            let a = this.scanStringBackslash(s, r);
            if (typeof a != "string")
                return a;
            s = a, r = this.index;
        }
        else {
            if (this.peek == Se)
                return this.error("Unterminated quote", 0);
            this.advance();
        } let o = i.substring(r, this.index); return this.advance(), new cr(e, this.index, s + o, Rn.Plain); }
    scanQuestion(e) { this.advance(); let t = "?"; return (this.peek === ic || this.peek === os) && (t += this.peek === os ? "." : "?", this.advance()), Zs(e, this.index, t); }
    scanTemplateLiteralPart(e) { let t = "", s = this.index; for (; this.peek !== nl;)
        if (this.peek === gs) {
            let i = this.scanStringBackslash(t, s);
            if (typeof i != "string")
                return i;
            t = i, s = this.index;
        }
        else if (this.peek === Wo) {
            let i = this.index;
            if (this.advance(), this.peek === pt)
                return this.braceStack.push("interpolation"), this.tokens.push(new cr(e, i, t + this.input.substring(s, i), Rn.TemplateLiteralPart)), this.advance(), Zs(i, this.index, this.input.substring(i, this.index));
        }
        else {
            if (this.peek === Se)
                return this.error("Unterminated template literal", 0);
            this.advance();
        } let r = this.input.substring(s, this.index); return this.advance(), new cr(e, this.index, t + r, Rn.TemplateLiteralEnd); }
    error(e, t) { let s = this.index + t; return Yv(s, this.index, `Lexer Error: ${e} at column ${s} in expression [${this.input}]`); }
    scanStringBackslash(e, t) { e += this.input.substring(t, this.index); let s; if (this.advance(), this.peek === hh) {
        let r = this.input.substring(this.index + 1, this.index + 5);
        if (/^[0-9a-f]+$/i.test(r))
            s = parseInt(r, 16);
        else
            return this.error(`Invalid unicode escape [\\u${r}]`, 0);
        for (let i = 0; i < 5; i++)
            this.advance();
    }
    else
        s = Jv(this.peek), this.advance(); return e += String.fromCharCode(s), e; }
};
function Dc(n) { return Yn <= n && n <= li || qs <= n && n <= jo || n == ai || n == Wo; }
function Pc(n) { return Vr(n) || Ct(n) || n == ai || n == Wo; }
function Qv(n) { return n == om || n == tm; }
function Zv(n) { return n == eo || n == ah; }
function Jv(n) { switch (n) {
    case uh: return Bn;
    case bu: return rh;
    case ch: return _u;
    case ph: return Au;
    case fh: return sh;
    default: return n;
} }
function Kv(n) { let e = parseInt(n); if (isNaN(e))
    throw new Error("Invalid integer literal when parsing " + n); return e; }
var yl = class {
    strings;
    expressions;
    offsets;
    constructor(e, t, s) { this.strings = e, this.expressions = t, this.offsets = s; }
}, Cl = class {
    templateBindings;
    warnings;
    errors;
    constructor(e, t, s) { this.templateBindings = e, this.warnings = t, this.errors = s; }
}, xo = class {
    _lexer;
    errors = [];
    constructor(e) { this._lexer = e; }
    parseAction(e, t, s, r = et) { this._checkNoInterpolation(e, t, r); let i = this._stripComments(e), o = this._lexer.tokenize(i), a = new Tn(e, t, s, o, 1, this.errors, 0).parseChain(); return new Ke(a, e, t, s, this.errors); }
    parseBinding(e, t, s, r = et) { let i = this._parseBindingAst(e, t, s, r); return new Ke(i, e, t, s, this.errors); }
    checkSimpleExpression(e) { let t = new Al; return e.visit(t), t.errors; }
    parseSimpleBinding(e, t, s, r = et) { let i = this._parseBindingAst(e, t, s, r), o = this.checkSimpleExpression(i); return o.length > 0 && this._reportError(`Host binding expression cannot contain ${o.join(" ")}`, e, t), new Ke(i, e, t, s, this.errors); }
    _reportError(e, t, s, r) { this.errors.push(new yr(e, t, s, r)); }
    _parseBindingAst(e, t, s, r) { this._checkNoInterpolation(e, t, r); let i = this._stripComments(e), o = this._lexer.tokenize(i); return new Tn(e, t, s, o, 0, this.errors, 0).parseChain(); }
    parseTemplateBindings(e, t, s, r, i) { let o = this._lexer.tokenize(t); return new Tn(t, s, i, o, 0, this.errors, 0).parseTemplateBindings({ source: e, span: new qe(r, r + e.length) }); }
    parseInterpolation(e, t, s, r, i = et) { let { strings: o, expressions: a, offsets: l } = this.splitInterpolation(e, t, r, i); if (a.length === 0)
        return null; let u = []; for (let p = 0; p < a.length; ++p) {
        let f = a[p].text, g = this._stripComments(f), v = this._lexer.tokenize(g), S = new Tn(e, t, s, v, 0, this.errors, l[p]).parseChain();
        u.push(S);
    } return this.createInterpolationAst(o.map(p => p.text), u, e, t, s); }
    parseInterpolationExpression(e, t, s) { let r = this._stripComments(e), i = this._lexer.tokenize(r), o = new Tn(e, t, s, i, 0, this.errors, 0).parseChain(), a = ["", ""]; return this.createInterpolationAst(a, [o], e, t, s); }
    createInterpolationAst(e, t, s, r, i) { let o = new jn(0, s.length), a = new ii(o, o.toAbsolute(i), e, t); return new Ke(a, s, r, i, this.errors); }
    splitInterpolation(e, t, s, r = et) { let i = [], o = [], a = [], l = s ? ew(s) : null, u = 0, p = !1, f = !1, { start: g, end: v } = r; for (; u < e.length;)
        if (p) {
            let S = u, _ = S + g.length, x = this._getInterpolationEndIndex(e, v, _);
            if (x === -1) {
                p = !1, f = !0;
                break;
            }
            let T = x + v.length, M = e.substring(_, x);
            M.trim().length === 0 && this._reportError("Blank expressions are not allowed in interpolated strings", e, `at column ${u} in`, t), o.push({ text: M, start: S, end: T });
            let te = (l?.get(S) ?? S) + g.length;
            a.push(te), u = T, p = !1;
        }
        else {
            let S = u;
            u = e.indexOf(g, u), u === -1 && (u = e.length);
            let _ = e.substring(S, u);
            i.push({ text: _, start: S, end: u }), p = !0;
        } if (!p)
        if (f) {
            let S = i[i.length - 1];
            S.text += e.substring(u), S.end = e.length;
        }
        else
            i.push({ text: e.substring(u), start: u, end: e.length }); return new yl(i, o, a); }
    wrapLiteralPrimitive(e, t, s) { let r = new jn(0, e == null ? 0 : e.length); return new Ke(new Ze(r, r.toAbsolute(s), e), e, t, s, this.errors); }
    _stripComments(e) { let t = this._commentStart(e); return t != null ? e.substring(0, t) : e; }
    _commentStart(e) { let t = null; for (let s = 0; s < e.length - 1; s++) {
        let r = e.charCodeAt(s), i = e.charCodeAt(s + 1);
        if (r === $t && i == $t && t == null)
            return s;
        t === r ? t = null : t == null && or(r) && (t = r);
    } return null; }
    _checkNoInterpolation(e, t, { start: s, end: r }) { let i = -1, o = -1; for (let a of this._forEachUnquotedChar(e, 0))
        if (i === -1)
            e.startsWith(s) && (i = a);
        else if (o = this._getInterpolationEndIndex(e, r, a), o > -1)
            break; i > -1 && o > -1 && this._reportError(`Got interpolation (${s}${r}) where expression was expected`, e, `at column ${i} in`, t); }
    _getInterpolationEndIndex(e, t, s) { for (let r of this._forEachUnquotedChar(e, s)) {
        if (e.startsWith(t, r))
            return r;
        if (e.startsWith("//", r))
            return e.indexOf(t, r);
    } return -1; }
    *_forEachUnquotedChar(e, t) { let s = null, r = 0; for (let i = t; i < e.length; i++) {
        let o = e[i];
        or(e.charCodeAt(i)) && (s === null || s === o) && r % 2 === 0 ? s = s === null ? o : null : s === null && (yield i), r = o === "\\" ? r + 1 : 0;
    } }
}, nr = function (n) { return n[n.None = 0] = "None", n[n.Writable = 1] = "Writable", n; }(nr || {}), Tn = class {
    input;
    location;
    absoluteOffset;
    tokens;
    parseFlags;
    errors;
    offset;
    rparensExpected = 0;
    rbracketsExpected = 0;
    rbracesExpected = 0;
    context = nr.None;
    sourceSpanCache = new Map;
    index = 0;
    constructor(e, t, s, r, i, o, a) { this.input = e, this.location = t, this.absoluteOffset = s, this.tokens = r, this.parseFlags = i, this.errors = o, this.offset = a; }
    peek(e) { let t = this.index + e; return t < this.tokens.length ? this.tokens[t] : fi; }
    get next() { return this.peek(0); }
    get atEOF() { return this.index >= this.tokens.length; }
    get inputIndex() { return this.atEOF ? this.currentEndIndex : this.next.index + this.offset; }
    get currentEndIndex() { return this.index > 0 ? this.peek(-1).end + this.offset : this.tokens.length === 0 ? this.input.length + this.offset : this.next.index + this.offset; }
    get currentAbsoluteOffset() { return this.absoluteOffset + this.inputIndex; }
    span(e, t) { let s = this.currentEndIndex; if (t !== void 0 && t > this.currentEndIndex && (s = t), e > s) {
        let r = s;
        s = e, e = r;
    } return new jn(e, s); }
    sourceSpan(e, t) { let s = `${e}@${this.inputIndex}:${t}`; return this.sourceSpanCache.has(s) || this.sourceSpanCache.set(s, this.span(e, t).toAbsolute(this.absoluteOffset)), this.sourceSpanCache.get(s); }
    advance() { this.index++; }
    withContext(e, t) { this.context |= e; let s = t(); return this.context ^= e, s; }
    consumeOptionalCharacter(e) { return this.next.isCharacter(e) ? (this.advance(), !0) : !1; }
    peekKeywordLet() { return this.next.isKeywordLet(); }
    peekKeywordAs() { return this.next.isKeywordAs(); }
    expectCharacter(e) { this.consumeOptionalCharacter(e) || this.error(`Missing expected ${String.fromCharCode(e)}`); }
    consumeOptionalOperator(e) { return this.next.isOperator(e) ? (this.advance(), !0) : !1; }
    expectOperator(e) { this.consumeOptionalOperator(e) || this.error(`Missing expected operator ${e}`); }
    prettyPrintToken(e) { return e === fi ? "end of input" : `token ${e}`; }
    expectIdentifierOrKeyword() { let e = this.next; return !e.isIdentifier() && !e.isKeyword() ? (e.isPrivateIdentifier() ? this._reportErrorForPrivateIdentifier(e, "expected identifier or keyword") : this.error(`Unexpected ${this.prettyPrintToken(e)}, expected identifier or keyword`), null) : (this.advance(), e.toString()); }
    expectIdentifierOrKeywordOrString() { let e = this.next; return !e.isIdentifier() && !e.isKeyword() && !e.isString() ? (e.isPrivateIdentifier() ? this._reportErrorForPrivateIdentifier(e, "expected identifier, keyword or string") : this.error(`Unexpected ${this.prettyPrintToken(e)}, expected identifier, keyword, or string`), "") : (this.advance(), e.toString()); }
    parseChain() { let e = [], t = this.inputIndex; for (; this.index < this.tokens.length;) {
        let s = this.parsePipe();
        if (e.push(s), this.consumeOptionalCharacter($e))
            for (this.parseFlags & 1 || this.error("Binding expression cannot contain chained expression"); this.consumeOptionalCharacter($e);)
                ;
        else if (this.index < this.tokens.length) {
            let r = this.index;
            if (this.error(`Unexpected token '${this.next}'`), this.index === r)
                break;
        }
    } if (e.length === 0) {
        let s = this.offset, r = this.offset + this.input.length;
        return new Ne(this.span(s, r), this.sourceSpan(s, r));
    } return e.length == 1 ? e[0] : new As(this.span(t), this.sourceSpan(t), e); }
    parsePipe() { let e = this.inputIndex, t = this.parseExpression(); if (this.consumeOptionalOperator("|")) {
        this.parseFlags & 1 && this.error("Cannot have a pipe in an action expression");
        do {
            let s = this.inputIndex, r = this.expectIdentifierOrKeyword(), i, o;
            r !== null ? i = this.sourceSpan(s) : (r = "", o = this.next.index !== -1 ? this.next.index : this.input.length + this.offset, i = new jn(o, o).toAbsolute(this.absoluteOffset));
            let a = [];
            for (; this.consumeOptionalCharacter(rn);)
                a.push(this.parseExpression());
            t = new Mi(this.span(e), this.sourceSpan(e, o), t, r, a, i);
        } while (this.consumeOptionalOperator("|"));
    } return t; }
    parseExpression() { return this.parseConditional(); }
    parseConditional() { let e = this.inputIndex, t = this.parseLogicalOr(); if (this.consumeOptionalOperator("?")) {
        let s = this.parsePipe(), r;
        if (this.consumeOptionalCharacter(rn))
            r = this.parsePipe();
        else {
            let i = this.inputIndex, o = this.input.substring(e, i);
            this.error(`Conditional expression ${o} requires all 3 expressions`), r = new Ne(this.span(e), this.sourceSpan(e));
        }
        return new Ni(this.span(e), this.sourceSpan(e), t, s, r);
    }
    else
        return t; }
    parseLogicalOr() { let e = this.inputIndex, t = this.parseLogicalAnd(); for (; this.consumeOptionalOperator("||");) {
        let s = this.parseLogicalAnd();
        t = new ut(this.span(e), this.sourceSpan(e), "||", t, s);
    } return t; }
    parseLogicalAnd() { let e = this.inputIndex, t = this.parseNullishCoalescing(); for (; this.consumeOptionalOperator("&&");) {
        let s = this.parseNullishCoalescing();
        t = new ut(this.span(e), this.sourceSpan(e), "&&", t, s);
    } return t; }
    parseNullishCoalescing() { let e = this.inputIndex, t = this.parseEquality(); for (; this.consumeOptionalOperator("??");) {
        let s = this.parseEquality();
        t = new ut(this.span(e), this.sourceSpan(e), "??", t, s);
    } return t; }
    parseEquality() { let e = this.inputIndex, t = this.parseRelational(); for (; this.next.type == q.Operator;) {
        let s = this.next.strValue;
        switch (s) {
            case "==":
            case "===":
            case "!=":
            case "!==":
                this.advance();
                let r = this.parseRelational();
                t = new ut(this.span(e), this.sourceSpan(e), s, t, r);
                continue;
        }
        break;
    } return t; }
    parseRelational() { let e = this.inputIndex, t = this.parseAdditive(); for (; this.next.type == q.Operator;) {
        let s = this.next.strValue;
        switch (s) {
            case "<":
            case ">":
            case "<=":
            case ">=":
                this.advance();
                let r = this.parseAdditive();
                t = new ut(this.span(e), this.sourceSpan(e), s, t, r);
                continue;
        }
        break;
    } return t; }
    parseAdditive() { let e = this.inputIndex, t = this.parseMultiplicative(); for (; this.next.type == q.Operator;) {
        let s = this.next.strValue;
        switch (s) {
            case "+":
            case "-":
                this.advance();
                let r = this.parseMultiplicative();
                t = new ut(this.span(e), this.sourceSpan(e), s, t, r);
                continue;
        }
        break;
    } return t; }
    parseMultiplicative() { let e = this.inputIndex, t = this.parsePrefix(); for (; this.next.type == q.Operator;) {
        let s = this.next.strValue;
        switch (s) {
            case "*":
            case "%":
            case "/":
                this.advance();
                let r = this.parsePrefix();
                t = new ut(this.span(e), this.sourceSpan(e), s, t, r);
                continue;
        }
        break;
    } return t; }
    parsePrefix() { if (this.next.type == q.Operator) {
        let e = this.inputIndex, t = this.next.strValue, s;
        switch (t) {
            case "+": return this.advance(), s = this.parsePrefix(), Ar.createPlus(this.span(e), this.sourceSpan(e), s);
            case "-": return this.advance(), s = this.parsePrefix(), Ar.createMinus(this.span(e), this.sourceSpan(e), s);
            case "!": return this.advance(), s = this.parsePrefix(), new $i(this.span(e), this.sourceSpan(e), s);
        }
    }
    else if (this.next.isKeywordTypeof()) {
        this.advance();
        let e = this.inputIndex, t = this.parsePrefix();
        return new Oi(this.span(e), this.sourceSpan(e), t);
    } return this.parseCallChain(); }
    parseCallChain() { let e = this.inputIndex, t = this.parsePrimary(); for (;;)
        if (this.consumeOptionalCharacter(os))
            t = this.parseAccessMember(t, e, !1);
        else if (this.consumeOptionalOperator("?."))
            this.consumeOptionalCharacter(Ut) ? t = this.parseCall(t, e, !0) : t = this.consumeOptionalCharacter(ms) ? this.parseKeyedReadOrWrite(t, e, !0) : this.parseAccessMember(t, e, !0);
        else if (this.consumeOptionalCharacter(ms))
            t = this.parseKeyedReadOrWrite(t, e, !1);
        else if (this.consumeOptionalCharacter(Ut))
            t = this.parseCall(t, e, !1);
        else if (this.consumeOptionalOperator("!"))
            t = new _r(this.span(e), this.sourceSpan(e), t);
        else
            return t; }
    parsePrimary() { let e = this.inputIndex; if (this.consumeOptionalCharacter(Ut)) {
        this.rparensExpected++;
        let t = this.parsePipe();
        return this.rparensExpected--, this.expectCharacter(ft), t;
    }
    else {
        if (this.next.isKeywordNull())
            return this.advance(), new Ze(this.span(e), this.sourceSpan(e), null);
        if (this.next.isKeywordUndefined())
            return this.advance(), new Ze(this.span(e), this.sourceSpan(e), void 0);
        if (this.next.isKeywordTrue())
            return this.advance(), new Ze(this.span(e), this.sourceSpan(e), !0);
        if (this.next.isKeywordFalse())
            return this.advance(), new Ze(this.span(e), this.sourceSpan(e), !1);
        if (this.next.isKeywordThis())
            return this.advance(), new zn(this.span(e), this.sourceSpan(e));
        if (this.consumeOptionalCharacter(ms)) {
            this.rbracketsExpected++;
            let t = this.parseExpressionList(ps);
            return this.rbracketsExpected--, this.expectCharacter(ps), new Ri(this.span(e), this.sourceSpan(e), t);
        }
        else {
            if (this.next.isCharacter(pt))
                return this.parseLiteralMap();
            if (this.next.isIdentifier())
                return this.parseAccessMember(new rt(this.span(e), this.sourceSpan(e)), e, !1);
            if (this.next.isNumber()) {
                let t = this.next.toNumber();
                return this.advance(), new Ze(this.span(e), this.sourceSpan(e), t);
            }
            else {
                if (this.next.isTemplateLiteralEnd())
                    return this.parseNoInterpolationTemplateLiteral();
                if (this.next.isTemplateLiteralPart())
                    return this.parseTemplateLiteral();
                if (this.next.isString() && this.next.kind === Rn.Plain) {
                    let t = this.next.toString();
                    return this.advance(), new Ze(this.span(e), this.sourceSpan(e), t);
                }
                else
                    return this.next.isPrivateIdentifier() ? (this._reportErrorForPrivateIdentifier(this.next, null), new Ne(this.span(e), this.sourceSpan(e))) : this.index >= this.tokens.length ? (this.error(`Unexpected end of expression: ${this.input}`), new Ne(this.span(e), this.sourceSpan(e))) : (this.error(`Unexpected token ${this.next}`), new Ne(this.span(e), this.sourceSpan(e)));
            }
        }
    } }
    parseExpressionList(e) { let t = []; do
        if (!this.next.isCharacter(e))
            t.push(this.parsePipe());
        else
            break;
    while (this.consumeOptionalCharacter(st)); return t; }
    parseLiteralMap() { let e = [], t = [], s = this.inputIndex; if (this.expectCharacter(pt), !this.consumeOptionalCharacter(Pe)) {
        this.rbracesExpected++;
        do {
            let r = this.inputIndex, i = this.next.isString(), o = this.expectIdentifierOrKeywordOrString(), a = { key: o, quoted: i };
            if (e.push(a), i)
                this.expectCharacter(rn), t.push(this.parsePipe());
            else if (this.consumeOptionalCharacter(rn))
                t.push(this.parsePipe());
            else {
                a.isShorthandInitialized = !0;
                let l = this.span(r), u = this.sourceSpan(r);
                t.push(new Gn(l, u, u, new rt(l, u), o));
            }
        } while (this.consumeOptionalCharacter(st) && !this.next.isCharacter(Pe));
        this.rbracesExpected--, this.expectCharacter(Pe);
    } return new Fi(this.span(s), this.sourceSpan(s), e, t); }
    parseAccessMember(e, t, s) { let r = this.inputIndex, i = this.withContext(nr.Writable, () => { let l = this.expectIdentifierOrKeyword() ?? ""; return l.length === 0 && this.error("Expected identifier for property access", e.span.end), l; }), o = this.sourceSpan(r), a; if (s)
        this.consumeOptionalOperator("=") ? (this.error("The '?.' operator cannot be used in the assignment"), a = new Ne(this.span(t), this.sourceSpan(t))) : a = new Pi(this.span(t), this.sourceSpan(t), o, e, i);
    else if (this.consumeOptionalOperator("=")) {
        if (!(this.parseFlags & 1))
            return this.error("Bindings cannot contain assignments"), new Ne(this.span(t), this.sourceSpan(t));
        let l = this.parseConditional();
        a = new Di(this.span(t), this.sourceSpan(t), o, e, i, l);
    }
    else
        a = new Gn(this.span(t), this.sourceSpan(t), o, e, i); return a; }
    parseCall(e, t, s) { let r = this.inputIndex; this.rparensExpected++; let i = this.parseCallArguments(), o = this.span(r, this.inputIndex).toAbsolute(this.absoluteOffset); this.expectCharacter(ft), this.rparensExpected--; let a = this.span(t), l = this.sourceSpan(t); return s ? new Vi(a, l, e, i, o) : new Tr(a, l, e, i, o); }
    parseCallArguments() { if (this.next.isCharacter(ft))
        return []; let e = []; do
        e.push(this.parsePipe());
    while (this.consumeOptionalCharacter(st)); return e; }
    expectTemplateBindingKey() { let e = "", t = !1, s = this.currentAbsoluteOffset; do
        e += this.expectIdentifierOrKeywordOrString(), t = this.consumeOptionalOperator("-"), t && (e += "-");
    while (t); return { source: e, span: new qe(s, s + e.length) }; }
    parseTemplateBindings(e) { let t = []; for (t.push(...this.parseDirectiveKeywordBindings(e)); this.index < this.tokens.length;) {
        let s = this.parseLetBinding();
        if (s)
            t.push(s);
        else {
            let r = this.expectTemplateBindingKey(), i = this.parseAsBinding(r);
            i ? t.push(i) : (r.source = e.source + r.source.charAt(0).toUpperCase() + r.source.substring(1), t.push(...this.parseDirectiveKeywordBindings(r)));
        }
        this.consumeStatementTerminator();
    } return new Cl(t, [], this.errors); }
    parseKeyedReadOrWrite(e, t, s) { return this.withContext(nr.Writable, () => { this.rbracketsExpected++; let r = this.parsePipe(); if (r instanceof Ne && this.error("Key access cannot be empty"), this.rbracketsExpected--, this.expectCharacter(ps), this.consumeOptionalOperator("=")) {
        if (s)
            this.error("The '?.' operator cannot be used in the assignment");
        else {
            let i = this.parseConditional();
            return new Bi(this.span(t), this.sourceSpan(t), e, r, i);
        }
    }
    else
        return s ? new Li(this.span(t), this.sourceSpan(t), e, r) : new Cr(this.span(t), this.sourceSpan(t), e, r); return new Ne(this.span(t), this.sourceSpan(t)); }); }
    parseDirectiveKeywordBindings(e) { let t = []; this.consumeOptionalCharacter(rn); let s = this.getDirectiveBoundTarget(), r = this.currentAbsoluteOffset, i = this.parseAsBinding(e); i || (this.consumeStatementTerminator(), r = this.currentAbsoluteOffset); let o = new qe(e.span.start, r); return t.push(new Ma(o, e, s)), i && t.push(i), t; }
    getDirectiveBoundTarget() { if (this.next === fi || this.peekKeywordAs() || this.peekKeywordLet())
        return null; let e = this.parsePipe(), { start: t, end: s } = e.span, r = this.input.substring(t, s); return new Ke(e, r, this.location, this.absoluteOffset + t, this.errors); }
    parseAsBinding(e) { if (!this.peekKeywordAs())
        return null; this.advance(); let t = this.expectTemplateBindingKey(); this.consumeStatementTerminator(); let s = new qe(e.span.start, this.currentAbsoluteOffset); return new kr(s, t, e); }
    parseLetBinding() { if (!this.peekKeywordLet())
        return null; let e = this.currentAbsoluteOffset; this.advance(); let t = this.expectTemplateBindingKey(), s = null; this.consumeOptionalOperator("=") && (s = this.expectTemplateBindingKey()), this.consumeStatementTerminator(); let r = new qe(e, this.currentAbsoluteOffset); return new kr(r, t, s); }
    parseNoInterpolationTemplateLiteral() { let e = this.next.strValue, t = this.inputIndex; this.advance(); let s = this.span(t), r = this.sourceSpan(t); return new br(s, r, [new qi(s, r, e)], []); }
    parseTemplateLiteral() { let e = this.inputIndex, t = [], s = []; for (; this.next !== fi;) {
        let r = this.next;
        if (r.isTemplateLiteralPart() || r.isTemplateLiteralEnd()) {
            let i = this.inputIndex;
            if (this.advance(), t.push(new qi(this.span(i), this.sourceSpan(i), r.strValue)), r.isTemplateLiteralEnd())
                break;
        }
        else if (r.isTemplateLiteralInterpolationStart()) {
            this.advance();
            let i = this.parsePipe();
            i instanceof Ne ? this.error("Template literal interpolation cannot be empty") : s.push(i);
        }
        else
            this.advance();
    } return new br(this.span(e), this.sourceSpan(e), t, s); }
    consumeStatementTerminator() { this.consumeOptionalCharacter($e) || this.consumeOptionalCharacter(st); }
    error(e, t = null) { this.errors.push(new yr(e, this.input, this.locationText(t), this.location)), this.skip(); }
    locationText(e = null) { return e == null && (e = this.index), e < this.tokens.length ? `at column ${this.tokens[e].index + 1} in` : "at the end of the expression"; }
    _reportErrorForPrivateIdentifier(e, t) { let s = `Private identifiers are not supported. Unexpected private identifier: ${e}`; t !== null && (s += `, ${t}`), this.error(s); }
    skip() { let e = this.next; for (; this.index < this.tokens.length && !e.isCharacter($e) && !e.isOperator("|") && (this.rparensExpected <= 0 || !e.isCharacter(ft)) && (this.rbracesExpected <= 0 || !e.isCharacter(Pe)) && (this.rbracketsExpected <= 0 || !e.isCharacter(ps)) && (!(this.context & nr.Writable) || !e.isOperator("="));)
        this.next.isError() && this.errors.push(new yr(this.next.toString(), this.input, this.locationText(), this.location)), this.advance(), e = this.next; }
}, Al = class extends Hi {
    errors = [];
    visitPipe() { this.errors.push("pipes"); }
};
function ew(n) { let e = new Map, t = 0, s = 0, r = 0; for (; r < n.length;) {
    let i = n[r];
    if (i.type === 9) {
        let [o, a] = i.parts;
        t += a.length, s += o.length;
    }
    else {
        let o = i.parts.reduce((a, l) => a + l.length, 0);
        s += o, t += o;
    }
    e.set(s, t), r++;
} return e; }
function tw(n) { return n.visit(new _l); }
var _l = class {
    visitUnary(e, t) { return `${e.operator}${e.expr.visit(this, t)}`; }
    visitBinary(e, t) { return `${e.left.visit(this, t)} ${e.operation} ${e.right.visit(this, t)}`; }
    visitChain(e, t) { return e.expressions.map(s => s.visit(this, t)).join("; "); }
    visitConditional(e, t) { return `${e.condition.visit(this, t)} ? ${e.trueExp.visit(this, t)} : ${e.falseExp.visit(this, t)}`; }
    visitThisReceiver() { return "this"; }
    visitImplicitReceiver() { return ""; }
    visitInterpolation(e, t) { return sw(e.strings, e.expressions.map(s => s.visit(this, t))).join(""); }
    visitKeyedRead(e, t) { return `${e.receiver.visit(this, t)}[${e.key.visit(this, t)}]`; }
    visitKeyedWrite(e, t) { return `${e.receiver.visit(this, t)}[${e.key.visit(this, t)}] = ${e.value.visit(this, t)}`; }
    visitLiteralArray(e, t) { return `[${e.expressions.map(s => s.visit(this, t)).join(", ")}]`; }
    visitLiteralMap(e, t) { return `{${nw(e.keys.map(s => s.quoted ? `'${s.key}'` : s.key), e.values.map(s => s.visit(this, t))).map(([s, r]) => `${s}: ${r}`).join(", ")}}`; }
    visitLiteralPrimitive(e) { if (e.value === null)
        return "null"; switch (typeof e.value) {
        case "number":
        case "boolean": return e.value.toString();
        case "undefined": return "undefined";
        case "string": return `'${e.value.replace(/'/g, "\\'")}'`;
        default: throw new Error(`Unsupported primitive type: ${e.value}`);
    } }
    visitPipe(e, t) { return `${e.exp.visit(this, t)} | ${e.name}`; }
    visitPrefixNot(e, t) { return `!${e.expression.visit(this, t)}`; }
    visitNonNullAssert(e, t) { return `${e.expression.visit(this, t)}!`; }
    visitPropertyRead(e, t) { return e.receiver instanceof rt ? e.name : `${e.receiver.visit(this, t)}.${e.name}`; }
    visitPropertyWrite(e, t) { return e.receiver instanceof rt ? `${e.name} = ${e.value.visit(this, t)}` : `${e.receiver.visit(this, t)}.${e.name} = ${e.value.visit(this, t)}`; }
    visitSafePropertyRead(e, t) { return `${e.receiver.visit(this, t)}?.${e.name}`; }
    visitSafeKeyedRead(e, t) { return `${e.receiver.visit(this, t)}?.[${e.key.visit(this, t)}]`; }
    visitCall(e, t) { return `${e.receiver.visit(this, t)}(${e.args.map(s => s.visit(this, t)).join(", ")})`; }
    visitSafeCall(e, t) { return `${e.receiver.visit(this, t)}?.(${e.args.map(s => s.visit(this, t)).join(", ")})`; }
    visitTypeofExpression(e, t) { return `typeof ${e.expression.visit(this, t)}`; }
    visitASTWithSource(e, t) { return e.ast.visit(this, t); }
    visitTemplateLiteral(e, t) { let s = ""; for (let r = 0; r < e.elements.length; r++) {
        s += e.elements[r].visit(this, t);
        let i = r < e.expressions.length ? e.expressions[r] : null;
        i !== null && (s += "${" + i.visit(this, t) + "}");
    } return "`" + s + "`"; }
    visitTemplateLiteralElement(e, t) { return e.text; }
};
function nw(n, e) { if (n.length !== e.length)
    throw new Error("Array lengths must match"); return n.map((t, s) => [t, e[s]]); }
function sw(n, e) { let t = []; for (let s = 0; s < Math.max(n.length, e.length); s++)
    s < n.length && t.push(n[s]), s < e.length && t.push(e[s]); return t; }
var yi;
function Lc() { return yi || (yi = {}, di(ee.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), di(ee.STYLE, ["*|style"]), di(ee.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), di(ee.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), yi; }
function di(n, e) { for (let t of e)
    yi[t.toLowerCase()] = n; }
var rw = new Set(["sandbox", "allow", "allowfullscreen", "referrerpolicy", "csp", "fetchpriority"]);
function iw(n) { return rw.has(n.toLowerCase()); }
var Tl = class {
}, ow = "boolean", aw = "number", lw = "string", uw = "object", cw = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,search,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "search^[HTMLELement]|", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"], Wh = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), pw = Array.from(Wh).reduce((n, [e, t]) => (n.set(e, t), n), new Map), $s = class extends Tl {
    _schema = new Map;
    _eventSchema = new Map;
    constructor() { super(), cw.forEach(e => { let t = new Map, s = new Set, [r, i] = e.split("|"), o = i.split(","), [a, l] = r.split("^"); a.split(",").forEach(p => { this._schema.set(p.toLowerCase(), t), this._eventSchema.set(p.toLowerCase(), s); }); let u = l && this._schema.get(l.toLowerCase()); if (u) {
        for (let [p, f] of u)
            t.set(p, f);
        for (let p of this._eventSchema.get(l.toLowerCase()))
            s.add(p);
    } o.forEach(p => { if (p.length > 0)
        switch (p[0]) {
            case "*":
                s.add(p.substring(1));
                break;
            case "!":
                t.set(p.substring(1), ow);
                break;
            case "#":
                t.set(p.substring(1), aw);
                break;
            case "%":
                t.set(p.substring(1), uw);
                break;
            default: t.set(p, lw);
        } }); }); }
    hasProperty(e, t, s) { if (s.some(i => i.name === Ca.name))
        return !0; if (e.indexOf("-") > -1) {
        if (ec(e) || Fa(e))
            return !1;
        if (s.some(i => i.name === ya.name))
            return !0;
    } return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(t); }
    hasElement(e, t) { return t.some(s => s.name === Ca.name) || e.indexOf("-") > -1 && (ec(e) || Fa(e) || t.some(s => s.name === ya.name)) ? !0 : this._schema.has(e.toLowerCase()); }
    securityContext(e, t, s) { s && (t = this.getMappedPropName(t)), e = e.toLowerCase(), t = t.toLowerCase(); let r = Lc()[e + "|" + t]; return r || (r = Lc()["*|" + t], r || ee.NONE); }
    getMappedPropName(e) { return Wh.get(e) ?? e; }
    getDefaultComponentElementName() { return "ng-component"; }
    validateProperty(e) {
        return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
    }
    validateAttribute(e) { return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 }; }
    allKnownElementNames() { return Array.from(this._schema.keys()); }
    allKnownAttributesOfElement(e) { let t = this._schema.get(e.toLowerCase()) || this._schema.get("unknown"); return Array.from(t.keys()).map(s => pw.get(s) ?? s); }
    allKnownEventsOfElement(e) { return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []); }
    normalizeAnimationStyleProperty(e) { return md(e); }
    normalizeAnimationStyleValue(e, t, s) { let r = "", i = s.toString().trim(), o = null; if (hw(e) && s !== 0 && s !== "0")
        if (typeof s == "number")
            r = "px";
        else {
            let a = s.match(/^[+-]?[\d\.]+([a-z]*)$/);
            a && a[1].length == 0 && (o = `Please provide a CSS unit value for ${t}:${s}`);
        } return { error: o, value: i + r }; }
};
function hw(n) { switch (n) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent": return !0;
    default: return !1;
} }
var O = class {
    closedByChildren = {};
    contentType;
    closedByParent = !1;
    implicitNamespacePrefix;
    isVoid;
    ignoreFirstLf;
    canSelfClose;
    preventNamespaceInheritance;
    constructor({ closedByChildren: e, implicitNamespacePrefix: t, contentType: s = _t.PARSABLE_DATA, closedByParent: r = !1, isVoid: i = !1, ignoreFirstLf: o = !1, preventNamespaceInheritance: a = !1, canSelfClose: l = !1 } = {}) { e && e.length > 0 && e.forEach(u => this.closedByChildren[u] = !0), this.isVoid = i, this.closedByParent = r || i, this.implicitNamespacePrefix = t || null, this.contentType = s, this.ignoreFirstLf = o, this.preventNamespaceInheritance = a, this.canSelfClose = l ?? i; }
    isClosedByChild(e) { return this.isVoid || e.toLowerCase() in this.closedByChildren; }
    getContentType(e) { return typeof this.contentType == "object" ? (e === void 0 ? void 0 : this.contentType[e]) ?? this.contentType.default : this.contentType; }
}, Bc, rs;
function jh(n) { return rs || (Bc = new O({ canSelfClose: !0 }), rs = Object.assign(Object.create(null), { base: new O({ isVoid: !0 }), meta: new O({ isVoid: !0 }), area: new O({ isVoid: !0 }), embed: new O({ isVoid: !0 }), link: new O({ isVoid: !0 }), img: new O({ isVoid: !0 }), input: new O({ isVoid: !0 }), param: new O({ isVoid: !0 }), hr: new O({ isVoid: !0 }), br: new O({ isVoid: !0 }), source: new O({ isVoid: !0 }), track: new O({ isVoid: !0 }), wbr: new O({ isVoid: !0 }), p: new O({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new O({ closedByChildren: ["tbody", "tfoot"] }), tbody: new O({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new O({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new O({ closedByChildren: ["tr"], closedByParent: !0 }), td: new O({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new O({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new O({ isVoid: !0 }), svg: new O({ implicitNamespacePrefix: "svg" }), foreignObject: new O({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new O({ implicitNamespacePrefix: "math" }), li: new O({ closedByChildren: ["li"], closedByParent: !0 }), dt: new O({ closedByChildren: ["dt", "dd"] }), dd: new O({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new O({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new O({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new O({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new O({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new O({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new O({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new O({ ignoreFirstLf: !0 }), listing: new O({ ignoreFirstLf: !0 }), style: new O({ contentType: _t.RAW_TEXT }), script: new O({ contentType: _t.RAW_TEXT }), title: new O({ contentType: { default: _t.ESCAPABLE_RAW_TEXT, svg: _t.PARSABLE_DATA } }), textarea: new O({ contentType: _t.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new $s().allKnownElementNames().forEach(e => { !rs[e] && $a(e) === null && (rs[e] = new O({ canSelfClose: !1 })); })), rs[n] ?? rs[n.toLowerCase()] ?? Bc; }
var Mc = { A: "LINK", B: "BOLD_TEXT", BR: "LINE_BREAK", EM: "EMPHASISED_TEXT", H1: "HEADING_LEVEL1", H2: "HEADING_LEVEL2", H3: "HEADING_LEVEL3", H4: "HEADING_LEVEL4", H5: "HEADING_LEVEL5", H6: "HEADING_LEVEL6", HR: "HORIZONTAL_RULE", I: "ITALIC_TEXT", LI: "LIST_ITEM", LINK: "MEDIA_LINK", OL: "ORDERED_LIST", P: "PARAGRAPH", Q: "QUOTATION", S: "STRIKETHROUGH_TEXT", SMALL: "SMALL_TEXT", SUB: "SUBSTRIPT", SUP: "SUPERSCRIPT", TBODY: "TABLE_BODY", TD: "TABLE_CELL", TFOOT: "TABLE_FOOTER", TH: "TABLE_HEADER_CELL", THEAD: "TABLE_HEADER", TR: "TABLE_ROW", TT: "MONOSPACED_TEXT", U: "UNDERLINED_TEXT", UL: "UNORDERED_LIST" }, bl = class {
    _placeHolderNameCounts = {};
    _signatureToName = {};
    getStartTagPlaceholderName(e, t, s) { let r = this._hashTag(e, t, s); if (this._signatureToName[r])
        return this._signatureToName[r]; let i = e.toUpperCase(), o = Mc[i] || `TAG_${i}`, a = this._generateUniqueName(s ? o : `START_${o}`); return this._signatureToName[r] = a, a; }
    getCloseTagPlaceholderName(e) { let t = this._hashClosingTag(e); if (this._signatureToName[t])
        return this._signatureToName[t]; let s = e.toUpperCase(), r = Mc[s] || `TAG_${s}`, i = this._generateUniqueName(`CLOSE_${r}`); return this._signatureToName[t] = i, i; }
    getPlaceholderName(e, t) { let s = e.toUpperCase(), r = `PH: ${s}=${t}`; if (this._signatureToName[r])
        return this._signatureToName[r]; let i = this._generateUniqueName(s); return this._signatureToName[r] = i, i; }
    getUniquePlaceholder(e) { return this._generateUniqueName(e.toUpperCase()); }
    getStartBlockPlaceholderName(e, t) { let s = this._hashBlock(e, t); if (this._signatureToName[s])
        return this._signatureToName[s]; let r = this._generateUniqueName(`START_BLOCK_${this._toSnakeCase(e)}`); return this._signatureToName[s] = r, r; }
    getCloseBlockPlaceholderName(e) { let t = this._hashClosingBlock(e); if (this._signatureToName[t])
        return this._signatureToName[t]; let s = this._generateUniqueName(`CLOSE_BLOCK_${this._toSnakeCase(e)}`); return this._signatureToName[t] = s, s; }
    _hashTag(e, t, s) { let r = `<${e}`, i = Object.keys(t).sort().map(a => ` ${a}=${t[a]}`).join(""), o = s ? "/>" : `></${e}>`; return r + i + o; }
    _hashClosingTag(e) { return this._hashTag(`/${e}`, {}, !1); }
    _hashBlock(e, t) { let s = t.length === 0 ? "" : ` (${t.sort().join("; ")})`; return `@${e}${s} {}`; }
    _hashClosingBlock(e) { return this._hashBlock(`close_${e}`, []); }
    _toSnakeCase(e) { return e.toUpperCase().replace(/[^A-Z0-9]/g, "_"); }
    _generateUniqueName(e) { if (!this._placeHolderNameCounts.hasOwnProperty(e))
        return this._placeHolderNameCounts[e] = 1, e; let s = this._placeHolderNameCounts[e]; return this._placeHolderNameCounts[e] = s + 1, `${e}_${s}`; }
}, fw = new xo(new Kr());
function zh(n, e, t, s) { let r = new kl(fw, n, e, t, s); return (i, o, a, l, u) => r.toI18nMessage(i, o, a, l, u); }
function dw(n, e) { return e; }
var kl = class {
    _expressionParser;
    _interpolationConfig;
    _containerBlocks;
    _retainEmptyTokens;
    _preserveExpressionWhitespace;
    constructor(e, t, s, r, i) { this._expressionParser = e, this._interpolationConfig = t, this._containerBlocks = s, this._retainEmptyTokens = r, this._preserveExpressionWhitespace = i; }
    toI18nMessage(e, t = "", s = "", r = "", i) { let o = { isIcu: e.length == 1 && e[0] instanceof un, icuDepth: 0, placeholderRegistry: new bl, placeholderToContent: {}, placeholderToMessage: {}, visitNodeFn: i || dw }, a = D(this, e, o); return new Ae(a, o.placeholderToContent, o.placeholderToMessage, t, s, r); }
    visitElement(e, t) { let s = D(this, e.children, t), r = {}; e.attrs.forEach(u => { r[u.name] = u.value; }); let i = jh(e.name).isVoid, o = t.placeholderRegistry.getStartTagPlaceholderName(e.name, r, i); t.placeholderToContent[o] = { text: e.startSourceSpan.toString(), sourceSpan: e.startSourceSpan }; let a = ""; i || (a = t.placeholderRegistry.getCloseTagPlaceholderName(e.name), t.placeholderToContent[a] = { text: `</${e.name}>`, sourceSpan: e.endSourceSpan ?? e.sourceSpan }); let l = new Pt(e.name, r, o, a, s, i, e.sourceSpan, e.startSourceSpan, e.endSourceSpan); return t.visitNodeFn(e, l); }
    visitAttribute(e, t) { let s = e.valueTokens === void 0 || e.valueTokens.length === 1 ? new Tt(e.value, e.valueSpan || e.sourceSpan) : this._visitTextWithInterpolation(e.valueTokens, e.valueSpan || e.sourceSpan, t, e.i18n); return t.visitNodeFn(e, s); }
    visitText(e, t) { let s = e.tokens.length === 1 ? new Tt(e.value, e.sourceSpan) : this._visitTextWithInterpolation(e.tokens, e.sourceSpan, t, e.i18n); return t.visitNodeFn(e, s); }
    visitComment(e, t) { return null; }
    visitExpansion(e, t) { t.icuDepth++; let s = {}, r = new gn(e.switchValue, e.type, s, e.sourceSpan); if (e.cases.forEach(a => { s[a.value] = new We(a.expression.map(l => l.visit(this, t)), a.expSourceSpan); }), t.icuDepth--, t.isIcu || t.icuDepth > 0) {
        let a = t.placeholderRegistry.getUniquePlaceholder(`VAR_${e.type}`);
        return r.expressionPlaceholder = a, t.placeholderToContent[a] = { text: e.switchValue, sourceSpan: e.switchValueSourceSpan }, t.visitNodeFn(e, r);
    } let i = t.placeholderRegistry.getPlaceholderName("ICU", e.sourceSpan.toString()); t.placeholderToMessage[i] = this.toI18nMessage([e], "", "", "", void 0); let o = new vn(r, i, e.sourceSpan); return t.visitNodeFn(e, o); }
    visitExpansionCase(e, t) { throw new Error("Unreachable code"); }
    visitBlock(e, t) { let s = D(this, e.children, t); if (this._containerBlocks.has(e.name))
        return new We(s, e.sourceSpan); let r = e.parameters.map(l => l.expression), i = t.placeholderRegistry.getStartBlockPlaceholderName(e.name, r), o = t.placeholderRegistry.getCloseBlockPlaceholderName(e.name); t.placeholderToContent[i] = { text: e.startSourceSpan.toString(), sourceSpan: e.startSourceSpan }, t.placeholderToContent[o] = { text: e.endSourceSpan ? e.endSourceSpan.toString() : "}", sourceSpan: e.endSourceSpan ?? e.sourceSpan }; let a = new Lt(e.name, r, i, o, s, e.sourceSpan, e.startSourceSpan, e.endSourceSpan); return t.visitNodeFn(e, a); }
    visitBlockParameter(e, t) { throw new Error("Unreachable code"); }
    visitLetDeclaration(e, t) { return null; }
    _visitTextWithInterpolation(e, t, s, r) { let i = [], o = !1; for (let a of e)
        switch (a.type) {
            case 8:
            case 17:
                o = !0;
                let [l, u, p] = a.parts, f = Ew(u) || "INTERPOLATION", g = s.placeholderRegistry.getPlaceholderName(f, u);
                if (this._preserveExpressionWhitespace)
                    s.placeholderToContent[g] = { text: a.parts.join(""), sourceSpan: a.sourceSpan }, i.push(new ot(u, g, a.sourceSpan));
                else {
                    let v = this.normalizeExpression(a);
                    s.placeholderToContent[g] = { text: `${l}${v}${p}`, sourceSpan: a.sourceSpan }, i.push(new ot(v, g, a.sourceSpan));
                }
                break;
            default:
                if (a.parts[0].length > 0 || this._retainEmptyTokens) {
                    let v = i[i.length - 1];
                    v instanceof Tt ? (v.value += a.parts[0], v.sourceSpan = new R(v.sourceSpan.start, a.sourceSpan.end, v.sourceSpan.fullStart, v.sourceSpan.details)) : i.push(new Tt(a.parts[0], a.sourceSpan));
                }
                else
                    this._retainEmptyTokens && i.push(new Tt(a.parts[0], a.sourceSpan));
                break;
        } return o ? (mw(i, r), new We(i, t)) : i[0]; }
    normalizeExpression(e) { let t = e.parts[1], s = this._expressionParser.parseBinding(t, e.sourceSpan.start.toString(), e.sourceSpan.start.offset, this._interpolationConfig); return tw(s); }
};
function mw(n, e) { if (e instanceof Ae && (gw(e), e = e.nodes[0]), e instanceof We) {
    vw(e.children, n);
    for (let t = 0; t < n.length; t++)
        n[t].sourceSpan = e.children[t].sourceSpan;
} }
function gw(n) { let e = n.nodes; if (e.length !== 1 || !(e[0] instanceof We))
    throw new Error("Unexpected previous i18n message - expected it to consist of only a single `Container` node."); }
function vw(n, e) {
    if (n.length !== e.length)
        throw new Error(`
The number of i18n message children changed between first and second pass.

First pass (${n.length} tokens):
${n.map(t => `"${t.sourceSpan.toString()}"`).join(`
`)}

Second pass (${e.length} tokens):
${e.map(t => `"${t.sourceSpan.toString()}"`).join(`
`)}
    `.trim());
    if (n.some((t, s) => e[s].constructor !== t.constructor))
        throw new Error("The types of the i18n message children changed between first and second pass.");
}
var ww = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
function Ew(n) { return n.split(ww)[2]; }
var xt = class extends L {
    constructor(e, t) { super(e, t); }
}, Rc = new Set(["iframe|srcdoc", "*|innerhtml", "*|outerhtml", "embed|src", "object|codebase", "object|data"]);
function Sw(n, e) { return n = n.toLowerCase(), e = e.toLowerCase(), Rc.has(n + "|" + e) || Rc.has("*|" + e); }
var xw = n => (e, t) => { let s = n.get(e) ?? e; return s instanceof En && (t instanceof vn && s.i18n instanceof Ae && (t.previousMessage = s.i18n), s.i18n = t), t; }, yo = class {
    interpolationConfig;
    keepI18nAttrs;
    enableI18nLegacyMessageIdFormat;
    containerBlocks;
    preserveSignificantWhitespace;
    retainEmptyTokens;
    hasI18nMeta = !1;
    _errors = [];
    constructor(e = et, t = !1, s = !1, r = nh, i = !0, o = !i) { this.interpolationConfig = e, this.keepI18nAttrs = t, this.enableI18nLegacyMessageIdFormat = s, this.containerBlocks = r, this.preserveSignificantWhitespace = i, this.retainEmptyTokens = o; }
    _generateI18nMessage(e, t = "", s) { let { meaning: r, description: i, customId: o } = this._parseMetadata(t), l = zh(this.interpolationConfig, this.containerBlocks, this.retainEmptyTokens, this.preserveSignificantWhitespace)(e, r, i, o, s); return this._setMessageId(l, t), this._setLegacyIds(l, t), l; }
    visitAllWithErrors(e) { let t = e.map(s => s.visit(this, null)); return new Fs(t, this._errors); }
    visitElement(e) { let t; if (zd(e)) {
        this.hasI18nMeta = !0;
        let s = [], r = {};
        for (let i of e.attrs)
            if (i.name === Zp) {
                let o = e.i18n || i.value, a = new Map, l = this.preserveSignificantWhitespace ? e.children : _n(new Jr(!1, a), e.children);
                t = this._generateI18nMessage(l, o, xw(a)), t.nodes.length === 0 && (t = void 0), e.i18n = t;
            }
            else if (i.name.startsWith(Ka)) {
                let o = i.name.slice(Ka.length);
                Sw(e.name, o) ? this._reportError(i, `Translating attribute '${o}' is disallowed for security reasons.`) : r[o] = i.value;
            }
            else
                s.push(i);
        if (Object.keys(r).length)
            for (let i of s) {
                let o = r[i.name];
                o !== void 0 && i.value && (i.i18n = this._generateI18nMessage([i], i.i18n || o));
            }
        this.keepI18nAttrs || (e.attrs = s);
    } return D(this, e.children, t), e; }
    visitExpansion(e, t) { let s, r = e.i18n; if (this.hasI18nMeta = !0, r instanceof vn) {
        let i = r.name;
        s = this._generateI18nMessage([e], r);
        let o = Kp(s);
        o.name = i, t !== null && (t.placeholderToMessage[i] = s);
    }
    else
        s = this._generateI18nMessage([e], t || r); return e.i18n = s, e; }
    visitText(e) { return e; }
    visitAttribute(e) { return e; }
    visitComment(e) { return e; }
    visitExpansionCase(e) { return e; }
    visitBlock(e, t) { return D(this, e.children, t), e; }
    visitBlockParameter(e, t) { return e; }
    visitLetDeclaration(e, t) { return e; }
    _parseMetadata(e) { return typeof e == "string" ? Aw(e) : e instanceof Ae ? e : {}; }
    _setMessageId(e, t) { e.id || (e.id = t instanceof Ae && t.id || hu(e)); }
    _setLegacyIds(e, t) { if (this.enableI18nLegacyMessageIdFormat)
        e.legacyIds = [Lp(e), Bp(e)];
    else if (typeof t != "string") {
        let s = t instanceof Ae ? t : t instanceof vn ? t.previousMessage : void 0;
        e.legacyIds = s ? s.legacyIds : [];
    } }
    _reportError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
}, yw = "|", Cw = "@@";
function Aw(n = "") { let e, t, s; if (n = n.trim(), n) {
    let r = n.indexOf(Cw), i = n.indexOf(yw), o;
    [o, e] = r > -1 ? [n.slice(0, r), n.slice(r + 2)] : [n, ""], [t, s] = i > -1 ? [o.slice(0, i), o.slice(i + 1)] : ["", o];
} return { customId: e, meaning: t, description: s }; }
function _w(n) { let e = []; return n.description ? e.push({ tagName: "desc", text: n.description }) : e.push({ tagName: "suppress", text: "{msgDescriptions}" }), n.meaning && e.push({ tagName: "meaning", text: n.meaning }), Vp(e); }
var Tw = "goog.getMsg";
function bw(n, e, t, s) { let r = Iw(e), i = [d(r)]; Object.keys(s).length && (i.push(vo(Su(s, !0), !0)), i.push(vo({ original_code: ue(Object.keys(s).map(l => ({ key: oi(l), quoted: !0, value: e.placeholders[l] ? d(e.placeholders[l].sourceSpan.toString()) : d(e.placeholderToMessage[l].nodes.map(u => u.sourceSpan.toString()).join("")) }))) }))); let o = t.set(N(Tw).callFn(i)).toConstDecl(); o.addLeadingComment(_w(e)); let a = new Ge(n.set(t)); return [o, a]; }
var Il = class {
    formatPh(e) { return `{$${oi(e)}}`; }
    visitText(e) { return e.value; }
    visitContainer(e) { return e.children.map(t => t.visit(this)).join(""); }
    visitIcu(e) { return Rh(e); }
    visitTagPlaceholder(e) { return e.isVoid ? this.formatPh(e.startName) : `${this.formatPh(e.startName)}${e.children.map(t => t.visit(this)).join("")}${this.formatPh(e.closeName)}`; }
    visitPlaceholder(e) { return this.formatPh(e.name); }
    visitBlockPlaceholder(e) { return `${this.formatPh(e.startName)}${e.children.map(t => t.visit(this)).join("")}${this.formatPh(e.closeName)}`; }
    visitIcuPlaceholder(e, t) { return this.formatPh(e.name); }
}, kw = new Il;
function Iw(n) { return n.nodes.map(e => e.visit(kw, null)).join(""); }
function Nw(n, e, t) { let { messageParts: s, placeHolders: r } = Dw(e), i = Pw(e), o = r.map(u => t[u.text]), a = Up(e, s, r, o, i), l = n.set(a); return [new Ge(l)]; }
var Nl = class {
    placeholderToMessage;
    pieces;
    constructor(e, t) { this.placeholderToMessage = e, this.pieces = t; }
    visitText(e) { if (this.pieces[this.pieces.length - 1] instanceof ln)
        this.pieces[this.pieces.length - 1].text += e.value;
    else {
        let t = new R(e.sourceSpan.fullStart, e.sourceSpan.end, e.sourceSpan.fullStart, e.sourceSpan.details);
        this.pieces.push(new ln(e.value, t));
    } }
    visitContainer(e) { e.children.forEach(t => t.visit(this)); }
    visitIcu(e) { this.pieces.push(new ln(Rh(e), e.sourceSpan)); }
    visitTagPlaceholder(e) { this.pieces.push(this.createPlaceholderPiece(e.startName, e.startSourceSpan ?? e.sourceSpan)), e.isVoid || (e.children.forEach(t => t.visit(this)), this.pieces.push(this.createPlaceholderPiece(e.closeName, e.endSourceSpan ?? e.sourceSpan))); }
    visitPlaceholder(e) { this.pieces.push(this.createPlaceholderPiece(e.name, e.sourceSpan)); }
    visitBlockPlaceholder(e) { this.pieces.push(this.createPlaceholderPiece(e.startName, e.startSourceSpan ?? e.sourceSpan)), e.children.forEach(t => t.visit(this)), this.pieces.push(this.createPlaceholderPiece(e.closeName, e.endSourceSpan ?? e.sourceSpan)); }
    visitIcuPlaceholder(e) { this.pieces.push(this.createPlaceholderPiece(e.name, e.sourceSpan, this.placeholderToMessage[e.name])); }
    createPlaceholderPiece(e, t, s) { return new Pn(oi(e, !1), t, s); }
};
function Dw(n) { let e = [], t = new Nl(n.placeholderToMessage, e); return n.nodes.forEach(s => s.visit(t)), Lw(e); }
function Pw(n) { let e = n.nodes[0], t = n.nodes[n.nodes.length - 1]; return new R(e.sourceSpan.fullStart, t.sourceSpan.end, e.sourceSpan.fullStart, e.sourceSpan.details); }
function Lw(n) { let e = [], t = []; n[0] instanceof Pn && e.push(oa(n[0].sourceSpan.start)); for (let s = 0; s < n.length; s++) {
    let r = n[s];
    r instanceof ln ? e.push(r) : (t.push(r), n[s - 1] instanceof Pn && e.push(oa(n[s - 1].sourceSpan.end)));
} return n[n.length - 1] instanceof Pn && e.push(oa(n[n.length - 1].sourceSpan.end)), { messageParts: e, placeHolders: t }; }
function oa(n) { return new ln("", new R(n, n)); }
var Fc = "ngI18nClosureMode", Bw = "i18n_", Mw = "I18N_EXP_", $c = "\uFFFD", Rw = "MSG_";
function Oc(n) { return `${Rw}${n}`.toUpperCase(); }
function Fw(n) { return new ve(n.name, void 0, Ve, void 0, n.sourceSpan); }
function $w(n) { let e = n.relativeContextFilePath.replace(/[^A-Za-z0-9]/g, "_").toUpperCase() + "_", t = new Map, s = new Map, r = new Map, i = new Map; for (let l of n.units)
    for (let u of l.ops())
        if (u.kind === c.ExtractedAttribute && u.i18nContext !== null) {
            let p = t.get(u.i18nContext) ?? [];
            p.push(u), t.set(u.i18nContext, p);
        }
        else if (u.kind === c.I18nAttributes)
            s.set(u.target, u);
        else if (u.kind === c.I18nExpression && u.usage === Hs.I18nAttribute) {
            let p = r.get(u.target) ?? [];
            p.push(u), r.set(u.target, p);
        }
        else
            u.kind === c.I18nMessage && i.set(u.xref, u); let o = new Map, a = new Map; for (let l of n.units)
    for (let u of l.create)
        if (u.kind === c.I18nMessage) {
            if (u.messagePlaceholder === null) {
                let { mainVar: p, statements: f } = Gh(n, e, i, u);
                if (u.i18nBlock !== null) {
                    let g = n.addConst(p, f);
                    a.set(u.i18nBlock, g);
                }
                else {
                    n.constsInitializers.push(...f), o.set(u.i18nContext, p);
                    let g = t.get(u.i18nContext);
                    if (g !== void 0)
                        for (let v of g)
                            v.expression = p.clone();
                }
            }
            w.remove(u);
        } for (let l of n.units)
    for (let u of l.create)
        if (wn(u)) {
            let p = s.get(u.xref);
            if (p === void 0)
                continue;
            let f = r.get(u.xref);
            if (f === void 0)
                throw new Error("AssertionError: Could not find any i18n expressions associated with an I18nAttributes instruction");
            let g = new Set;
            f = f.filter(S => { let _ = g.has(S.name); return g.add(S.name), !_; });
            let v = f.flatMap(S => { let _ = o.get(S.context); if (_ === void 0)
                throw new Error("AssertionError: Could not find i18n expression's value"); return [d(S.name), _]; });
            p.i18nAttributesConfig = n.addConst(new at(v));
        } for (let l of n.units)
    for (let u of l.create)
        if (u.kind === c.I18nStart) {
            let p = a.get(u.root);
            if (p === void 0)
                throw new Error("AssertionError: Could not find corresponding i18n block index for an i18n message op; was an i18n message incorrectly assumed to correspond to an attribute?");
            u.messageIndex = p;
        } }
function Gh(n, e, t, s) { let r = [], i = new Map; for (let u of s.subMessages) {
    let p = t.get(u), { mainVar: f, statements: g } = Gh(n, e, t, p);
    r.push(...g);
    let v = i.get(p.messagePlaceholder) ?? [];
    v.push(f), i.set(p.messagePlaceholder, v);
} Ow(s, i), s.params = new Map([...s.params.entries()].sort()); let o = N(n.pool.uniqueName(Bw)), a = Hw(n.pool, s.message.id, e, n.i18nUseExternalIds), l; if (s.needsPostprocessing || s.postprocessingParams.size > 0) {
    let u = Object.fromEntries([...s.postprocessingParams.entries()].sort()), p = Su(u, !1), f = [];
    s.postprocessingParams.size > 0 && f.push(vo(p, !0)), l = g => y(h.i18nPostprocess).callFn([g, ...f]);
} return r.push(...Vw(s.message, o, a, s.params, l)), { mainVar: o, statements: r }; }
function Ow(n, e) { for (let [t, s] of e)
    s.length === 1 ? n.params.set(t, s[0]) : (n.params.set(t, d(`${$c}${Mw}${t}${$c}`)), n.postprocessingParams.set(t, B(s))); }
function Vw(n, e, t, s, r) { let i = Object.fromEntries(s), o = [Fw(e), ri(qw(), bw(e, n, t, i), Nw(e, n, Su(i, !1)))]; return r && o.push(new Ge(e.set(r(e)))), o; }
function qw() { return Vs(N(Fc)).notIdentical(d("undefined", Vo)).and(N(Fc)); }
function Hw(n, e, t, s) { let r, i = t; if (s) {
    let o = Oc("EXTERNAL_"), a = n.uniqueName(i);
    r = `${o}${ar(e)}$$${a}`;
}
else {
    let o = Oc(i);
    r = n.uniqueName(o);
} return N(r); }
function Uw(n) { for (let e of n.units) {
    let t = null, s = null, r = new Map, i = new Map, o = new Map;
    for (let a of e.create)
        switch (a.kind) {
            case c.I18nStart:
                if (a.context === null)
                    throw Error("I18n op should have its context set.");
                t = a;
                break;
            case c.I18nEnd:
                t = null;
                break;
            case c.IcuStart:
                if (a.context === null)
                    throw Error("Icu op should have its context set.");
                s = a;
                break;
            case c.IcuEnd:
                s = null;
                break;
            case c.Text:
                if (t !== null)
                    if (r.set(a.xref, t), i.set(a.xref, s), a.icuPlaceholder !== null) {
                        let l = Eg(n.allocateXrefId(), a.icuPlaceholder, [a.initialValue]);
                        w.replace(a, l), o.set(a.xref, l);
                    }
                    else
                        w.remove(a);
                break;
        }
    for (let a of e.update)
        switch (a.kind) {
            case c.InterpolateText:
                if (!r.has(a.target))
                    continue;
                let l = r.get(a.target), u = i.get(a.target), p = o.get(a.target), f = u ? u.context : l.context, g = u ? Ur.Postproccessing : Ur.Creation, v = [];
                for (let S = 0; S < a.interpolation.expressions.length; S++) {
                    let _ = a.interpolation.expressions[S];
                    v.push(bh(f, l.xref, l.xref, l.handle, _, p?.xref ?? null, a.interpolation.i18nPlaceholders[S] ?? null, g, Hs.I18nText, "", _.sourceSpan ?? a.sourceSpan));
                }
                w.replaceWithMany(a, v), p !== void 0 && (p.strings = a.interpolation.strings);
                break;
        }
} }
function Ww(n) { for (let e of n.units)
    for (let t of e.create)
        switch (t.kind) {
            case c.ElementStart:
            case c.Template:
                if (!Array.isArray(t.localRefs))
                    throw new Error("AssertionError: expected localRefs to be an array still");
                if (t.numSlotsUsed += t.localRefs.length, t.localRefs.length > 0) {
                    let s = jw(t.localRefs);
                    t.localRefs = n.addConst(s);
                }
                else
                    t.localRefs = null;
                break;
        } }
function jw(n) { let e = []; for (let t of n)
    e.push(d(t.name), d(t.target)); return B(e); }
function zw(n) { for (let e of n.units) {
    let t = Ce.HTML;
    for (let s of e.create)
        s.kind === c.ElementStart && s.namespace !== t && (w.insertBefore(pg(s.namespace), s), t = s.namespace);
} }
function Gw(n) { let e = [], t = 0, s = 0, r = 0, i = 0, o = 0, a = null; for (; t < n.length;)
    switch (n.charCodeAt(t++)) {
        case 40:
            s++;
            break;
        case 41:
            s--;
            break;
        case 39:
            r === 0 ? r = 39 : r === 39 && n.charCodeAt(t - 1) !== 92 && (r = 0);
            break;
        case 34:
            r === 0 ? r = 34 : r === 34 && n.charCodeAt(t - 1) !== 92 && (r = 0);
            break;
        case 58:
            !a && s === 0 && r === 0 && (a = Xh(n.substring(o, t - 1).trim()), i = t);
            break;
        case 59:
            if (a && i > 0 && s === 0 && r === 0) {
                let u = n.substring(i, t - 1).trim();
                e.push(a, u), o = t, i = 0, a = null;
            }
            break;
    } if (a && i) {
    let l = n.slice(i).trim();
    e.push(a, l);
} return e; }
function Xh(n) { return n.replace(/[a-z][A-Z]/g, e => e.charAt(0) + "-" + e.charAt(1)).toLowerCase(); }
function Xw(n) { let e = new Map; for (let t of n.units)
    for (let s of t.create)
        wn(s) && e.set(s.xref, s); for (let t of n.units)
    for (let s of t.create)
        if (s.kind === c.ExtractedAttribute && s.bindingKind === I.Attribute && kh(s.expression)) {
            let r = e.get(s.target);
            if (r !== void 0 && r.kind === c.Template && r.templateKind === je.Structural)
                continue;
            if (s.name === "style") {
                let i = Gw(s.expression.value);
                for (let o = 0; o < i.length - 1; o += 2)
                    w.insertBefore(nt(s.target, I.StyleProperty, null, i[o], d(i[o + 1]), null, null, ee.STYLE), s);
                w.remove(s);
            }
            else if (s.name === "class") {
                let i = s.expression.value.trim().split(/\s+/g);
                for (let o of i)
                    w.insertBefore(nt(s.target, I.ClassName, null, o, null, null, null, ee.NONE), s);
                w.remove(s);
            }
        } }
function Yw(n) { sr(n.root, n.componentName, { index: 0 }, n.compatibility === Xe.TemplateDefinitionBuilder); }
function sr(n, e, t, s) { n.fnName === null && (n.fnName = n.job.pool.uniqueName(ar(`${e}_${n.job.fnSuffix}`), !1)); let r = new Map; for (let i of n.ops())
    switch (i.kind) {
        case c.Property:
        case c.HostProperty:
            i.isAnimationTrigger && (i.name = "@" + i.name);
            break;
        case c.Listener:
            if (i.handlerFnName !== null)
                break;
            if (!i.hostListener && i.targetSlot.slot === null)
                throw new Error("Expected a slot to be assigned");
            let o = "";
            i.isAnimationListener && (i.name = `@${i.name}.${i.animationPhase}`, o = "animation"), i.hostListener ? i.handlerFnName = `${e}_${o}${i.name}_HostBindingHandler` : i.handlerFnName = `${n.fnName}_${i.tag.replace("-", "_")}_${o}${i.name}_${i.targetSlot.slot}_listener`, i.handlerFnName = ar(i.handlerFnName);
            break;
        case c.TwoWayListener:
            if (i.handlerFnName !== null)
                break;
            if (i.targetSlot.slot === null)
                throw new Error("Expected a slot to be assigned");
            i.handlerFnName = ar(`${n.fnName}_${i.tag.replace("-", "_")}_${i.name}_${i.targetSlot.slot}_listener`);
            break;
        case c.Variable:
            r.set(i.xref, Qw(n, i.variable, t));
            break;
        case c.RepeaterCreate:
            if (!(n instanceof bt))
                throw new Error("AssertionError: must be compiling a component");
            if (i.handle.slot === null)
                throw new Error("Expected slot to be assigned");
            if (i.emptyView !== null) {
                let u = n.job.views.get(i.emptyView);
                sr(u, `${e}_${i.functionNameSuffix}Empty_${i.handle.slot + 2}`, t, s);
            }
            sr(n.job.views.get(i.xref), `${e}_${i.functionNameSuffix}_${i.handle.slot + 1}`, t, s);
            break;
        case c.Projection:
            if (!(n instanceof bt))
                throw new Error("AssertionError: must be compiling a component");
            if (i.handle.slot === null)
                throw new Error("Expected slot to be assigned");
            if (i.fallbackView !== null) {
                let u = n.job.views.get(i.fallbackView);
                sr(u, `${e}_ProjectionFallback_${i.handle.slot}`, t, s);
            }
            break;
        case c.Template:
            if (!(n instanceof bt))
                throw new Error("AssertionError: must be compiling a component");
            let a = n.job.views.get(i.xref);
            if (i.handle.slot === null)
                throw new Error("Expected slot to be assigned");
            let l = i.functionNameSuffix.length === 0 ? "" : `_${i.functionNameSuffix}`;
            sr(a, `${e}${l}_${i.handle.slot}`, t, s);
            break;
        case c.StyleProp:
            i.name = Zw(i.name), s && (i.name = Vc(i.name));
            break;
        case c.ClassProp:
            s && (i.name = Vc(i.name));
            break;
    } for (let i of n.ops())
    _e(i, o => { if (!(!(o instanceof Wt) || o.name !== null)) {
        if (!r.has(o.xref))
            throw new Error(`Variable ${o.xref} not yet named`);
        o.name = r.get(o.xref);
    } }); }
function Qw(n, e, t) { if (e.name === null)
    switch (e.kind) {
        case we.Context:
            e.name = `ctx_r${t.index++}`;
            break;
        case we.Identifier:
            if (n.job.compatibility === Xe.TemplateDefinitionBuilder) {
                let s = e.identifier === "ctx" ? "i" : "";
                e.name = `${e.identifier}_${s}r${++t.index}`;
            }
            else
                e.name = `${e.identifier}_i${t.index++}`;
            break;
        default:
            e.name = `_r${++t.index}`;
            break;
    } return e.name; }
function Zw(n) { return n.startsWith("--") ? n : Xh(n); }
function Vc(n) { let e = n.indexOf("!important"); return e > -1 ? n.substring(0, e) : n; }
function Jw(n) { for (let e of n.units) {
    for (let t of e.create)
        (t.kind === c.Listener || t.kind === c.TwoWayListener) && qc(t.handlerOps);
    qc(e.update);
} }
function qc(n) { for (let e of n) {
    if (e.kind !== c.Statement || !(e.statement instanceof Ge) || !(e.statement.expr instanceof oo))
        continue;
    let t = e.statement.expr.steps, s = !0;
    for (let r = e.next; r.kind !== c.ListEnd && s; r = r.next)
        _e(r, (i, o) => { if (!Bt(i))
            return i; if (s && !(o & z.InChildOperation))
            switch (i.kind) {
                case k.NextContext:
                    i.steps += t, w.remove(e), s = !1;
                    break;
                case k.GetCurrentView:
                case k.Reference:
                case k.ContextLetReference:
                    s = !1;
                    break;
            } });
} }
var Kw = "ng-container";
function eE(n) { for (let e of n.units) {
    let t = new Set;
    for (let s of e.create)
        s.kind === c.ElementStart && s.tag === Kw && (s.kind = c.ContainerStart, t.add(s.xref)), s.kind === c.ElementEnd && t.has(s.xref) && (s.kind = c.ContainerEnd);
} }
function tE(n, e) { let t = n.get(e); if (t === void 0)
    throw new Error("All attributes should have an element-like target."); return t; }
function nE(n) { let e = new Map; for (let t of n.units)
    for (let s of t.create)
        wn(s) && e.set(s.xref, s); for (let t of n.units)
    for (let s of t.create)
        (s.kind === c.ElementStart || s.kind === c.ContainerStart) && s.nonBindable && w.insertAfter(ug(s.xref), s), (s.kind === c.ElementEnd || s.kind === c.ContainerEnd) && tE(e, s.xref).nonBindable && w.insertBefore(cg(s.xref), s); }
function sE(n) { for (let e of n.units)
    for (let t of e.ops())
        ce(t, s => { if (!(s instanceof W) || s.operator !== b.NullishCoalesce)
            return s; let r = new Et(s.lhs.clone(), n.allocateXrefId()), i = new Xt(r.xref); return new kt(new W(b.And, new W(b.NotIdentical, r, Wn), new W(b.NotIdentical, i, new ge(void 0))), i.clone(), s.rhs); }, z.None); }
function Ot(n) { return e => e.kind === n; }
function pr(n, e) { return t => t.kind === n && e === t.expression instanceof le; }
function rE(n) { return n.kind === c.Listener && !(n.hostListener && n.isAnimationListener) || n.kind === c.TwoWayListener; }
function iE(n) { return (n.kind === c.Property || n.kind === c.TwoWayProperty) && !(n.expression instanceof le); }
var oE = [{ test: n => n.kind === c.Listener && n.hostListener && n.isAnimationListener }, { test: rE }], aE = [{ test: Ot(c.StyleMap), transform: Co }, { test: Ot(c.ClassMap), transform: Co }, { test: Ot(c.StyleProp) }, { test: Ot(c.ClassProp) }, { test: pr(c.Attribute, !0) }, { test: pr(c.Property, !0) }, { test: iE }, { test: pr(c.Attribute, !1) }], lE = [{ test: pr(c.HostProperty, !0) }, { test: pr(c.HostProperty, !1) }, { test: Ot(c.Attribute) }, { test: Ot(c.StyleMap), transform: Co }, { test: Ot(c.ClassMap), transform: Co }, { test: Ot(c.StyleProp) }, { test: Ot(c.ClassProp) }], Hc = new Set([c.Listener, c.TwoWayListener, c.StyleMap, c.ClassMap, c.StyleProp, c.ClassProp, c.Property, c.TwoWayProperty, c.HostProperty, c.Attribute]);
function uE(n) { for (let e of n.units) {
    Uc(e.create, oE);
    let t = e.job.kind === C.Host ? lE : aE;
    Uc(e.update, t);
} }
function Uc(n, e) { let t = [], s = null; for (let r of n) {
    let i = ro(r) ? r.target : null;
    (!Hc.has(r.kind) || i !== s && s !== null && i !== null) && (w.insertBefore(Wc(t, e), r), t = [], s = null), Hc.has(r.kind) && (t.push(r), w.remove(r), s = i ?? s);
} n.push(Wc(t, e)); }
function Wc(n, e) { let t = Array.from(e, () => new Array); for (let s of n) {
    let r = e.findIndex(i => i.test(s));
    t[r].push(s);
} return t.flatMap((s, r) => { let i = e[r].transform; return i ? i(s) : s; }); }
function Co(n) { return n.slice(n.length - 1); }
function cE(n) { for (let e of n.units) {
    let t = Pu(e);
    for (let s of e.ops())
        switch (s.kind) {
            case c.Binding:
                let r = hE(t, s.target);
                pE(s.name) && r.kind === c.Projection && w.remove(s);
                break;
        }
} }
function pE(n) { return n.toLowerCase() === "select"; }
function hE(n, e) { let t = n.get(e); if (t === void 0)
    throw new Error("All attributes should have an slottable target."); return t; }
function fE(n) { for (let e of n.units)
    dE(e); }
function dE(n) { for (let e of n.update)
    _e(e, (t, s) => { if (Bt(t) && t.kind === k.PipeBinding) {
        if (s & z.InChildOperation)
            throw new Error("AssertionError: pipe bindings should not appear in child expressions");
        if (n.job.compatibility) {
            if (e.target == null)
                throw new Error("AssertionError: expected slot handle to be assigned for pipe creation");
            mE(n, e.target, t);
        }
        else
            n.create.push(Dh(t.target, t.targetSlot, t.name));
    } }); }
function mE(n, e, t) { for (let s = n.create.head.next; s.kind !== c.ListEnd; s = s.next) {
    if (!Ws(s) || s.xref !== e)
        continue;
    for (; s.next.kind === c.Pipe;)
        s = s.next;
    let r = Dh(t.target, t.targetSlot, t.name);
    w.insertBefore(r, s.next);
    return;
} throw new Error(`AssertionError: unable to find insertion point for pipe ${t.name}`); }
function gE(n) { for (let e of n.units)
    for (let t of e.update)
        ce(t, s => !(s instanceof Ds) || s.args.length <= 4 ? s : new uo(s.target, s.targetSlot, s.name, B(s.args), s.args.length), z.None); }
function vE(n) { Yh(n.root, 0); }
function Yh(n, e) { let t = null; for (let s of n.create)
    switch (s.kind) {
        case c.I18nStart:
            s.subTemplateIndex = e === 0 ? null : e, t = s;
            break;
        case c.I18nEnd:
            t.subTemplateIndex === null && (e = 0), t = null;
            break;
        case c.Template:
            e = aa(n.job.views.get(s.xref), t, s.i18nPlaceholder, e);
            break;
        case c.RepeaterCreate:
            let r = n.job.views.get(s.xref);
            e = aa(r, t, s.i18nPlaceholder, e), s.emptyView !== null && (e = aa(n.job.views.get(s.emptyView), t, s.emptyI18nPlaceholder, e));
            break;
    } return e; }
function aa(n, e, t, s) { if (t !== void 0) {
    if (e === null)
        throw Error("Expected template with i18n placeholder to be in an i18n block.");
    s++, wE(n, e);
} return Yh(n, s); }
function wE(n, e) { if (n.create.head.next?.kind !== c.I18nStart) {
    let t = n.job.allocateXrefId();
    w.insertAfter(Xo(t, e.message, e.root, null), n.create.head), w.insertBefore(Yo(t, null), n.create.tail);
} }
function EE(n) { for (let e of n.units)
    for (let t of e.ops())
        _e(t, s => { if (!(s instanceof Jn) || s.body === null)
            return; let r = new Dl(s.args.length); s.fn = n.pool.getSharedConstant(r, s.body), s.body = null; }); }
var Dl = class extends ds {
    numArgs;
    constructor(e) { super(), this.numArgs = e; }
    keyOf(e) { return e instanceof Ns ? `param(${e.index})` : super.keyOf(e); }
    toSharedConstantDeclaration(e, t) { let s = []; for (let i = 0; i < this.numArgs; i++)
        s.push(new Y("a" + i)); let r = A(t, i => i instanceof Ns ? N("a" + i.index) : i, z.None); return new ve(e, new pn(s, r), void 0, oe.Final); }
};
function SE(n) { for (let e of n.units)
    for (let t of e.update)
        ce(t, (s, r) => r & z.InChildOperation ? s : s instanceof at ? xE(s) : s instanceof gt ? yE(s) : s, z.None); }
function xE(n) { let e = [], t = []; for (let s of n.entries)
    if (s.isConstant())
        e.push(s);
    else {
        let r = t.length;
        t.push(s), e.push(new Ns(r));
    } return new Jn(B(e), t); }
function yE(n) { let e = [], t = []; for (let s of n.entries)
    if (s.value.isConstant())
        e.push(s);
    else {
        let r = t.length;
        t.push(s.value), e.push(new Un(s.key, new Ns(r), s.quoted));
    } return new Jn(ue(e), t); }
function CE(n, e, t, s, r) { return Qo(h.element, n, e, t, s, r); }
function AE(n, e, t, s, r) { return Qo(h.elementStart, n, e, t, s, r); }
function Qo(n, e, t, s, r, i) { let o = [d(e)]; return t !== null && o.push(d(t)), r !== null ? o.push(d(s), d(r)) : s !== null && o.push(d(s)), H(n, o, i); }
function _E(n) { return H(h.elementEnd, [], n); }
function TE(n, e, t, s) { return Qo(h.elementContainerStart, n, null, e, t, s); }
function bE(n, e, t, s) { return Qo(h.elementContainer, n, null, e, t, s); }
function kE() { return H(h.elementContainerEnd, [], null); }
function IE(n, e, t, s, r, i, o, a) { let l = [d(n), e, d(t), d(s), d(r), d(i)]; for (o !== null && (l.push(d(o)), l.push(y(h.templateRefExtractor))); l[l.length - 1].isEquivalent(Wn);)
    l.pop(); return H(h.templateCreate, l, a); }
function NE() { return H(h.disableBindings, [], null); }
function DE() { return H(h.enableBindings, [], null); }
function PE(n, e, t, s, r) { let i = [d(n), e]; return t !== null && (i.push(d(!1)), i.push(y(t))), H(s ? h.syntheticHostListener : h.listener, i, r); }
function jc(n, e) { return y(h.twoWayBindingSet).callFn([n, e]); }
function LE(n, e, t) { return H(h.twoWayListener, [d(n), e], t); }
function BE(n, e) { return H(h.pipe, [d(n), d(e)], null); }
function ME() { return H(h.namespaceHTML, [], null); }
function RE() { return H(h.namespaceSVG, [], null); }
function FE() { return H(h.namespaceMathML, [], null); }
function $E(n, e) { return H(h.advance, n > 1 ? [d(n)] : [], e); }
function OE(n) { return y(h.reference).callFn([d(n)]); }
function VE(n) { return y(h.nextContext).callFn(n === 1 ? [] : [d(n)]); }
function qE() { return y(h.getCurrentView).callFn([]); }
function HE(n) { return y(h.restoreView).callFn([n]); }
function UE(n) { return y(h.resetView).callFn([n]); }
function WE(n, e, t) { let s = [d(n, null)]; return e !== "" && s.push(d(e)), H(h.text, s, t); }
function jE(n, e, t, s, r, i, o, a, l, u, p) { let f = [d(n), d(e), t ?? d(null), d(s), d(r), d(i), o ?? d(null), a ?? d(null), l ? y(h.deferEnableTimerScheduling) : d(null), d(p)], g; for (; (g = f[f.length - 1]) !== null && g instanceof ge && g.value === null;)
    f.pop(); return H(h.defer, f, u); }
var zE = new Map([[X.Idle, { none: h.deferOnIdle, prefetch: h.deferPrefetchOnIdle, hydrate: h.deferHydrateOnIdle }], [X.Immediate, { none: h.deferOnImmediate, prefetch: h.deferPrefetchOnImmediate, hydrate: h.deferHydrateOnImmediate }], [X.Timer, { none: h.deferOnTimer, prefetch: h.deferPrefetchOnTimer, hydrate: h.deferHydrateOnTimer }], [X.Hover, { none: h.deferOnHover, prefetch: h.deferPrefetchOnHover, hydrate: h.deferHydrateOnHover }], [X.Interaction, { none: h.deferOnInteraction, prefetch: h.deferPrefetchOnInteraction, hydrate: h.deferHydrateOnInteraction }], [X.Viewport, { none: h.deferOnViewport, prefetch: h.deferPrefetchOnViewport, hydrate: h.deferHydrateOnViewport }], [X.Never, { none: h.deferHydrateNever, prefetch: h.deferHydrateNever, hydrate: h.deferHydrateNever }]]);
function GE(n, e, t, s) { let r = zE.get(n)?.[t]; if (r === void 0)
    throw new Error(`Unable to determine instruction for trigger ${n}`); return H(r, e.map(i => d(i)), s); }
function XE(n) { return H(h.projectionDef, n ? [n] : [], null); }
function YE(n, e, t, s, r, i, o) { let a = [d(n)]; return (e !== 0 || t !== null || s !== null) && (a.push(d(e)), t !== null && a.push(t), s !== null && (t === null && a.push(d(null)), a.push(N(s), d(r), d(i)))), H(h.projection, a, o); }
function QE(n, e, t, s) { let r = [d(n), d(e)]; return t !== null && r.push(d(t)), H(h.i18nStart, r, s); }
function ZE(n, e, t, s, r, i, o, a, l, u, p, f, g, v) { let S = [d(n), N(e), d(t), d(s), d(r), d(i), o]; return (a || l !== null) && (S.push(d(a)), l !== null && (S.push(N(l), d(u), d(p)), (f !== null || g !== null) && S.push(d(f)), g !== null && S.push(d(g)))), H(h.repeaterCreate, S, v); }
function JE(n, e) { return H(h.repeater, [n], e); }
function KE(n, e, t) { return n === "prefetch" ? H(h.deferPrefetchWhen, [e], t) : n === "hydrate" ? H(h.deferHydrateWhen, [e], t) : H(h.deferWhen, [e], t); }
function e2(n, e) { return H(h.declareLet, [d(n)], e); }
function t2(n, e) { return y(h.storeLet).callFn([n], e); }
function n2(n) { return y(h.readContextLet).callFn([d(n)]); }
function s2(n, e, t, s) { let r = [d(n), d(e)]; return t && r.push(d(t)), H(h.i18n, r, s); }
function r2(n) { return H(h.i18nEnd, [], n); }
function i2(n, e) { let t = [d(n), d(e)]; return H(h.i18nAttributes, t, null); }
function o2(n, e, t, s) { let r = [d(n), e]; return t !== null && r.push(t), H(h.property, r, s); }
function a2(n, e, t, s) { let r = [d(n), e]; return t !== null && r.push(t), H(h.twoWayProperty, r, s); }
function l2(n, e, t, s) { let r = [d(n), e]; return (t !== null || s !== null) && r.push(t ?? d(null)), s !== null && r.push(d(s)), H(h.attribute, r, null); }
function u2(n, e, t, s) { let r = [d(n), e]; return t !== null && r.push(d(t)), H(h.styleProp, r, s); }
function c2(n, e, t) { return H(h.classProp, [d(n), e], t); }
function p2(n, e) { return H(h.styleMap, [n], e); }
function h2(n, e) { return H(h.classMap, [n], e); }
var zc = [h.pipeBind1, h.pipeBind2, h.pipeBind3, h.pipeBind4];
function f2(n, e, t) { if (t.length < 1 || t.length > zc.length)
    throw new Error("pipeBind() argument count out of bounds"); let s = zc[t.length - 1]; return y(s).callFn([d(n), d(e), ...t]); }
function d2(n, e, t) { return y(h.pipeBindV).callFn([d(n), d(e), t]); }
function m2(n, e, t) { let s = js(n, e); return zs(k2, [], s, [], t); }
function g2(n, e) { return H(h.i18nExp, [n], e); }
function v2(n, e) { return H(h.i18nApply, [d(n)], e); }
function w2(n, e, t, s, r) { let i = js(e, t), o = []; return s !== null && o.push(s), zs(I2, [d(n)], i, o, r); }
function E2(n, e, t, s, r) { let i = js(e, t), o = []; return s !== null && o.push(s), zs(D2, [d(n)], i, o, r); }
function S2(n, e, t, s, r) { let i = js(e, t), o = []; return s !== null && o.push(d(s)), zs(N2, [d(n)], i, o, r); }
function x2(n, e, t) { let s = js(n, e); return zs(P2, [], s, [], t); }
function y2(n, e, t) { let s = js(n, e); return zs(L2, [], s, [], t); }
function C2(n, e, t, s) { let r = [d(n), e]; return t !== null && r.push(t), H(h.hostProperty, r, s); }
function A2(n, e, t) { return H(h.syntheticHostProperty, [d(n), e], t); }
function _2(n, e, t) { return Qh(B2, [d(n), e], t, [], null); }
function T2(n, e) { return H(h.attachSourceLocations, [d(n), e], null); }
function js(n, e) { if (n.length < 1 || e.length !== n.length - 1)
    throw new Error("AssertionError: expected specific shape of args for strings/expressions in interpolation"); let t = []; if (e.length === 1 && n[0] === "" && n[1] === "")
    t.push(e[0]);
else {
    let s;
    for (s = 0; s < e.length; s++)
        t.push(d(n[s]), e[s]);
    t.push(d(n[s]));
} return t; }
function H(n, e, t) { let s = y(n).callFn(e, t); return wt(new Ge(s, t)); }
function b2(n, e, t) { let s = [n]; return e !== null && s.push(e), H(h.conditional, s, t); }
var k2 = { constant: [h.textInterpolate, h.textInterpolate1, h.textInterpolate2, h.textInterpolate3, h.textInterpolate4, h.textInterpolate5, h.textInterpolate6, h.textInterpolate7, h.textInterpolate8], variable: h.textInterpolateV, mapping: n => { if (n % 2 === 0)
        throw new Error("Expected odd number of arguments"); return (n - 1) / 2; } }, I2 = { constant: [h.propertyInterpolate, h.propertyInterpolate1, h.propertyInterpolate2, h.propertyInterpolate3, h.propertyInterpolate4, h.propertyInterpolate5, h.propertyInterpolate6, h.propertyInterpolate7, h.propertyInterpolate8], variable: h.propertyInterpolateV, mapping: n => { if (n % 2 === 0)
        throw new Error("Expected odd number of arguments"); return (n - 1) / 2; } }, N2 = { constant: [h.styleProp, h.stylePropInterpolate1, h.stylePropInterpolate2, h.stylePropInterpolate3, h.stylePropInterpolate4, h.stylePropInterpolate5, h.stylePropInterpolate6, h.stylePropInterpolate7, h.stylePropInterpolate8], variable: h.stylePropInterpolateV, mapping: n => { if (n % 2 === 0)
        throw new Error("Expected odd number of arguments"); return (n - 1) / 2; } }, D2 = { constant: [h.attribute, h.attributeInterpolate1, h.attributeInterpolate2, h.attributeInterpolate3, h.attributeInterpolate4, h.attributeInterpolate5, h.attributeInterpolate6, h.attributeInterpolate7, h.attributeInterpolate8], variable: h.attributeInterpolateV, mapping: n => { if (n % 2 === 0)
        throw new Error("Expected odd number of arguments"); return (n - 1) / 2; } }, P2 = { constant: [h.styleMap, h.styleMapInterpolate1, h.styleMapInterpolate2, h.styleMapInterpolate3, h.styleMapInterpolate4, h.styleMapInterpolate5, h.styleMapInterpolate6, h.styleMapInterpolate7, h.styleMapInterpolate8], variable: h.styleMapInterpolateV, mapping: n => { if (n % 2 === 0)
        throw new Error("Expected odd number of arguments"); return (n - 1) / 2; } }, L2 = { constant: [h.classMap, h.classMapInterpolate1, h.classMapInterpolate2, h.classMapInterpolate3, h.classMapInterpolate4, h.classMapInterpolate5, h.classMapInterpolate6, h.classMapInterpolate7, h.classMapInterpolate8], variable: h.classMapInterpolateV, mapping: n => { if (n % 2 === 0)
        throw new Error("Expected odd number of arguments"); return (n - 1) / 2; } }, B2 = { constant: [h.pureFunction0, h.pureFunction1, h.pureFunction2, h.pureFunction3, h.pureFunction4, h.pureFunction5, h.pureFunction6, h.pureFunction7, h.pureFunction8], variable: h.pureFunctionV, mapping: n => n };
function Qh(n, e, t, s, r) { let i = n.mapping(t.length); if (i < n.constant.length)
    return y(n.constant[i]).callFn([...e, ...t, ...s], r); if (n.variable !== null)
    return y(n.variable).callFn([...e, B(t), ...s], r); throw new Error("AssertionError: unable to call variadic function"); }
function zs(n, e, t, s, r) { return wt(Qh(n, e, t, s, r).toStmt()); }
var M2 = new Map([["window", h.resolveWindow], ["document", h.resolveDocument], ["body", h.resolveBody]]);
function R2(n) { for (let e of n.units)
    F2(e, e.create), Lu(e, e.update); }
function F2(n, e) { for (let t of e)
    switch (ce(t, Zh, z.None), t.kind) {
        case c.Text:
            w.replace(t, WE(t.handle.slot, t.initialValue, t.sourceSpan));
            break;
        case c.ElementStart:
            w.replace(t, AE(t.handle.slot, t.tag, t.attributes, t.localRefs, t.startSourceSpan));
            break;
        case c.Element:
            w.replace(t, CE(t.handle.slot, t.tag, t.attributes, t.localRefs, t.wholeSourceSpan));
            break;
        case c.ElementEnd:
            w.replace(t, _E(t.sourceSpan));
            break;
        case c.ContainerStart:
            w.replace(t, TE(t.handle.slot, t.attributes, t.localRefs, t.startSourceSpan));
            break;
        case c.Container:
            w.replace(t, bE(t.handle.slot, t.attributes, t.localRefs, t.wholeSourceSpan));
            break;
        case c.ContainerEnd:
            w.replace(t, kE());
            break;
        case c.I18nStart:
            w.replace(t, QE(t.handle.slot, t.messageIndex, t.subTemplateIndex, t.sourceSpan));
            break;
        case c.I18nEnd:
            w.replace(t, r2(t.sourceSpan));
            break;
        case c.I18n:
            w.replace(t, s2(t.handle.slot, t.messageIndex, t.subTemplateIndex, t.sourceSpan));
            break;
        case c.I18nAttributes:
            if (t.i18nAttributesConfig === null)
                throw new Error("AssertionError: i18nAttributesConfig was not set");
            w.replace(t, i2(t.handle.slot, t.i18nAttributesConfig));
            break;
        case c.Template:
            if (!(n instanceof bt))
                throw new Error("AssertionError: must be compiling a component");
            if (Array.isArray(t.localRefs))
                throw new Error("AssertionError: local refs array should have been extracted into a constant");
            let s = n.job.views.get(t.xref);
            w.replace(t, IE(t.handle.slot, N(s.fnName), s.decls, s.vars, t.tag, t.attributes, t.localRefs, t.startSourceSpan));
            break;
        case c.DisableBindings:
            w.replace(t, NE());
            break;
        case c.EnableBindings:
            w.replace(t, DE());
            break;
        case c.Pipe:
            w.replace(t, BE(t.handle.slot, t.name));
            break;
        case c.DeclareLet:
            w.replace(t, e2(t.handle.slot, t.sourceSpan));
            break;
        case c.Listener:
            let r = Gc(n, t.handlerFnName, t.handlerOps, t.consumesDollarEvent), i = t.eventTarget ? M2.get(t.eventTarget) : null;
            if (i === void 0)
                throw new Error(`Unexpected global target '${t.eventTarget}' defined for '${t.name}' event. Supported list of global targets: window,document,body.`);
            w.replace(t, PE(t.name, r, i, t.hostListener && t.isAnimationListener, t.sourceSpan));
            break;
        case c.TwoWayListener:
            w.replace(t, LE(t.name, Gc(n, t.handlerFnName, t.handlerOps, !0), t.sourceSpan));
            break;
        case c.Variable:
            if (t.variable.name === null)
                throw new Error(`AssertionError: unnamed variable ${t.xref}`);
            w.replace(t, wt(new ve(t.variable.name, t.initializer, void 0, oe.Final)));
            break;
        case c.Namespace:
            switch (t.active) {
                case Ce.HTML:
                    w.replace(t, ME());
                    break;
                case Ce.SVG:
                    w.replace(t, RE());
                    break;
                case Ce.Math:
                    w.replace(t, FE());
                    break;
            }
            break;
        case c.Defer:
            let o = !!t.loadingMinimumTime || !!t.loadingAfterTime || !!t.placeholderMinimumTime;
            w.replace(t, jE(t.handle.slot, t.mainSlot.slot, t.resolverFn, t.loadingSlot?.slot ?? null, t.placeholderSlot?.slot ?? null, t.errorSlot?.slot ?? null, t.loadingConfig, t.placeholderConfig, o, t.sourceSpan, t.flags));
            break;
        case c.DeferOn:
            let a = [];
            switch (t.trigger.kind) {
                case X.Never:
                case X.Idle:
                case X.Immediate: break;
                case X.Timer:
                    a = [t.trigger.delay];
                    break;
                case X.Interaction:
                case X.Hover:
                case X.Viewport:
                    if (t.modifier === "hydrate")
                        a = [];
                    else {
                        if (t.trigger.targetSlot?.slot == null || t.trigger.targetSlotViewSteps === null)
                            throw new Error(`Slot or view steps not set in trigger reification for trigger kind ${t.trigger.kind}`);
                        a = [t.trigger.targetSlot.slot], t.trigger.targetSlotViewSteps !== 0 && a.push(t.trigger.targetSlotViewSteps);
                    }
                    break;
                default: throw new Error(`AssertionError: Unsupported reification of defer trigger kind ${t.trigger.kind}`);
            }
            w.replace(t, GE(t.trigger.kind, a, t.modifier, t.sourceSpan));
            break;
        case c.ProjectionDef:
            w.replace(t, XE(t.def));
            break;
        case c.Projection:
            if (t.handle.slot === null)
                throw new Error("No slot was assigned for project instruction");
            let l = null, u = null, p = null;
            if (t.fallbackView !== null) {
                if (!(n instanceof bt))
                    throw new Error("AssertionError: must be compiling a component");
                let x = n.job.views.get(t.fallbackView);
                if (x === void 0)
                    throw new Error("AssertionError: projection had fallback view xref, but fallback view was not found");
                if (x.fnName === null || x.decls === null || x.vars === null)
                    throw new Error("AssertionError: expected projection fallback view to have been named and counted");
                l = x.fnName, u = x.decls, p = x.vars;
            }
            w.replace(t, YE(t.handle.slot, t.projectionSlotIndex, t.attributes, l, u, p, t.sourceSpan));
            break;
        case c.RepeaterCreate:
            if (t.handle.slot === null)
                throw new Error("No slot was assigned for repeater instruction");
            if (!(n instanceof bt))
                throw new Error("AssertionError: must be compiling a component");
            let f = n.job.views.get(t.xref);
            if (f.fnName === null)
                throw new Error("AssertionError: expected repeater primary view to have been named");
            let g = null, v = null, S = null;
            if (t.emptyView !== null) {
                let x = n.job.views.get(t.emptyView);
                if (x === void 0)
                    throw new Error("AssertionError: repeater had empty view xref, but empty view was not found");
                if (x.fnName === null || x.decls === null || x.vars === null)
                    throw new Error("AssertionError: expected repeater empty view to have been named and counted");
                g = x.fnName, v = x.decls, S = x.vars;
            }
            w.replace(t, ZE(t.handle.slot, f.fnName, t.decls, t.vars, t.tag, t.attributes, $2(n, t), t.usesComponentInstance, g, v, S, t.emptyTag, t.emptyAttributes, t.wholeSourceSpan));
            break;
        case c.SourceLocation:
            let _ = B(t.locations.map(({ targetSlot: x, offset: T, line: M, column: Z }) => { if (x.slot === null)
                throw new Error("No slot was assigned for source location"); return B([d(x.slot), d(T), d(M), d(Z)]); }));
            w.replace(t, T2(t.templatePath, _));
            break;
        case c.Statement: break;
        default: throw new Error(`AssertionError: Unsupported reification of create op ${c[t.kind]}`);
    } }
function Lu(n, e) { for (let t of e)
    switch (ce(t, Zh, z.None), t.kind) {
        case c.Advance:
            w.replace(t, $E(t.delta, t.sourceSpan));
            break;
        case c.Property:
            t.expression instanceof le ? w.replace(t, w2(t.name, t.expression.strings, t.expression.expressions, t.sanitizer, t.sourceSpan)) : w.replace(t, o2(t.name, t.expression, t.sanitizer, t.sourceSpan));
            break;
        case c.TwoWayProperty:
            w.replace(t, a2(t.name, t.expression, t.sanitizer, t.sourceSpan));
            break;
        case c.StyleProp:
            t.expression instanceof le ? w.replace(t, S2(t.name, t.expression.strings, t.expression.expressions, t.unit, t.sourceSpan)) : w.replace(t, u2(t.name, t.expression, t.unit, t.sourceSpan));
            break;
        case c.ClassProp:
            w.replace(t, c2(t.name, t.expression, t.sourceSpan));
            break;
        case c.StyleMap:
            t.expression instanceof le ? w.replace(t, x2(t.expression.strings, t.expression.expressions, t.sourceSpan)) : w.replace(t, p2(t.expression, t.sourceSpan));
            break;
        case c.ClassMap:
            t.expression instanceof le ? w.replace(t, y2(t.expression.strings, t.expression.expressions, t.sourceSpan)) : w.replace(t, h2(t.expression, t.sourceSpan));
            break;
        case c.I18nExpression:
            w.replace(t, g2(t.expression, t.sourceSpan));
            break;
        case c.I18nApply:
            w.replace(t, v2(t.handle.slot, t.sourceSpan));
            break;
        case c.InterpolateText:
            w.replace(t, m2(t.interpolation.strings, t.interpolation.expressions, t.sourceSpan));
            break;
        case c.Attribute:
            t.expression instanceof le ? w.replace(t, E2(t.name, t.expression.strings, t.expression.expressions, t.sanitizer, t.sourceSpan)) : w.replace(t, l2(t.name, t.expression, t.sanitizer, t.namespace));
            break;
        case c.HostProperty:
            if (t.expression instanceof le)
                throw new Error("not yet handled");
            t.isAnimationTrigger ? w.replace(t, A2(t.name, t.expression, t.sourceSpan)) : w.replace(t, C2(t.name, t.expression, t.sanitizer, t.sourceSpan));
            break;
        case c.Variable:
            if (t.variable.name === null)
                throw new Error(`AssertionError: unnamed variable ${t.xref}`);
            w.replace(t, wt(new ve(t.variable.name, t.initializer, void 0, oe.Final)));
            break;
        case c.Conditional:
            if (t.processed === null)
                throw new Error("Conditional test was not set.");
            w.replace(t, b2(t.processed, t.contextValue, t.sourceSpan));
            break;
        case c.Repeater:
            w.replace(t, JE(t.collection, t.sourceSpan));
            break;
        case c.DeferWhen:
            w.replace(t, KE(t.modifier, t.expr, t.sourceSpan));
            break;
        case c.StoreLet: throw new Error(`AssertionError: unexpected storeLet ${t.declaredName}`);
        case c.Statement: break;
        default: throw new Error(`AssertionError: Unsupported reification of update op ${c[t.kind]}`);
    } }
function Zh(n) { if (!Bt(n))
    return n; switch (n.kind) {
    case k.NextContext: return VE(n.steps);
    case k.Reference: return OE(n.targetSlot.slot + 1 + n.offset);
    case k.LexicalRead: throw new Error(`AssertionError: unresolved LexicalRead of ${n.name}`);
    case k.TwoWayBindingSet: throw new Error("AssertionError: unresolved TwoWayBindingSet");
    case k.RestoreView:
        if (typeof n.view == "number")
            throw new Error("AssertionError: unresolved RestoreView");
        return HE(n.view);
    case k.ResetView: return UE(n.expr);
    case k.GetCurrentView: return qE();
    case k.ReadVariable:
        if (n.name === null)
            throw new Error(`Read of unnamed variable ${n.xref}`);
        return N(n.name);
    case k.ReadTemporaryExpr:
        if (n.name === null)
            throw new Error(`Read of unnamed temporary ${n.xref}`);
        return N(n.name);
    case k.AssignTemporaryExpr:
        if (n.name === null)
            throw new Error(`Assign of unnamed temporary ${n.xref}`);
        return N(n.name).set(n.expr);
    case k.PureFunctionExpr:
        if (n.fn === null)
            throw new Error("AssertionError: expected PureFunctions to have been extracted");
        return _2(n.varOffset, n.fn, n.args);
    case k.PureFunctionParameterExpr: throw new Error("AssertionError: expected PureFunctionParameterExpr to have been extracted");
    case k.PipeBinding: return f2(n.targetSlot.slot, n.varOffset, n.args);
    case k.PipeBindingVariadic: return d2(n.targetSlot.slot, n.varOffset, n.args);
    case k.SlotLiteralExpr: return d(n.slot.slot);
    case k.ContextLetReference: return n2(n.targetSlot.slot);
    case k.StoreLet: return t2(n.value, n.sourceSpan);
    case k.TrackContext: return N("this");
    default: throw new Error(`AssertionError: Unsupported reification of ir.Expression kind: ${k[n.kind]}`);
} }
function Gc(n, e, t, s) { Lu(n, t); let r = []; for (let o of t) {
    if (o.kind !== c.Statement)
        throw new Error(`AssertionError: expected reified statements, but found op ${c[o.kind]}`);
    r.push(o.statement);
} let i = []; return s && i.push(new Y("$event")), zt(i, r, void 0, void 0, e); }
function $2(n, e) { if (e.trackByFn !== null)
    return e.trackByFn; let t = [new Y("$index"), new Y("$item")], s; if (e.trackByOps === null)
    s = e.usesComponentInstance ? zt(t, [new ye(e.track)]) : se(t, e.track);
else {
    Lu(n, e.trackByOps);
    let r = [];
    for (let i of e.trackByOps) {
        if (i.kind !== c.Statement)
            throw new Error(`AssertionError: expected reified statements, but found op ${c[i.kind]}`);
        r.push(i.statement);
    }
    s = e.usesComponentInstance || r.length !== 1 || !(r[0] instanceof ye) ? zt(t, r) : se(t, r[0].value);
} return e.trackByFn = n.job.pool.getSharedFunctionReference(s, "_forTrack"), e.trackByFn; }
function O2(n) { for (let e of n.units)
    for (let t of e.update)
        switch (t.kind) {
            case c.Attribute:
            case c.Binding:
            case c.ClassProp:
            case c.ClassMap:
            case c.Property:
            case c.StyleProp:
            case c.StyleMap:
                t.expression instanceof zr && w.remove(t);
                break;
        } }
function V2(n) { for (let e of n.units)
    for (let t of e.create)
        switch (t.kind) {
            case c.I18nContext:
                w.remove(t);
                break;
            case c.I18nStart:
                t.context = null;
                break;
        } }
function q2(n) { for (let e of n.units) {
    let t = new Set;
    for (let s of e.update)
        switch (s.kind) {
            case c.I18nExpression: t.add(s.i18nOwner);
        }
    for (let s of e.create)
        switch (s.kind) {
            case c.I18nAttributes:
                if (t.has(s.xref))
                    continue;
                w.remove(s);
        }
} }
function H2(n) { for (let e of n.units)
    Ao(e, e.create), Ao(e, e.update); }
function Ao(n, e) { let t = new Map; t.set(n.xref, N("ctx")); for (let s of e)
    switch (s.kind) {
        case c.Variable:
            switch (s.variable.kind) {
                case we.Context:
                    t.set(s.variable.view, new Wt(s.xref));
                    break;
            }
            break;
        case c.Listener:
        case c.TwoWayListener:
            Ao(n, s.handlerOps);
            break;
        case c.RepeaterCreate:
            s.trackByOps !== null && Ao(n, s.trackByOps);
            break;
    } n === n.job.root && t.set(n.xref, N("ctx")); for (let s of e)
    ce(s, r => { if (r instanceof Gt) {
        if (!t.has(r.view))
            throw new Error(`No context found for reference to view ${r.view} from view ${n.xref}`);
        return t.get(r.view);
    }
    else
        return r; }, z.None); }
function U2(n) { for (let e of n.units)
    Xc(e.create), Xc(e.update); }
function Xc(n) { for (let e of n)
    (e.kind === c.Listener || e.kind === c.TwoWayListener) && ce(e, t => t instanceof xe && t.name === "$event" ? (e.kind === c.Listener && (e.consumesDollarEvent = !0), new ze(t.name)) : t, z.InChildOperation); }
function W2(n) { let e = new Map, t = new Map; for (let s of n.units)
    for (let r of s.create)
        switch (r.kind) {
            case c.I18nContext:
                e.set(r.xref, r);
                break;
            case c.ElementStart:
                t.set(r.xref, r);
                break;
        } en(n, n.root, e, t); }
function en(n, e, t, s, r) { let i = null, o = new Map; for (let a of e.create)
    switch (a.kind) {
        case c.I18nStart:
            if (!a.context)
                throw Error("Could not find i18n context for i18n op");
            i = { i18nBlock: a, i18nContext: t.get(a.context) };
            break;
        case c.I18nEnd:
            i = null;
            break;
        case c.ElementStart:
            if (a.i18nPlaceholder !== void 0) {
                if (i === null)
                    throw Error("i18n tag placeholder should only occur inside an i18n block");
                Yc(a, i.i18nContext, i.i18nBlock, r), r && a.i18nPlaceholder.closeName && o.set(a.xref, r), r = void 0;
            }
            break;
        case c.ElementEnd:
            let l = s.get(a.xref);
            if (l && l.i18nPlaceholder !== void 0) {
                if (i === null)
                    throw Error("AssertionError: i18n tag placeholder should only occur inside an i18n block");
                Qc(l, i.i18nContext, i.i18nBlock, o.get(a.xref)), o.delete(a.xref);
            }
            break;
        case c.Projection:
            if (a.i18nPlaceholder !== void 0) {
                if (i === null)
                    throw Error("i18n tag placeholder should only occur inside an i18n block");
                Yc(a, i.i18nContext, i.i18nBlock, r), Qc(a, i.i18nContext, i.i18nBlock, r), r = void 0;
            }
            break;
        case c.Template:
            let u = n.views.get(a.xref);
            if (a.i18nPlaceholder === void 0)
                en(n, u, t, s);
            else {
                if (i === null)
                    throw Error("i18n tag placeholder should only occur inside an i18n block");
                a.templateKind === je.Structural ? en(n, u, t, s, a) : (la(n, u, a.handle.slot, a.i18nPlaceholder, i.i18nContext, i.i18nBlock, r), en(n, u, t, s), ua(n, u, a.handle.slot, a.i18nPlaceholder, i.i18nContext, i.i18nBlock, r), r = void 0);
            }
            break;
        case c.RepeaterCreate:
            if (r !== void 0)
                throw Error("AssertionError: Unexpected structural directive associated with @for block");
            let p = a.handle.slot + 1, f = n.views.get(a.xref);
            if (a.i18nPlaceholder === void 0)
                en(n, f, t, s);
            else {
                if (i === null)
                    throw Error("i18n tag placeholder should only occur inside an i18n block");
                la(n, f, p, a.i18nPlaceholder, i.i18nContext, i.i18nBlock, r), en(n, f, t, s), ua(n, f, p, a.i18nPlaceholder, i.i18nContext, i.i18nBlock, r), r = void 0;
            }
            if (a.emptyView !== null) {
                let g = a.handle.slot + 2, v = n.views.get(a.emptyView);
                if (a.emptyI18nPlaceholder === void 0)
                    en(n, v, t, s);
                else {
                    if (i === null)
                        throw Error("i18n tag placeholder should only occur inside an i18n block");
                    la(n, v, g, a.emptyI18nPlaceholder, i.i18nContext, i.i18nBlock, r), en(n, v, t, s), ua(n, v, g, a.emptyI18nPlaceholder, i.i18nContext, i.i18nBlock, r), r = void 0;
                }
            }
            break;
    } }
function Yc(n, e, t, s) { let { startName: r, closeName: i } = n.i18nPlaceholder, o = J.ElementTag | J.OpenTag, a = n.handle.slot; s !== void 0 && (o |= J.TemplateTag, a = { element: a, template: s.handle.slot }), i || (o |= J.CloseTag), Os(e.params, r, a, t.subTemplateIndex, o); }
function Qc(n, e, t, s) { let { closeName: r } = n.i18nPlaceholder; if (r) {
    let i = J.ElementTag | J.CloseTag, o = n.handle.slot;
    s !== void 0 && (i |= J.TemplateTag, o = { element: o, template: s.handle.slot }), Os(e.params, r, o, t.subTemplateIndex, i);
} }
function la(n, e, t, s, r, i, o) { let { startName: a, closeName: l } = s, u = J.TemplateTag | J.OpenTag; l || (u |= J.CloseTag), o !== void 0 && Os(r.params, a, o.handle.slot, i.subTemplateIndex, u), Os(r.params, a, t, Jh(n, i, e), u); }
function ua(n, e, t, s, r, i, o) { let { closeName: a } = s, l = J.TemplateTag | J.CloseTag; a && (Os(r.params, a, t, Jh(n, i, e), l), o !== void 0 && Os(r.params, a, o.handle.slot, i.subTemplateIndex, l)); }
function Jh(n, e, t) { for (let s of t.create)
    if (s.kind === c.I18nStart)
        return s.subTemplateIndex; return e.subTemplateIndex; }
function Os(n, e, t, s, r) { let i = n.get(e) ?? []; i.push({ value: t, subTemplateIndex: s, flags: r }), n.set(e, i); }
function j2(n) { let e = new Map, t = new Map, s = new Map; for (let o of n.units)
    for (let a of o.create)
        switch (a.kind) {
            case c.I18nStart:
                e.set(a.xref, a.subTemplateIndex);
                break;
            case c.I18nContext:
                t.set(a.xref, a);
                break;
            case c.IcuPlaceholder:
                s.set(a.xref, a);
                break;
        } let r = new Map, i = o => o.usage === Hs.I18nText ? o.i18nOwner : o.context; for (let o of n.units)
    for (let a of o.update)
        if (a.kind === c.I18nExpression) {
            let l = r.get(i(a)) || 0, u = e.get(a.i18nOwner) ?? null, p = { value: l, subTemplateIndex: u, flags: J.ExpressionIndex };
            z2(a, p, t, s), r.set(i(a), l + 1);
        } }
function z2(n, e, t, s) { if (n.i18nPlaceholder !== null) {
    let r = t.get(n.context), i = n.resolutionTime === Ur.Creation ? r.params : r.postprocessingParams, o = i.get(n.i18nPlaceholder) || [];
    o.push(e), i.set(n.i18nPlaceholder, o);
} n.icuPlaceholder !== null && s.get(n.icuPlaceholder)?.expressionPlaceholders.push(e); }
function G2(n) { for (let e of n.units)
    _o(e, e.create, null), _o(e, e.update, null); }
function _o(n, e, t) { let s = new Map, r = new Map; for (let i of e)
    switch (i.kind) {
        case c.Variable:
            switch (i.variable.kind) {
                case we.Identifier:
                    if (i.variable.local) {
                        if (r.has(i.variable.identifier))
                            continue;
                        r.set(i.variable.identifier, i.xref);
                    }
                    else if (s.has(i.variable.identifier))
                        continue;
                    s.set(i.variable.identifier, i.xref);
                    break;
                case we.Alias:
                    if (s.has(i.variable.identifier))
                        continue;
                    s.set(i.variable.identifier, i.xref);
                    break;
                case we.SavedView:
                    t = { view: i.variable.view, variable: i.xref };
                    break;
            }
            break;
        case c.Listener:
        case c.TwoWayListener:
            _o(n, i.handlerOps, t);
            break;
        case c.RepeaterCreate:
            i.trackByOps !== null && _o(n, i.trackByOps, t);
            break;
    } for (let i of e)
    i.kind == c.Listener || i.kind === c.TwoWayListener || ce(i, o => { if (o instanceof xe)
        return r.has(o.name) ? new Wt(r.get(o.name)) : s.has(o.name) ? new Wt(s.get(o.name)) : new Me(new Gt(n.job.root.xref), o.name); if (o instanceof ao && typeof o.view == "number") {
        if (t === null || t.view !== o.view)
            throw new Error(`AssertionError: no saved view ${o.view} from view ${n.xref}`);
        return o.view = new Wt(t.variable), o;
    }
    else
        return o; }, z.None); for (let i of e)
    _e(i, o => { if (o instanceof xe)
        throw new Error(`AssertionError: no lexical reads should remain, but found read of ${o.name}`); }); }
var X2 = new Map([[ee.HTML, h.sanitizeHtml], [ee.RESOURCE_URL, h.sanitizeResourceUrl], [ee.SCRIPT, h.sanitizeScript], [ee.STYLE, h.sanitizeStyle], [ee.URL, h.sanitizeUrl]]), Y2 = new Map([[ee.HTML, h.trustConstantHtml], [ee.RESOURCE_URL, h.trustConstantResourceUrl]]);
function Q2(n) { for (let e of n.units) {
    let t = Pu(e);
    if (n.kind !== C.Host) {
        for (let s of e.create)
            if (s.kind === c.ExtractedAttribute) {
                let r = Y2.get(Zc(s.securityContext)) ?? null;
                s.trustedValueFn = r !== null ? y(r) : null;
            }
    }
    for (let s of e.update)
        switch (s.kind) {
            case c.Property:
            case c.Attribute:
            case c.HostProperty:
                let r = null;
                if (Array.isArray(s.securityContext) && s.securityContext.length === 2 && s.securityContext.indexOf(ee.URL) > -1 && s.securityContext.indexOf(ee.RESOURCE_URL) > -1 ? r = h.sanitizeUrlOrResourceUrl : r = X2.get(Zc(s.securityContext)) ?? null, s.sanitizer = r !== null ? y(r) : null, s.sanitizer === null) {
                    let i = !1;
                    if (n.kind === C.Host || s.kind === c.HostProperty)
                        i = !0;
                    else {
                        let o = t.get(s.target);
                        if (o === void 0 || !wn(o))
                            throw Error("Property should have an element-like owner");
                        i = Z2(o);
                    }
                    i && iw(s.name) && (s.sanitizer = y(h.validateIframeAttribute));
                }
                break;
        }
} }
function Z2(n) { return n.kind === c.ElementStart && n.tag?.toLowerCase() === "iframe"; }
function Zc(n) { if (Array.isArray(n)) {
    if (n.length > 1)
        throw Error("AssertionError: Ambiguous security context");
    return n[0] || ee.NONE;
} return n; }
function J2(n) { for (let e of n.units)
    for (let t of e.create)
        t.kind === c.TwoWayListener && ce(t, s => { if (!(s instanceof lo))
            return s; let { target: r, value: i } = s; if (r instanceof Me || r instanceof It)
            return jc(r, i).or(r.set(i)); if (r instanceof Wt)
            return jc(r, i); throw new Error("Unsupported expression in two-way action binding."); }, z.InChildOperation); }
function K2(n) { for (let e of n.units) {
    e.create.prepend([on(e.job.allocateXrefId(), { kind: we.SavedView, name: null, view: e.xref }, new cl, tt.None)]);
    for (let t of e.create) {
        if (t.kind !== c.Listener && t.kind !== c.TwoWayListener)
            continue;
        let s = e !== n.root;
        if (!s)
            for (let r of t.handlerOps)
                _e(r, i => { (i instanceof io || i instanceof jr) && (s = !0); });
        s && eS(e, t);
    }
} }
function eS(n, e) { e.handlerOps.prepend([on(n.job.allocateXrefId(), { kind: we.Context, name: null, view: n.xref }, new ao(n.xref), tt.None)]); for (let t of e.handlerOps)
    t.kind === c.Statement && t.statement instanceof ye && (t.statement.value = new pl(t.statement.value)); }
function tS(n) { let e = new Map; for (let t of n.units) {
    let s = 0;
    for (let r of t.create)
        Ws(r) && (r.handle.slot = s, e.set(r.xref, r.handle.slot), s += r.numSlotsUsed);
    t.decls = s;
} for (let t of n.units)
    for (let s of t.ops())
        if (s.kind === c.Template || s.kind === c.RepeaterCreate) {
            let r = n.views.get(s.xref);
            s.decls = r.decls;
        } }
function nS(n) { for (let e of n.units)
    for (let t of e.update)
        if (t.kind === c.Binding)
            switch (t.bindingKind) {
                case I.ClassName:
                    if (t.expression instanceof le)
                        throw new Error("Unexpected interpolation in ClassName binding");
                    w.replace(t, Qm(t.target, t.name, t.expression, t.sourceSpan));
                    break;
                case I.StyleProperty:
                    w.replace(t, Ym(t.target, t.name, t.expression, t.unit, t.sourceSpan));
                    break;
                case I.Property:
                case I.Template:
                    t.name === "style" ? w.replace(t, Zm(t.target, t.expression, t.sourceSpan)) : t.name === "class" && w.replace(t, Jm(t.target, t.expression, t.sourceSpan));
                    break;
            } }
function sS(n) { for (let e of n.units)
    e.create.prepend(To(e.create)), e.update.prepend(To(e.update)); }
function To(n) { let e = 0, t = []; for (let s of n) {
    let r = new Map;
    _e(s, (u, p) => { p & z.InChildOperation || u instanceof Xt && r.set(u.xref, u); });
    let i = 0, o = new Set, a = new Set, l = new Map;
    _e(s, (u, p) => { p & z.InChildOperation || (u instanceof Et ? (o.has(u.xref) || (o.add(u.xref), l.set(u.xref, `tmp_${e}_${i++}`)), Jc(l, u)) : u instanceof Xt && (r.get(u.xref) === u && (a.add(u.xref), i--), Jc(l, u))); }), t.push(...Array.from(new Set(l.values())).map(u => wt(new ve(u)))), e++, s.kind === c.Listener || s.kind === c.TwoWayListener ? s.handlerOps.prepend(To(s.handlerOps)) : s.kind === c.RepeaterCreate && s.trackByOps !== null && s.trackByOps.prepend(To(s.trackByOps));
} return t; }
function Jc(n, e) { let t = n.get(e.xref); if (t === void 0)
    throw new Error(`Found xref with unassigned name: ${e.xref}`); e.name = t; }
function rS(n) { for (let e of n.units)
    for (let t of e.create)
        if (t.kind === c.RepeaterCreate)
            if (t.track instanceof ze && t.track.name === "$index")
                t.trackByFn = y(h.repeaterTrackByIndex);
            else if (t.track instanceof ze && t.track.name === "$item")
                t.trackByFn = y(h.repeaterTrackByIdentity);
            else if (iS(n.root.xref, t.track))
                t.usesComponentInstance = !0, t.track.receiver.receiver.view === e.xref ? t.trackByFn = t.track.receiver : (t.trackByFn = y(h.componentInstance).callFn([]).prop(t.track.receiver.name), t.track = t.trackByFn);
            else {
                t.track = A(t.track, r => { if (r instanceof Ds || r instanceof uo)
                    throw new Error("Illegal State: Pipes are not allowed in this context"); return r instanceof Gt ? (t.usesComponentInstance = !0, new ul(r.view)) : r; }, z.None);
                let s = new w;
                s.push(wt(new ye(t.track, t.track.sourceSpan))), t.trackByOps = s;
            } }
function iS(n, e) { if (!(e instanceof Ie) || e.args.length === 0 || e.args.length > 2 || !(e.receiver instanceof Me && e.receiver.receiver instanceof Gt) || e.receiver.receiver.view !== n)
    return !1; let [t, s] = e.args; return !(t instanceof ze) || t.name !== "$index" ? !1 : e.args.length === 1 ? !0 : !(!(s instanceof ze) || s.name !== "$item"); }
function oS(n) { for (let e of n.units)
    for (let t of e.create)
        t.kind === c.RepeaterCreate && (t.track = A(t.track, s => { if (s instanceof xe) {
            if (t.varNames.$index.has(s.name))
                return N("$index");
            if (s.name === t.varNames.$implicit)
                return N("$item");
        } return s; }, z.None)); }
function aS(n) { for (let e of n.units) {
    let t = 0;
    for (let s of e.ops())
        na(s) && (t += lS(s));
    for (let s of e.ops())
        _e(s, r => { Bt(r) && (n.compatibility === Xe.TemplateDefinitionBuilder && r instanceof Jn || (mc(r) && (r.varOffset = t), na(r) && (t += Kc(r)))); });
    if (n.compatibility === Xe.TemplateDefinitionBuilder)
        for (let s of e.ops())
            _e(s, r => { !Bt(r) || !(r instanceof Jn) || (mc(r) && (r.varOffset = t), na(r) && (t += Kc(r))); });
    e.vars = t;
} if (n instanceof Xr)
    for (let e of n.units)
        for (let t of e.create) {
            if (t.kind !== c.Template && t.kind !== c.RepeaterCreate)
                continue;
            let s = n.views.get(t.xref);
            t.vars = s.vars;
        } }
function lS(n) { let e; switch (n.kind) {
    case c.Property:
    case c.HostProperty:
    case c.Attribute: return e = 1, n.expression instanceof le && !uS(n.expression) && (e += n.expression.expressions.length), e;
    case c.TwoWayProperty: return 1;
    case c.StyleProp:
    case c.ClassProp:
    case c.StyleMap:
    case c.ClassMap: return e = 2, n.expression instanceof le && (e += n.expression.expressions.length), e;
    case c.InterpolateText: return n.interpolation.expressions.length;
    case c.I18nExpression:
    case c.Conditional:
    case c.DeferWhen:
    case c.StoreLet: return 1;
    case c.RepeaterCreate: return n.emptyView ? 1 : 0;
    default: throw new Error(`Unhandled op: ${c[n.kind]}`);
} }
function Kc(n) { switch (n.kind) {
    case k.PureFunctionExpr: return 1 + n.args.length;
    case k.PipeBinding: return 1 + n.args.length;
    case k.PipeBindingVariadic: return 1 + n.numArgs;
    case k.StoreLet: return 1;
    default: throw new Error(`AssertionError: unhandled ConsumesVarsTrait expression ${n.constructor.name}`);
} }
function uS(n) { return !(n.expressions.length !== 1 || n.strings.length !== 2 || n.strings[0] !== "" || n.strings[1] !== ""); }
function cS(n) { for (let e of n.units) {
    mi(e.create), mi(e.update);
    for (let t of e.create)
        t.kind === c.Listener || t.kind === c.TwoWayListener ? mi(t.handlerOps) : t.kind === c.RepeaterCreate && t.trackByOps !== null && mi(t.trackByOps);
    gi(e.create, n.compatibility), gi(e.update, n.compatibility);
    for (let t of e.create)
        t.kind === c.Listener || t.kind === c.TwoWayListener ? gi(t.handlerOps, n.compatibility) : t.kind === c.RepeaterCreate && t.trackByOps !== null && gi(t.trackByOps, n.compatibility);
} }
var de = function (n) { return n[n.None = 0] = "None", n[n.ViewContextRead = 1] = "ViewContextRead", n[n.ViewContextWrite = 2] = "ViewContextWrite", n[n.SideEffectful = 4] = "SideEffectful", n; }(de || {});
function mi(n) { let e = new Map; for (let t of n)
    t.kind === c.Variable && t.flags & tt.AlwaysInline && (_e(t, s => { if (Bt(s) && Bu(s) !== de.None)
        throw new Error("AssertionError: A context-sensitive variable was marked AlwaysInline"); }), e.set(t.xref, t)), ce(t, s => s instanceof Wt && e.has(s.xref) ? e.get(s.xref).initializer.clone() : s, z.None); for (let t of e.values())
    w.remove(t); }
function gi(n, e) { let t = new Map, s = new Map, r = new Set, i = new Map; for (let u of n) {
    if (u.kind === c.Variable) {
        if (t.has(u.xref) || s.has(u.xref))
            throw new Error(`Should not see two declarations of the same variable: ${u.xref}`);
        t.set(u.xref, u), s.set(u.xref, 0);
    }
    i.set(u, pS(u)), hS(u, s, r);
} let o = !1; for (let u of n.reversed()) {
    let p = i.get(u);
    if (u.kind === c.Variable && s.get(u.xref) === 0) {
        if (o && p.fences & de.ViewContextWrite || p.fences & de.SideEffectful) {
            let f = wt(u.initializer.toStmt());
            i.set(f, p), w.replace(u, f);
        }
        else
            fS(u, s), w.remove(u);
        i.delete(u), t.delete(u.xref), s.delete(u.xref);
        continue;
    }
    p.fences & de.ViewContextRead && (o = !0);
} let a = []; for (let [u, p] of s) {
    let g = !!(t.get(u).flags & tt.AlwaysInline);
    p !== 1 || g || r.has(u) || a.push(u);
} let l; for (; l = a.pop();) {
    let u = t.get(l), p = i.get(u);
    if (!!(u.flags & tt.AlwaysInline))
        throw new Error("AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.");
    for (let g = u.next; g.kind !== c.ListEnd; g = g.next) {
        let v = i.get(g);
        if (v.variablesUsed.has(l)) {
            if (e === Xe.TemplateDefinitionBuilder && !mS(u, g))
                break;
            if (dS(l, u.initializer, g, p.fences)) {
                v.variablesUsed.delete(l);
                for (let S of p.variablesUsed)
                    v.variablesUsed.add(S);
                v.fences |= p.fences, t.delete(l), s.delete(l), i.delete(u), w.remove(u);
            }
            break;
        }
        if (!Kh(v.fences, p.fences))
            break;
    }
} }
function Bu(n) { switch (n.kind) {
    case k.NextContext: return de.ViewContextRead | de.ViewContextWrite;
    case k.RestoreView: return de.ViewContextRead | de.ViewContextWrite | de.SideEffectful;
    case k.StoreLet: return de.SideEffectful;
    case k.Reference:
    case k.ContextLetReference: return de.ViewContextRead;
    default: return de.None;
} }
function pS(n) { let e = de.None, t = new Set; return _e(n, s => { if (Bt(s))
    switch (s.kind) {
        case k.ReadVariable:
            t.add(s.xref);
            break;
        default: e |= Bu(s);
    } }), { fences: e, variablesUsed: t }; }
function hS(n, e, t) { _e(n, (s, r) => { if (!Bt(s) || s.kind !== k.ReadVariable)
    return; let i = e.get(s.xref); i !== void 0 && (e.set(s.xref, i + 1), r & z.InChildOperation && t.add(s.xref)); }); }
function fS(n, e) { _e(n, t => { if (!Bt(t) || t.kind !== k.ReadVariable)
    return; let s = e.get(t.xref); if (s !== void 0) {
    if (s === 0)
        throw new Error(`Inaccurate variable count: ${t.xref} - found another read but count is already 0`);
    e.set(t.xref, s - 1);
} }); }
function Kh(n, e) { if (n & de.ViewContextWrite) {
    if (e & de.ViewContextRead)
        return !1;
}
else if (n & de.ViewContextRead && e & de.ViewContextWrite)
    return !1; return !0; }
function dS(n, e, t, s) { let r = !1, i = !0; return ce(t, (o, a) => { if (!Bt(o) || r || !i)
    return o; if (a & z.InChildOperation && s & de.ViewContextRead)
    return o; switch (o.kind) {
    case k.ReadVariable:
        if (o.xref === n)
            return r = !0, e;
        break;
    default:
        let l = Bu(o);
        i = i && Kh(l, s);
        break;
} return o; }, z.None), r; }
function mS(n, e) { switch (n.variable.kind) {
    case we.Identifier: return n.initializer instanceof ze && n.initializer.name === "ctx";
    case we.Context: return e.kind === c.Variable;
    default: return !0;
} }
function gS(n) { for (let e of n.units) {
    let t = null, s = null;
    for (let r of e.create)
        switch (r.kind) {
            case c.I18nStart:
                t = r;
                break;
            case c.I18nEnd:
                t = null;
                break;
            case c.IcuStart:
                t === null && (s = n.allocateXrefId(), w.insertBefore(Xo(s, r.message, void 0, null), r));
                break;
            case c.IcuEnd:
                s !== null && (w.insertAfter(Yo(s, null), r), s = null);
                break;
        }
} }
function vS(n) { let e = new Set; for (let t of n.units)
    for (let s of t.ops())
        _e(s, r => { r instanceof jr && e.add(r.target); }); for (let t of n.units)
    for (let s of t.update)
        ce(s, r => r instanceof Wr && !e.has(r.target) ? r.value : r, z.None); }
function wS(n) { for (let e of n.units)
    for (let t of e.update) {
        if (t.kind !== c.Variable || t.variable.kind !== we.Identifier || !(t.initializer instanceof Wr))
            continue;
        let s = t.variable.identifier, r = t;
        for (; r && r.kind !== c.ListEnd;)
            ce(r, i => i instanceof xe && i.name === s ? d(void 0) : i, z.None), r = r.prev;
    } }
function ES(n) { for (let e of n.units)
    for (let t of e.update) {
        if (t.kind !== c.StoreLet)
            continue;
        let s = { kind: we.Identifier, name: null, identifier: t.declaredName, local: !0 };
        w.replace(t, on(n.allocateXrefId(), s, new Wr(t.target, t.value, t.sourceSpan), tt.None));
    } }
function SS(n) { if (!(!n.enableDebugLocations || n.relativeTemplatePath === null))
    for (let e of n.units) {
        let t = [];
        for (let s of e.create)
            if (s.kind === c.ElementStart || s.kind === c.Element) {
                let r = s.startSourceSpan.start;
                t.push({ targetSlot: s.handle, offset: r.offset, line: r.line, column: r.col });
            }
        t.length > 0 && e.create.push(Sg(n.relativeTemplatePath, t));
    } }
var xS = [{ kind: C.Tmpl, fn: cE }, { kind: C.Host, fn: yv }, { kind: C.Tmpl, fn: zw }, { kind: C.Tmpl, fn: vE }, { kind: C.Tmpl, fn: gS }, { kind: C.Both, fn: Wg }, { kind: C.Both, fn: nS }, { kind: C.Both, fn: Ng }, { kind: C.Both, fn: bg }, { kind: C.Tmpl, fn: Ug }, { kind: C.Both, fn: Xw }, { kind: C.Tmpl, fn: O2 }, { kind: C.Both, fn: Bg }, { kind: C.Both, fn: uE }, { kind: C.Tmpl, fn: Mg }, { kind: C.Tmpl, fn: fE }, { kind: C.Tmpl, fn: jg }, { kind: C.Tmpl, fn: Uw }, { kind: C.Tmpl, fn: qg }, { kind: C.Tmpl, fn: q2 }, { kind: C.Tmpl, fn: Tg }, { kind: C.Tmpl, fn: Ag }, { kind: C.Tmpl, fn: gE }, { kind: C.Both, fn: SE }, { kind: C.Tmpl, fn: vv }, { kind: C.Tmpl, fn: ES }, { kind: C.Tmpl, fn: wv }, { kind: C.Tmpl, fn: K2 }, { kind: C.Both, fn: yg }, { kind: C.Both, fn: U2 }, { kind: C.Tmpl, fn: oS }, { kind: C.Tmpl, fn: wS }, { kind: C.Both, fn: G2 }, { kind: C.Tmpl, fn: zg }, { kind: C.Tmpl, fn: J2 }, { kind: C.Tmpl, fn: rS }, { kind: C.Both, fn: H2 }, { kind: C.Both, fn: Q2 }, { kind: C.Tmpl, fn: Ww }, { kind: C.Both, fn: sE }, { kind: C.Both, fn: Zg }, { kind: C.Both, fn: sS }, { kind: C.Both, fn: cS }, { kind: C.Both, fn: vS }, { kind: C.Tmpl, fn: tS }, { kind: C.Tmpl, fn: W2 }, { kind: C.Tmpl, fn: j2 }, { kind: C.Tmpl, fn: hv }, { kind: C.Tmpl, fn: $w }, { kind: C.Tmpl, fn: Sv }, { kind: C.Both, fn: Og }, { kind: C.Tmpl, fn: V2 }, { kind: C.Both, fn: aS }, { kind: C.Tmpl, fn: gv }, { kind: C.Both, fn: Yw }, { kind: C.Tmpl, fn: Hg }, { kind: C.Tmpl, fn: Jw }, { kind: C.Tmpl, fn: eE }, { kind: C.Tmpl, fn: Qg }, { kind: C.Tmpl, fn: SS }, { kind: C.Tmpl, fn: nE }, { kind: C.Both, fn: EE }, { kind: C.Both, fn: R2 }, { kind: C.Both, fn: Lg }];
function ef(n, e) { for (let t of xS)
    (t.kind === e || t.kind === C.Both) && t.fn(n); }
function yS(n, e) { let t = nf(n.root); return tf(n.root, e), t; }
function tf(n, e) { for (let t of n.job.units) {
    if (t.parent !== n.xref)
        continue;
    tf(t, e);
    let s = nf(t);
    e.statements.push(s.toDeclStmt(s.name));
} }
function nf(n) { if (n.fnName === null)
    throw new Error(`AssertionError: view ${n.xref} is unnamed`); let e = []; for (let i of n.create) {
    if (i.kind !== c.Statement)
        throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${c[i.kind]}`);
    e.push(i.statement);
} let t = []; for (let i of n.update) {
    if (i.kind !== c.Statement)
        throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${c[i.kind]}`);
    t.push(i.statement);
} let s = bo(1, e), r = bo(2, t); return zt([new Y("rf"), new Y("ctx")], [...s, ...r], void 0, void 0, n.fnName); }
function bo(n, e) { return e.length === 0 ? [] : [ri(new W(b.BitwiseAnd, N("rf"), d(n)), e)]; }
function CS(n) { if (n.root.fnName === null)
    throw new Error("AssertionError: host binding function is unnamed"); let e = []; for (let i of n.root.create) {
    if (i.kind !== c.Statement)
        throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${c[i.kind]}`);
    e.push(i.statement);
} let t = []; for (let i of n.root.update) {
    if (i.kind !== c.Statement)
        throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${c[i.kind]}`);
    t.push(i.statement);
} if (e.length === 0 && t.length === 0)
    return null; let s = bo(1, e), r = bo(2, t); return zt([new Y("rf"), new Y("ctx")], [...s, ...r], void 0, void 0, n.root.fnName); }
var sf = Xe.TemplateDefinitionBuilder, Fn = new $s, $n = "ng-template";
function Pl(n) { return n instanceof Ae; }
function AS(n) { return Pl(n) && n.nodes.length === 1 && n.nodes[0] instanceof gn; }
function _S(n, e, t, s, r, i, o, a, l) { let u = new Xr(n, t, sf, s, r, i, o, a, l); return Qt(u.root, e), u; }
function TS(n, e, t) { let s = new go(n.componentName, t, sf); for (let r of n.properties ?? []) {
    let i = I.Property;
    r.name.startsWith("attr.") && (r.name = r.name.substring(5), i = I.Attribute), r.isAnimation && (i = I.Animation);
    let o = e.calcPossibleSecurityContexts(n.componentSelector, r.name, i === I.Attribute).filter(a => a !== ee.NONE);
    bS(s, r, i, o);
} for (let [r, i] of Object.entries(n.attributes) ?? []) {
    let o = e.calcPossibleSecurityContexts(n.componentSelector, r, !0).filter(a => a !== ee.NONE);
    kS(s, r, i, o);
} for (let r of n.events ?? [])
    IS(s, r); return s; }
function bS(n, e, t, s) { let r, i = e.expression.ast; i instanceof ii ? r = new le(i.strings, i.expressions.map(o => F(o, n, e.sourceSpan)), []) : r = F(i, n, e.sourceSpan), n.root.update.push(Zn(n.root.xref, t, e.name, r, null, s, !1, !1, null, null, e.sourceSpan)); }
function kS(n, e, t, s) { let r = Zn(n.root.xref, I.Attribute, e, t, null, s, !0, !1, null, null, t.sourceSpan); n.root.update.push(r); }
function IS(n, e) { let [t, s] = e.type !== it.Animation ? [null, e.targetOrPhase] : [e.targetOrPhase, null], r = Du(n.root.xref, new Re, e.name, null, Mu(n.root, e.handler, e.handlerSpan), t, s, !0, e.sourceSpan); n.root.create.push(r); }
function Qt(n, e) { for (let t of e)
    if (t instanceof Nt)
        NS(n, t);
    else if (t instanceof Ue)
        DS(n, t);
    else if (t instanceof ks)
        PS(n, t);
    else if (t instanceof kn)
        rf(n, t, null);
    else if (t instanceof _s)
        of(n, t, null);
    else if (t instanceof Yi)
        LS(n, t);
    else if (t instanceof Xi)
        BS(n, t);
    else if (t instanceof Xn)
        MS(n, t);
    else if (t instanceof Yp)
        FS(n, t);
    else if (t instanceof bs)
        $S(n, t);
    else if (t instanceof vu)
        VS(n, t);
    else
        throw new Error(`Unsupported template node: ${t.constructor.name}`); }
function NS(n, e) { if (e.i18n !== void 0 && !(e.i18n instanceof Ae || e.i18n instanceof Pt))
    throw Error(`Unhandled i18n metadata type for element: ${e.i18n.constructor.name}`); let t = n.job.allocateXrefId(), [s, r] = vt(e.name), i = og(r, t, Bh(s), e.i18n instanceof Pt ? e.i18n : void 0, e.startSourceSpan, e.sourceSpan); n.create.push(i), HS(n, i, e), uf(i, e); let o = null; e.i18n instanceof Ae && (o = n.job.allocateXrefId(), n.create.push(Xo(o, e.i18n, void 0, e.startSourceSpan))), Qt(n, e.children); let a = lg(t, e.endSourceSpan ?? e.startSourceSpan); n.create.push(a), o !== null && w.insertBefore(Yo(o, e.endSourceSpan ?? e.startSourceSpan), a); }
function DS(n, e) { if (e.i18n !== void 0 && !(e.i18n instanceof Ae || e.i18n instanceof Pt))
    throw Error(`Unhandled i18n metadata type for template: ${e.i18n.constructor.name}`); let t = n.job.allocateView(n.xref), s = e.tagName, r = ""; e.tagName && ([r, s] = vt(e.tagName)); let i = e.i18n instanceof Pt ? e.i18n : void 0, o = Bh(r), a = s === null ? "" : $g(s, o), l = qS(e) ? je.NgTemplate : je.Structural, u = Go(t.xref, l, s, a, o, i, e.startSourceSpan, e.sourceSpan); n.create.push(u), US(n, u, e, l), uf(u, e), Qt(t, e.children); for (let { name: p, value: f } of e.variables)
    t.contextVariables.set(p, f !== "" ? f : "$implicit"); if (l === je.NgTemplate && e.i18n instanceof Ae) {
    let p = n.job.allocateXrefId();
    w.insertAfter(Xo(p, e.i18n, void 0, e.startSourceSpan), t.create.head), w.insertBefore(Yo(p, e.endSourceSpan ?? e.startSourceSpan), t.create.tail);
} }
function PS(n, e) { if (e.i18n !== void 0 && !(e.i18n instanceof Pt))
    throw Error(`Unhandled i18n metadata type for element: ${e.i18n.constructor.name}`); let t = null; e.children.some(i => !(i instanceof Ho) && (!(i instanceof kn) || i.value.trim().length > 0)) && (t = n.job.allocateView(n.xref), Qt(t, e.children)); let s = n.job.allocateXrefId(), r = fg(s, e.selector, e.i18n, t?.xref ?? null, e.sourceSpan); for (let i of e.attributes) {
    let o = Fn.securityContext(e.name, i.name, !0);
    n.update.push(Zn(r.xref, I.Attribute, i.name, d(i.value), null, o, !0, !1, null, qt(i.i18n), i.sourceSpan));
} n.create.push(r); }
function rf(n, e, t) { n.create.push(Ih(n.job.allocateXrefId(), e.value, t, e.sourceSpan)); }
function of(n, e, t) { let s = e.value; if (s instanceof Ke && (s = s.ast), !(s instanceof ii))
    throw new Error(`AssertionError: expected Interpolation for BoundText node, got ${s.constructor.name}`); if (e.i18n !== void 0 && !(e.i18n instanceof We))
    throw Error(`Unhandled i18n metadata type for text interpolation: ${e.i18n?.constructor.name}`); let r = e.i18n instanceof We ? e.i18n.children.filter(a => a instanceof ot).map(a => a.name) : []; if (r.length > 0 && r.length !== s.expressions.length)
    throw Error(`Unexpected number of i18n placeholders (${s.expressions.length}) for BoundText with ${s.expressions.length} expressions`); let i = n.job.allocateXrefId(); n.create.push(Ih(i, "", t, e.sourceSpan)); let o = n.job.compatibility ? null : e.sourceSpan; n.update.push(zm(i, new le(s.strings, s.expressions.map(a => F(a, n.job, o)), r), e.sourceSpan)); }
function LS(n, e) { let t = null, s = []; for (let r = 0; r < e.branches.length; r++) {
    let i = e.branches[r], o = n.job.allocateView(n.xref), a = ko(n, o.xref, i);
    i.expressionAlias !== null && o.contextVariables.set(i.expressionAlias.name, Lh);
    let l;
    if (i.i18n !== void 0) {
        if (!(i.i18n instanceof Lt))
            throw Error(`Unhandled i18n metadata type for if block: ${i.i18n?.constructor.name}`);
        l = i.i18n;
    }
    let u = Go(o.xref, je.Block, a, "Conditional", Ce.HTML, l, i.startSourceSpan, i.sourceSpan);
    n.create.push(u), t === null && (t = o.xref);
    let p = i.expression ? F(i.expression, n.job, null) : null, f = new po(p, u.xref, u.handle, i.expressionAlias);
    s.push(f), Qt(o, i.children);
} n.update.push(Th(t, null, s, e.sourceSpan)); }
function BS(n, e) { if (e.cases.length === 0)
    return; let t = null, s = []; for (let r of e.cases) {
    let i = n.job.allocateView(n.xref), o = ko(n, i.xref, r), a;
    if (r.i18n !== void 0) {
        if (!(r.i18n instanceof Lt))
            throw Error(`Unhandled i18n metadata type for switch block: ${r.i18n?.constructor.name}`);
        a = r.i18n;
    }
    let l = Go(i.xref, je.Block, o, "Case", Ce.HTML, a, r.startSourceSpan, r.sourceSpan);
    n.create.push(l), t === null && (t = i.xref);
    let u = r.expression ? F(r.expression, n.job, e.startSourceSpan) : null, p = new po(u, l.xref, l.handle);
    s.push(p), Qt(i, r.children);
} n.update.push(Th(t, F(e.expression, n.job, null), s, e.sourceSpan)); }
function vi(n, e, t, s, r) { if (t !== void 0 && !(t instanceof Lt))
    throw Error("Unhandled i18n metadata type for defer block"); if (s === void 0)
    return null; let i = n.job.allocateView(n.xref); Qt(i, s); let o = Go(i.xref, je.Block, null, `Defer${e}`, Ce.HTML, t, r, r); return n.create.push(o), o; }
function MS(n, e) { let t = null; if (n.job.deferMeta.mode === 0) {
    if (!n.job.deferMeta.blocks.has(e))
        throw new Error("AssertionError: unable to find a dependency function for this deferred block");
    t = n.job.deferMeta.blocks.get(e) ?? null;
} let s = vi(n, "", e.i18n, e.children, e.sourceSpan), r = vi(n, "Loading", e.loading?.i18n, e.loading?.children, e.loading?.sourceSpan), i = vi(n, "Placeholder", e.placeholder?.i18n, e.placeholder?.children, e.placeholder?.sourceSpan), o = vi(n, "Error", e.error?.i18n, e.error?.children, e.error?.sourceSpan), a = n.job.allocateXrefId(), l = dg(a, s.xref, s.handle, t, n.job.allDeferrableDepsFn, e.sourceSpan); l.placeholderView = i?.xref ?? null, l.placeholderSlot = i?.handle ?? null, l.loadingSlot = r?.handle ?? null, l.errorSlot = o?.handle ?? null, l.placeholderMinimumTime = e.placeholder?.minimumTime ?? null, l.loadingMinimumTime = e.loading?.minimumTime ?? null, l.loadingAfterTime = e.loading?.afterTime ?? null, l.flags = RS(e), n.create.push(l); let u = [], p = []; ca("hydrate", e.hydrateTriggers, u, p, n, a), ca("none", e.triggers, u, p, n, a), ca("prefetch", e.prefetchTriggers, u, p, n, a), u.some(g => g.modifier === "none") || p.some(g => g.modifier === "none") || u.push(Kt(a, { kind: X.Idle }, "none", null)), n.create.push(u), n.update.push(p); }
function RS(n) { return Object.keys(n.hydrateTriggers).length > 0 ? 1 : null; }
function ca(n, e, t, s, r, i) { if (e.idle !== void 0) {
    let o = Kt(i, { kind: X.Idle }, n, e.idle.sourceSpan);
    t.push(o);
} if (e.immediate !== void 0) {
    let o = Kt(i, { kind: X.Immediate }, n, e.immediate.sourceSpan);
    t.push(o);
} if (e.timer !== void 0) {
    let o = Kt(i, { kind: X.Timer, delay: e.timer.delay }, n, e.timer.sourceSpan);
    t.push(o);
} if (e.hover !== void 0) {
    let o = Kt(i, { kind: X.Hover, targetName: e.hover.reference, targetXref: null, targetSlot: null, targetView: null, targetSlotViewSteps: null }, n, e.hover.sourceSpan);
    t.push(o);
} if (e.interaction !== void 0) {
    let o = Kt(i, { kind: X.Interaction, targetName: e.interaction.reference, targetXref: null, targetSlot: null, targetView: null, targetSlotViewSteps: null }, n, e.interaction.sourceSpan);
    t.push(o);
} if (e.viewport !== void 0) {
    let o = Kt(i, { kind: X.Viewport, targetName: e.viewport.reference, targetXref: null, targetSlot: null, targetView: null, targetSlotViewSteps: null }, n, e.viewport.sourceSpan);
    t.push(o);
} if (e.never !== void 0) {
    let o = Kt(i, { kind: X.Never }, n, e.never.sourceSpan);
    t.push(o);
} if (e.when !== void 0) {
    if (e.when.value instanceof ii)
        throw new Error("Unexpected interpolation in defer block when trigger");
    let o = ng(i, F(e.when.value, r.job, e.when.sourceSpan), n, e.when.sourceSpan);
    s.push(o);
} }
function FS(n, e) { if (e.i18n instanceof Ae && AS(e.i18n)) {
    let t = n.job.allocateXrefId();
    n.create.push(vg(t, e.i18n, Kp(e.i18n).name, null));
    for (let [s, r] of Object.entries(E(E({}, e.vars), e.placeholders)))
        r instanceof _s ? of(n, r, s) : rf(n, r, s);
    n.create.push(wg(t));
}
else
    throw Error(`Unhandled i18n metadata type for ICU: ${e.i18n?.constructor.name}`); }
function $S(n, e) { let t = n.job.allocateView(n.xref), s = `\u0275$index_${t.xref}`, r = `\u0275$count_${t.xref}`, i = new Set; t.contextVariables.set(e.item.name, e.item.value); for (let T of e.contextVariables)
    T.value === "$index" && i.add(T.name), T.name === "$index" ? t.contextVariables.set("$index", T.value).set(s, T.value) : T.name === "$count" ? t.contextVariables.set("$count", T.value).set(r, T.value) : t.aliases.add({ kind: we.Alias, name: null, identifier: T.name, expression: OS(T, s, r) }); let o = he(e.trackBy.span, e.sourceSpan), a = F(e.trackBy, n.job, o); Qt(t, e.children); let l = null, u = null; e.empty !== null && (l = n.job.allocateView(n.xref), Qt(l, e.empty.children), u = ko(n, l.xref, e.empty)); let p = { $index: i, $implicit: e.item.name }; if (e.i18n !== void 0 && !(e.i18n instanceof Lt))
    throw Error("AssertionError: Unhandled i18n metadata type or @for"); if (e.empty?.i18n !== void 0 && !(e.empty.i18n instanceof Lt))
    throw Error("AssertionError: Unhandled i18n metadata type or @empty"); let f = e.i18n, g = e.empty?.i18n, v = ko(n, t.xref, e), S = ag(t.xref, l?.xref ?? null, v, a, p, u, f, g, e.startSourceSpan, e.sourceSpan); n.create.push(S); let _ = F(e.expression, n.job, he(e.expression.span, e.sourceSpan)), x = tg(S.xref, S.handle, _, e.sourceSpan); n.update.push(x); }
function OS(n, e, t) { switch (n.value) {
    case "$index": return new xe(e);
    case "$count": return new xe(t);
    case "$first": return new xe(e).identical(d(0));
    case "$last": return new xe(e).identical(new xe(t).minus(d(1)));
    case "$even": return new xe(e).modulo(d(2)).identical(d(0));
    case "$odd": return new xe(e).modulo(d(2)).notIdentical(d(0));
    default: throw new Error(`AssertionError: unknown @for loop variable ${n.value}`);
} }
function VS(n, e) { let t = n.job.allocateXrefId(); n.create.push(mg(t, e.name, e.sourceSpan)), n.update.push(rg(t, e.name, F(e.value, n.job, e.valueSpan), e.sourceSpan)); }
function F(n, e, t) { if (n instanceof Ke)
    return F(n.ast, e, t); if (n instanceof Gn)
    return n.receiver instanceof rt && !(n.receiver instanceof zn) ? new xe(n.name) : new Me(F(n.receiver, e, t), n.name, null, he(n.span, t)); if (n instanceof Di)
    return n.receiver instanceof rt ? new qn(new Gt(e.root.xref), n.name, F(n.value, e, t), null, he(n.span, t)) : new qn(F(n.receiver, e, t), n.name, F(n.value, e, t), void 0, he(n.span, t)); if (n instanceof Bi)
    return new Es(F(n.receiver, e, t), F(n.key, e, t), F(n.value, e, t), void 0, he(n.span, t)); if (n instanceof Tr) {
    if (n.receiver instanceof rt)
        throw new Error("Unexpected ImplicitReceiver");
    return new Ie(F(n.receiver, e, t), n.args.map(s => F(s, e, t)), void 0, he(n.span, t));
}
else {
    if (n instanceof Ze)
        return d(n.value, void 0, he(n.span, t));
    if (n instanceof Ar)
        switch (n.operator) {
            case "+": return new hn(ws.Plus, F(n.expr, e, t), void 0, he(n.span, t));
            case "-": return new hn(ws.Minus, F(n.expr, e, t), void 0, he(n.span, t));
            default: throw new Error(`AssertionError: unknown unary operator ${n.operator}`);
        }
    else if (n instanceof ut) {
        let s = Rg.get(n.operation);
        if (s === void 0)
            throw new Error(`AssertionError: unknown binary operator ${n.operation}`);
        return new W(s, F(n.left, e, t), F(n.right, e, t), void 0, he(n.span, t));
    }
    else {
        if (n instanceof zn)
            return new Gt(e.root.xref);
        if (n instanceof Cr)
            return new It(F(n.receiver, e, t), F(n.key, e, t), void 0, he(n.span, t));
        if (n instanceof As)
            throw new Error("AssertionError: Chain in unknown context");
        if (n instanceof Fi) {
            let s = n.keys.map((r, i) => { let o = n.values[i]; return new Un(r.key, F(o, e, t), r.quoted); });
            return new gt(s, void 0, he(n.span, t));
        }
        else {
            if (n instanceof Ri)
                return new at(n.expressions.map(s => F(s, e, t)));
            if (n instanceof Ni)
                return new kt(F(n.condition, e, t), F(n.trueExp, e, t), F(n.falseExp, e, t), void 0, he(n.span, t));
            if (n instanceof _r)
                return F(n.expression, e, t);
            if (n instanceof Mi)
                return new Ds(e.allocateXrefId(), new Re(), n.name, [F(n.exp, e, t), ...n.args.map(s => F(s, e, t))]);
            if (n instanceof Li)
                return new Ls(F(n.receiver, e, t), F(n.key, e, t), he(n.span, t));
            if (n instanceof Pi)
                return new Ps(F(n.receiver, e, t), n.name);
            if (n instanceof Vi)
                return new Kn(F(n.receiver, e, t), n.args.map(s => F(s, e, t)));
            if (n instanceof Ne)
                return new zr(he(n.span, t));
            if (n instanceof $i)
                return qp(F(n.expression, e, t), he(n.span, t));
            if (n instanceof Oi)
                return Vs(F(n.expression, e, t));
            if (n instanceof br)
                return new xs(n.elements.map(s => new gr(s.text, he(s.span, t))), n.expressions.map(s => F(s, e, t)), he(n.span, t));
            throw new Error(`Unhandled expression type "${n.constructor.name}" in file "${t?.start.file.url}"`);
        }
    }
} }
function Ll(n, e, t, s) { let r; return e instanceof ii ? r = new le(e.strings, e.expressions.map(i => F(i, n, null)), Object.keys(qt(t)?.placeholders ?? {})) : e instanceof re ? r = F(e, n, null) : r = d(e), r; }
var af = new Map([[K.Property, I.Property], [K.TwoWay, I.TwoWayProperty], [K.Attribute, I.Attribute], [K.Class, I.ClassName], [K.Style, I.StyleProperty], [K.Animation, I.Animation]]);
function qS(n) { return vt(n.tagName ?? "")[1] === $n; }
function qt(n) { if (n == null)
    return null; if (!(n instanceof Ae))
    throw Error(`Expected i18n meta to be a Message, but got: ${n.constructor.name}`); return n; }
function HS(n, e, t) { let s = new Array, r = new Set; for (let i of t.attributes) {
    let o = Fn.securityContext(t.name, i.name, !0);
    s.push(Zn(e.xref, I.Attribute, i.name, Ll(n.job, i.value, i.i18n), null, o, !0, !1, null, qt(i.i18n), i.sourceSpan)), i.i18n && r.add(i.name);
} for (let i of t.inputs)
    r.has(i.name) && console.error(`On component ${n.job.componentName}, the binding ${i.name} is both an i18n attribute and a property. You may want to remove the property binding. This will become a compilation error in future versions of Angular.`), s.push(Zn(e.xref, af.get(i.type), i.name, Ll(n.job, ei(i.value), i.i18n), i.unit, i.securityContext, !1, !1, null, qt(i.i18n) ?? null, i.sourceSpan)); n.create.push(s.filter(i => i?.kind === c.ExtractedAttribute)), n.update.push(s.filter(i => i?.kind === c.Binding)); for (let i of t.outputs) {
    if (i.type === it.Animation && i.phase === null)
        throw Error("Animation listener should have a phase");
    i.type === it.TwoWay ? n.create.push(Nh(e.xref, e.handle, i.name, e.tag, lf(n, i.handler, i.handlerSpan), i.sourceSpan)) : n.create.push(Du(e.xref, e.handle, i.name, e.tag, Mu(n, i.handler, i.handlerSpan), i.phase, i.target, !1, i.sourceSpan));
} s.some(i => i?.i18nMessage) !== null && n.create.push(Ph(n.job.allocateXrefId(), new Re, e.xref)); }
function US(n, e, t, s) { let r = new Array; for (let i of t.templateAttrs)
    if (i instanceof Ts) {
        let o = Fn.securityContext($n, i.name, !0);
        r.push(wi(n, e.xref, K.Attribute, i.name, i.value, null, o, !0, s, qt(i.i18n), i.sourceSpan));
    }
    else
        r.push(wi(n, e.xref, i.type, i.name, ei(i.value), i.unit, i.securityContext, !0, s, qt(i.i18n), i.sourceSpan)); for (let i of t.attributes) {
    let o = Fn.securityContext($n, i.name, !0);
    r.push(wi(n, e.xref, K.Attribute, i.name, i.value, null, o, !1, s, qt(i.i18n), i.sourceSpan));
} for (let i of t.inputs)
    r.push(wi(n, e.xref, i.type, i.name, ei(i.value), i.unit, i.securityContext, !1, s, qt(i.i18n), i.sourceSpan)); n.create.push(r.filter(i => i?.kind === c.ExtractedAttribute)), n.update.push(r.filter(i => i?.kind === c.Binding)); for (let i of t.outputs) {
    if (i.type === it.Animation && i.phase === null)
        throw Error("Animation listener should have a phase");
    if (s === je.NgTemplate && (i.type === it.TwoWay ? n.create.push(Nh(e.xref, e.handle, i.name, e.tag, lf(n, i.handler, i.handlerSpan), i.sourceSpan)) : n.create.push(Du(e.xref, e.handle, i.name, e.tag, Mu(n, i.handler, i.handlerSpan), i.phase, i.target, !1, i.sourceSpan))), s === je.Structural && i.type !== it.Animation) {
        let o = Fn.securityContext($n, i.name, !1);
        n.create.push(nt(e.xref, I.Property, null, i.name, null, null, null, o));
    }
} r.some(i => i?.i18nMessage) !== null && n.create.push(Ph(n.job.allocateXrefId(), new Re, e.xref)); }
function wi(n, e, t, s, r, i, o, a, l, u, p) { let f = typeof r == "string"; if (l === je.Structural) {
    if (!a)
        switch (t) {
            case K.Property:
            case K.Class:
            case K.Style: return nt(e, I.Property, null, s, null, null, u, o);
            case K.TwoWay: return nt(e, I.TwoWayProperty, null, s, null, null, u, o);
        }
    if (!f && (t === K.Attribute || t === K.Animation))
        return null;
} let g = af.get(t); return l === je.NgTemplate && (t === K.Class || t === K.Style || t === K.Attribute && !f) && (g = I.Property), Zn(e, g, s, Ll(n.job, r, u), i, o, f, a, l, u, p); }
function Mu(n, e, t) { e = ei(e); let s = new Array, r = e instanceof As ? e.expressions : [e]; if (r.length === 0)
    throw new Error("Expected listener to have non-empty expression list."); let i = r.map(a => F(a, n.job, t)), o = i.pop(); return s.push(...i.map(a => wt(new Ge(a, a.sourceSpan)))), s.push(wt(new ye(o, o.sourceSpan))), s; }
function lf(n, e, t) { e = ei(e); let s = new Array; if (e instanceof As)
    if (e.expressions.length === 1)
        e = e.expressions[0];
    else
        throw new Error("Expected two-way listener to have a single expression."); let r = F(e, n.job, t), i = new xe("$event"), o = new lo(r, i); return s.push(wt(new Ge(o))), s.push(wt(new ye(i))), s; }
function ei(n) { return n instanceof Ke ? n.ast : n; }
function uf(n, e) { WS(n.localRefs); for (let { name: t, value: s } of e.references)
    n.localRefs.push({ name: t, target: s }); }
function WS(n) { if (!Array.isArray(n))
    throw new Error("AssertionError: expected an array"); }
function he(n, e) { if (e === null)
    return null; let t = e.start.moveBy(n.start), s = e.start.moveBy(n.end), r = e.fullStart.moveBy(n.start); return new R(t, s, r); }
function ko(n, e, t) { let s = null; for (let r of t.children)
    if (!(r instanceof Ho || r instanceof vu)) {
        if (s !== null)
            return null;
        if (r instanceof Nt || r instanceof Ue && r.tagName !== null)
            s = r;
        else
            return null;
    } if (s !== null) {
    for (let i of s.attributes) {
        let o = Fn.securityContext($n, i.name, !0);
        n.update.push(Zn(e, I.Attribute, i.name, d(i.value), null, o, !0, !1, null, qt(i.i18n), i.sourceSpan));
    }
    for (let i of s.inputs)
        if (i.type !== K.Animation && i.type !== K.Attribute) {
            let o = Fn.securityContext($n, i.name, !0);
            n.create.push(nt(e, I.Property, null, i.name, null, null, null, o));
        }
    let r = s instanceof Nt ? s.name : s.tagName;
    return r === $n ? null : r;
} return null; }
var cf = !1;
function KC(n) { cf = n; }
function jS() { return cf; }
function Io(n, e) { return ri(N(Cu).bitwiseAnd(d(n), null, !1), e); }
function zS(n) { return (n.descendants ? 1 : 0) | (n.static ? 2 : 0) | (n.emitDistinctChangesOnly ? 4 : 0); }
function GS(n, e) { if (Array.isArray(n.predicate)) {
    let t = [];
    return n.predicate.forEach(s => { let r = s.split(",").map(i => d(i.trim())); t.push(...r); }), e.getConstLiteral(B(t), !0);
}
else
    switch (n.predicate.forwardRef) {
        case 0:
        case 2: return n.predicate.expression;
        case 1: return y(h.resolveForwardRef).callFn([n.predicate.expression]);
    } }
function pf(n, e, t, s) { let r = []; s !== void 0 && r.push(...s), n.isSignal && r.push(new Me(N(Rr), n.propertyName)), r.push(GS(n, e), d(zS(n))), n.read && r.push(n.read); let i = n.isSignal ? t.signalBased : t.nonSignal; return y(i).callFn(r); }
var Ru = Symbol("queryAdvancePlaceholder");
function hf(n) { let e = [], t = 0, s = () => { t > 0 && (e.unshift(y(h.queryAdvance).callFn(t === 1 ? [] : [d(t)]).toStmt()), t = 0); }; for (let r = n.length - 1; r >= 0; r--) {
    let i = n[r];
    i === Ru ? t++ : (s(), e.unshift(i));
} return s(), e; }
function XS(n, e, t) { let s = [], r = [], i = eh(a => r.push(a), yu); n.forEach(a => { let l = pf(a, e, { signalBased: h.viewQuerySignal, nonSignal: h.viewQuery }); if (s.push(l.toStmt()), a.isSignal) {
    r.push(Ru);
    return;
} let u = i(), p = y(h.loadQuery).callFn([]), f = y(h.queryRefresh).callFn([u.set(p)]), g = N(Rr).prop(a.propertyName).set(a.first ? u.prop("first") : u); r.push(f.and(g).toStmt()); }); let o = t ? `${t}_Query` : null; return zt([new Y(Cu, Oo), new Y(Rr, null)], [Io(1, s), Io(2, hf(r))], Ve, null, o); }
function YS(n, e, t) { let s = [], r = [], i = eh(a => r.push(a), yu); for (let a of n) {
    if (s.push(pf(a, e, { nonSignal: h.contentQuery, signalBased: h.contentQuerySignal }, [N("dirIndex")]).toStmt()), a.isSignal) {
        r.push(Ru);
        continue;
    }
    let l = i(), u = y(h.loadQuery).callFn([]), p = y(h.queryRefresh).callFn([l.set(u)]), f = N(Rr).prop(a.propertyName).set(a.first ? l.prop("first") : l);
    r.push(p.and(f).toStmt());
} let o = t ? `${t}_ContentQueries` : null; return zt([new Y(Cu, Oo), new Y(Rr, null), new Y("dirIndex", null)], [Io(1, s), Io(2, hf(r))], Ve, null, o); }
var No = class extends $h {
    constructor() { super(jh); }
    parse(e, t, s) { return super.parse(e, t, s); }
}, ep = ".", QS = "attr", ZS = "class", JS = "style", KS = "*", pa = "animate-", Bl = class {
    _exprParser;
    _interpolationConfig;
    _schemaRegistry;
    errors;
    constructor(e, t, s, r) { this._exprParser = e, this._interpolationConfig = t, this._schemaRegistry = s, this.errors = r; }
    get interpolationConfig() { return this._interpolationConfig; }
    createBoundHostProperties(e, t) { let s = []; for (let r of Object.keys(e)) {
        let i = e[r];
        typeof i == "string" ? this.parsePropertyBinding(r, i, !0, !1, t, t.start.offset, void 0, [], s, t) : this._reportError(`Value of the host property binding "${r}" needs to be a string representing an expression but got "${i}" (${typeof i})`, t);
    } return s; }
    createDirectiveHostEventAsts(e, t) { let s = []; for (let r of Object.keys(e)) {
        let i = e[r];
        typeof i == "string" ? this.parseEvent(r, i, !1, t, t, [], s, t) : this._reportError(`Value of the host listener "${r}" needs to be a string representing an expression but got "${i}" (${typeof i})`, t);
    } return s; }
    parseInterpolation(e, t, s) { let r = t.start.toString(), i = t.fullStart.offset; try {
        let o = this._exprParser.parseInterpolation(e, r, i, s, this._interpolationConfig);
        return o && this._reportExpressionParserErrors(o.errors, t), o;
    }
    catch (o) {
        return this._reportError(`${o}`, t), this._exprParser.wrapLiteralPrimitive("ERROR", r, i);
    } }
    parseInterpolationExpression(e, t) { let s = t.start.toString(), r = t.start.offset; try {
        let i = this._exprParser.parseInterpolationExpression(e, s, r);
        return i && this._reportExpressionParserErrors(i.errors, t), i;
    }
    catch (i) {
        return this._reportError(`${i}`, t), this._exprParser.wrapLiteralPrimitive("ERROR", s, r);
    } }
    parseInlineTemplateBinding(e, t, s, r, i, o, a, l) { let u = s.start.offset + KS.length, p = this._parseTemplateBindings(e, t, s, u, r); for (let f of p) {
        let g = Zt(s, f.sourceSpan), v = f.key.source, S = Zt(s, f.key.span);
        if (f instanceof kr) {
            let _ = f.value ? f.value.source : "$implicit", x = f.value ? Zt(s, f.value.span) : void 0;
            a.push(new Ra(v, _, g, S, x));
        }
        else if (f.value) {
            let _ = l ? g : s, x = Zt(s, f.value.ast.sourceSpan);
            this._parsePropertyAst(v, f.value, !1, _, S, x, i, o);
        }
        else
            i.push([v, ""]), this.parseLiteralAttr(v, null, S, r, void 0, i, o, S);
    } }
    _parseTemplateBindings(e, t, s, r, i) { let o = s.start.toString(); try {
        let a = this._exprParser.parseTemplateBindings(e, t, o, r, i);
        return this._reportExpressionParserErrors(a.errors, s), a.warnings.forEach(l => { this._reportError(l, s, an.WARNING); }), a.templateBindings;
    }
    catch (a) {
        return this._reportError(`${a}`, s), [];
    } }
    parseLiteralAttr(e, t, s, r, i, o, a, l) { ha(e) ? (e = e.substring(1), l !== void 0 && (l = Zt(l, new qe(l.start.offset + 1, l.end.offset))), t && this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid. Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", s, an.ERROR), this._parseAnimation(e, t, s, r, l, i, o, a)) : a.push(new ir(e, this._exprParser.wrapLiteralPrimitive(t, "", r), sn.LITERAL_ATTR, s, l, i)); }
    parsePropertyBinding(e, t, s, r, i, o, a, l, u, p) { e.length === 0 && this._reportError("Property name is missing in binding", i); let f = !1; e.startsWith(pa) ? (f = !0, e = e.substring(pa.length), p !== void 0 && (p = Zt(p, new qe(p.start.offset + pa.length, p.end.offset)))) : ha(e) && (f = !0, e = e.substring(1), p !== void 0 && (p = Zt(p, new qe(p.start.offset + 1, p.end.offset)))), f ? this._parseAnimation(e, t, i, o, p, a, l, u) : this._parsePropertyAst(e, this.parseBinding(t, s, a || i, o), r, i, p, a, l, u); }
    parsePropertyInterpolation(e, t, s, r, i, o, a, l) { let u = this.parseInterpolation(t, r || s, l); return u ? (this._parsePropertyAst(e, u, !1, s, a, r, i, o), !0) : !1; }
    _parsePropertyAst(e, t, s, r, i, o, a, l) { a.push([e, t.source]), l.push(new ir(e, t, s ? sn.TWO_WAY : sn.DEFAULT, r, i, o)); }
    _parseAnimation(e, t, s, r, i, o, a, l) { e.length === 0 && this._reportError("Animation trigger is missing", s); let u = this.parseBinding(t || "undefined", !1, o || s, r); a.push([e, u.source]), l.push(new ir(e, u, sn.ANIMATION, s, i, o)); }
    parseBinding(e, t, s, r) { let i = (s && s.start || "(unknown)").toString(); try {
        let o = t ? this._exprParser.parseSimpleBinding(e, i, r, this._interpolationConfig) : this._exprParser.parseBinding(e, i, r, this._interpolationConfig);
        return o && this._reportExpressionParserErrors(o.errors, s), o;
    }
    catch (o) {
        return this._reportError(`${o}`, s), this._exprParser.wrapLiteralPrimitive("ERROR", i, r);
    } }
    createBoundElementProperty(e, t, s = !1, r = !0) { if (t.isAnimation)
        return new Wi(t.name, K.Animation, ee.NONE, t.expression, null, t.sourceSpan, t.keySpan, t.valueSpan); let i = null, o, a = null, l = t.name.split(ep), u; if (l.length > 1)
        if (l[0] == QS) {
            a = l.slice(1).join(ep), s || this._validatePropertyOrAttributeName(a, t.sourceSpan, !0), u = fa(this._schemaRegistry, e, a, !0);
            let p = a.indexOf(":");
            if (p > -1) {
                let f = a.substring(0, p), g = a.substring(p + 1);
                a = Oa(f, g);
            }
            o = K.Attribute;
        }
        else
            l[0] == ZS ? (a = l[1], o = K.Class, u = [ee.NONE]) : l[0] == JS && (i = l.length > 2 ? l[2] : null, a = l[1], o = K.Style, u = [ee.STYLE]); if (a === null) {
        let p = this._schemaRegistry.getMappedPropName(t.name);
        a = r ? p : t.name, u = fa(this._schemaRegistry, e, p, !1), o = t.type === sn.TWO_WAY ? K.TwoWay : K.Property, s || this._validatePropertyOrAttributeName(p, t.sourceSpan, !1);
    } return new Wi(a, o, u[0], t.expression, i, t.sourceSpan, t.keySpan, t.valueSpan); }
    parseEvent(e, t, s, r, i, o, a, l) { e.length === 0 && this._reportError("Event name is missing in binding", r), ha(e) ? (e = e.slice(1), l !== void 0 && (l = Zt(l, new qe(l.start.offset + 1, l.end.offset))), this._parseAnimationEvent(e, t, r, i, a, l)) : this._parseRegularEvent(e, t, s, r, i, o, a, l); }
    calcPossibleSecurityContexts(e, t, s) { let r = this._schemaRegistry.getMappedPropName(t); return fa(this._schemaRegistry, e, r, s); }
    _parseAnimationEvent(e, t, s, r, i, o) { let a = vd(e, [e, ""]), l = a[0], u = a[1].toLowerCase(), p = this._parseAction(t, r); i.push(new Ui(l, u, it.Animation, p, s, r, o)), l.length === 0 && this._reportError("Animation event name is missing in binding", s), u ? u !== "start" && u !== "done" && this._reportError(`The provided animation output phase value "${u}" for "@${l}" is not supported (use start or done)`, s) : this._reportError(`The animation trigger output event (@${l}) is missing its phase value name (start or done are currently supported)`, s); }
    _parseRegularEvent(e, t, s, r, i, o, a, l) { let [u, p] = gd(e, [null, e]), f = this.errors.length, g = this._parseAction(t, i), v = this.errors.length === f; o.push([e, g.source]), s && v && !this._isAllowedAssignmentEvent(g) && this._reportError("Unsupported expression in a two-way binding", r), a.push(new Ui(p, u, s ? it.TwoWay : it.Regular, g, r, i, l)); }
    _parseAction(e, t) { let s = (t && t.start || "(unknown").toString(), r = t && t.start ? t.start.offset : 0; try {
        let i = this._exprParser.parseAction(e, s, r, this._interpolationConfig);
        return i && this._reportExpressionParserErrors(i.errors, t), !i || i.ast instanceof Ne ? (this._reportError("Empty expressions are not allowed", t), this._exprParser.wrapLiteralPrimitive("ERROR", s, r)) : i;
    }
    catch (i) {
        return this._reportError(`${i}`, t), this._exprParser.wrapLiteralPrimitive("ERROR", s, r);
    } }
    _reportError(e, t, s = an.ERROR, r) { this.errors.push(new L(t, e, s, r)); }
    _reportExpressionParserErrors(e, t) { for (let s of e)
        this._reportError(s.message, t, void 0, s); }
    _validatePropertyOrAttributeName(e, t, s) { let r = s ? this._schemaRegistry.validateAttribute(e) : this._schemaRegistry.validateProperty(e); r.error && this._reportError(r.msg, t, an.ERROR); }
    _isAllowedAssignmentEvent(e) { return e instanceof Ke ? this._isAllowedAssignmentEvent(e.ast) : e instanceof _r ? this._isAllowedAssignmentEvent(e.expression) : e instanceof Tr && e.args.length === 1 && e.receiver instanceof Gn && e.receiver.name === "$any" && e.receiver.receiver instanceof rt && !(e.receiver.receiver instanceof zn) ? this._isAllowedAssignmentEvent(e.args[0]) : e instanceof Gn || e instanceof Cr; }
};
function ha(n) { return n[0] == "@"; }
function fa(n, e, t, s) { let r = []; return On.parse(e).forEach(i => { let o = i.element ? [i.element] : n.allKnownElementNames(), a = new Set(i.notSelectors.filter(u => u.isElementSelector()).map(u => u.element)), l = o.filter(u => !a.has(u)); r.push(...l.map(u => n.securityContext(u, t, s))); }), r.length === 0 ? [ee.NONE] : Array.from(new Set(r)).sort(); }
function Zt(n, e) { let t = e.start - n.start.offset, s = e.end - n.end.offset; return new R(n.start.moveBy(t), n.end.moveBy(s), n.fullStart.moveBy(t), n.details); }
function ex(n) { if (n == null || n.length === 0 || n[0] == "/")
    return !1; let e = n.match(tx); return e === null || e[1] == "package" || e[1] == "asset"; }
var tx = /^([^:/?#]+):/, nx = "select", sx = "link", rx = "rel", ix = "href", ox = "stylesheet", ax = "style", lx = "script", ux = "ngNonBindable", cx = "ngProjectAs";
function ff(n) { let e = null, t = null, s = null, r = !1, i = ""; n.attrs.forEach(l => { let u = l.name.toLowerCase(); u == nx ? e = l.value : u == ix ? t = l.value : u == rx ? s = l.value : l.name == ux ? r = !0 : l.name == cx && l.value.length > 0 && (i = l.value); }), e = px(e); let o = n.name.toLowerCase(), a = Oe.OTHER; return Fa(o) ? a = Oe.NG_CONTENT : o == ax ? a = Oe.STYLE : o == lx ? a = Oe.SCRIPT : o == sx && s == ox && (a = Oe.STYLESHEET), new Ml(a, e, t, r, i); }
var Oe = function (n) { return n[n.NG_CONTENT = 0] = "NG_CONTENT", n[n.STYLE = 1] = "STYLE", n[n.STYLESHEET = 2] = "STYLESHEET", n[n.SCRIPT = 3] = "SCRIPT", n[n.OTHER = 4] = "OTHER", n; }(Oe || {}), Ml = class {
    type;
    selectAttr;
    hrefAttr;
    nonBindable;
    projectAs;
    constructor(e, t, s, r, i) { this.type = e, this.selectAttr = t, this.hrefAttr = s, this.nonBindable = r, this.projectAs = i; }
};
function px(n) { return n === null || n.length === 0 ? "*" : n; }
var hx = /^\s*([0-9A-Za-z_$]*)\s+of\s+([\S\s]*)/, fx = /^track\s+([\S\s]*)/, dx = /^(as\s+)(.*)/, Fu = /^else[^\S\r\n]+if/, mx = /^let\s+([\S\s]*)/, gx = /^[$A-Z_][0-9A-Z_$]*$/i, tp = /(\s*)(\S+)(\s*)/, hr = new Set(["$index", "$first", "$last", "$even", "$odd", "$count"]);
function np(n) { return n === "empty"; }
function sp(n) { return n === "else" || Fu.test(n); }
function vx(n, e, t, s) { let r = yx(e), i = [], o = rp(n, r, s); o !== null && i.push(new Ln(o.expression, D(t, n.children, n.children), o.expressionAlias, n.sourceSpan, n.startSourceSpan, n.endSourceSpan, n.nameSpan, n.i18n)); for (let f of e)
    if (Fu.test(f.name)) {
        let g = rp(f, r, s);
        if (g !== null) {
            let v = D(t, f.children, f.children);
            i.push(new Ln(g.expression, v, g.expressionAlias, f.sourceSpan, f.startSourceSpan, f.endSourceSpan, f.nameSpan, f.i18n));
        }
    }
    else if (f.name === "else") {
        let g = D(t, f.children, f.children);
        i.push(new Ln(null, g, null, f.sourceSpan, f.startSourceSpan, f.endSourceSpan, f.nameSpan, f.i18n));
    } let a = i.length > 0 ? i[0].startSourceSpan : n.startSourceSpan, l = i.length > 0 ? i[i.length - 1].endSourceSpan : n.endSourceSpan, u = n.sourceSpan, p = i[i.length - 1]; return p !== void 0 && (u = new R(a.start, p.sourceSpan.end)), { node: new Yi(i, u, n.startSourceSpan, l, n.nameSpan), errors: r }; }
function wx(n, e, t, s) { let r = [], i = Sx(n, r, s), o = null, a = null; for (let l of e)
    l.name === "empty" ? a !== null ? r.push(new L(l.sourceSpan, "@for loop can only have one @empty block")) : l.parameters.length > 0 ? r.push(new L(l.sourceSpan, "@empty block cannot have parameters")) : a = new Lr(D(t, l.children, l.children), l.sourceSpan, l.startSourceSpan, l.endSourceSpan, l.nameSpan, l.i18n) : r.push(new L(l.sourceSpan, `Unrecognized @for loop block "${l.name}"`)); if (i !== null)
    if (i.trackBy === null)
        r.push(new L(n.startSourceSpan, "@for loop must have a \"track\" expression"));
    else {
        let l = a?.endSourceSpan ?? n.endSourceSpan, u = new R(n.sourceSpan.start, l?.end ?? n.sourceSpan.end);
        o = new bs(i.itemName, i.expression, i.trackBy.expression, i.trackBy.keywordSpan, i.context, D(t, n.children, n.children), a, u, n.sourceSpan, n.startSourceSpan, l, n.nameSpan, n.i18n);
    } return { node: o, errors: r }; }
function Ex(n, e, t) { let s = Cx(n), r = n.parameters.length > 0 ? ti(n.parameters[0], t) : t.parseBinding("", !1, n.sourceSpan, 0), i = [], o = [], a = null; for (let l of n.children) {
    if (!(l instanceof Je))
        continue;
    if ((l.name !== "case" || l.parameters.length === 0) && l.name !== "default") {
        o.push(new Qi(l.name, l.sourceSpan, l.nameSpan));
        continue;
    }
    let u = l.name === "case" ? ti(l.parameters[0], t) : null, p = new Pr(u, D(e, l.children, l.children), l.sourceSpan, l.startSourceSpan, l.endSourceSpan, l.nameSpan, l.i18n);
    u === null ? a = p : i.push(p);
} return a !== null && i.push(a), { node: new Xi(r, i, o, n.sourceSpan, n.startSourceSpan, n.endSourceSpan, n.nameSpan), errors: s }; }
function Sx(n, e, t) { if (n.parameters.length === 0)
    return e.push(new L(n.startSourceSpan, "@for loop does not have an expression")), null; let [s, ...r] = n.parameters, i = Ax(s, e)?.match(hx); if (!i || i[2].trim().length === 0)
    return e.push(new L(s.sourceSpan, "Cannot parse expression. @for loop expression must match the pattern \"<identifier> of <expression>\"")), null; let [, o, a] = i; hr.has(o) && e.push(new L(s.sourceSpan, `@for loop item name cannot be one of ${Array.from(hr).join(", ")}.`)); let l = s.expression.split(" ")[0], u = new R(s.sourceSpan.start, s.sourceSpan.start.moveBy(l.length)), p = { itemName: new mn(o, "$implicit", u, u), trackBy: null, expression: ti(s, t, a), context: Array.from(hr, f => { let g = new R(n.startSourceSpan.end, n.startSourceSpan.end); return new mn(f, f, g, g); }) }; for (let f of r) {
    let g = f.expression.match(mx);
    if (g !== null) {
        let S = new R(f.sourceSpan.start.moveBy(g[0].length - g[1].length), f.sourceSpan.end);
        xx(f.sourceSpan, g[1], S, o, p.context, e);
        continue;
    }
    let v = f.expression.match(fx);
    if (v !== null) {
        if (p.trackBy !== null)
            e.push(new L(f.sourceSpan, "@for loop can only have one \"track\" expression"));
        else {
            let S = ti(f, t, v[1]);
            S.ast instanceof Ne && e.push(new L(n.startSourceSpan, "@for loop must have a \"track\" expression"));
            let _ = new R(f.sourceSpan.start, f.sourceSpan.start.moveBy(5));
            p.trackBy = { expression: S, keywordSpan: _ };
        }
        continue;
    }
    e.push(new L(f.sourceSpan, `Unrecognized @for loop parameter "${f.expression}"`));
} return p; }
function xx(n, e, t, s, r, i) { let o = e.split(","), a = t.start; for (let l of o) {
    let u = l.split("="), p = u.length === 2 ? u[0].trim() : "", f = u.length === 2 ? u[1].trim() : "";
    if (p.length === 0 || f.length === 0)
        i.push(new L(n, "Invalid @for loop \"let\" parameter. Parameter should match the pattern \"<name> = <variable name>\""));
    else if (!hr.has(f))
        i.push(new L(n, `Unknown "let" parameter variable "${f}". The allowed variables are: ${Array.from(hr).join(", ")}`));
    else if (p === s)
        i.push(new L(n, `Invalid @for loop "let" parameter. Variable cannot be called "${s}"`));
    else if (r.some(g => g.name === p))
        i.push(new L(n, `Duplicate "let" parameter variable "${f}"`));
    else {
        let [, g, v] = u[0].match(tp) ?? [], S = g !== void 0 && u.length === 2 ? new R(a.moveBy(g.length), a.moveBy(g.length + v.length)) : t, _;
        if (u.length === 2) {
            let [, T, M] = u[1].match(tp) ?? [];
            _ = T !== void 0 ? new R(a.moveBy(u[0].length + 1 + T.length), a.moveBy(u[0].length + 1 + T.length + M.length)) : void 0;
        }
        let x = new R(S.start, _?.end ?? S.end);
        r.push(new mn(p, f, x, S, _));
    }
    a = a.moveBy(l.length + 1);
} }
function yx(n) { let e = [], t = !1; for (let s = 0; s < n.length; s++) {
    let r = n[s];
    r.name === "else" ? (t ? e.push(new L(r.startSourceSpan, "Conditional can only have one @else block")) : n.length > 1 && s < n.length - 1 ? e.push(new L(r.startSourceSpan, "@else block must be last inside the conditional")) : r.parameters.length > 0 && e.push(new L(r.startSourceSpan, "@else block cannot have parameters")), t = !0) : Fu.test(r.name) || e.push(new L(r.startSourceSpan, `Unrecognized conditional block @${r.name}`));
} return e; }
function Cx(n) { let e = [], t = !1; if (n.parameters.length !== 1)
    return e.push(new L(n.startSourceSpan, "@switch block must have exactly one parameter")), e; for (let s of n.children)
    if (!(s instanceof Sn || s instanceof Yt && s.value.trim().length === 0)) {
        if (!(s instanceof Je) || s.name !== "case" && s.name !== "default") {
            e.push(new L(s.sourceSpan, "@switch block can only contain @case and @default blocks"));
            continue;
        }
        s.name === "default" ? (t ? e.push(new L(s.startSourceSpan, "@switch block can only have one @default block")) : s.parameters.length > 0 && e.push(new L(s.startSourceSpan, "@default block cannot have parameters")), t = !0) : s.name === "case" && s.parameters.length !== 1 && e.push(new L(s.startSourceSpan, "@case block must have exactly one parameter"));
    } return e; }
function ti(n, e, t) { let s, r; return typeof t == "string" ? (s = Math.max(0, n.expression.lastIndexOf(t)), r = s + t.length) : (s = 0, r = n.expression.length), e.parseBinding(n.expression.slice(s, r), !1, n.sourceSpan, n.sourceSpan.start.offset + s); }
function rp(n, e, t) { if (n.parameters.length === 0)
    return e.push(new L(n.startSourceSpan, "Conditional block does not have an expression")), null; let s = ti(n.parameters[0], t), r = null; for (let i = 1; i < n.parameters.length; i++) {
    let o = n.parameters[i], a = o.expression.match(dx);
    if (a === null)
        e.push(new L(o.sourceSpan, `Unrecognized conditional parameter "${o.expression}"`));
    else if (n.name !== "if")
        e.push(new L(o.sourceSpan, "\"as\" expression is only allowed on the primary @if block"));
    else if (r !== null)
        e.push(new L(o.sourceSpan, "Conditional can only have one \"as\" expression"));
    else {
        let l = a[2].trim();
        if (gx.test(l)) {
            let u = o.sourceSpan.start.moveBy(a[1].length), p = new R(u, u.moveBy(l.length));
            r = new mn(l, l, p, p);
        }
        else
            e.push(new L(o.sourceSpan, "\"as\" expression must be a valid JavaScript identifier"));
    }
} return { expression: s, expressionAlias: r }; }
function Ax(n, e) { let t = n.expression, s = /^\s$/, r = 0, i = 0, o = t.length - 1; for (let a = 0; a < t.length; a++) {
    let l = t[a];
    if (l === "(")
        i = a + 1, r++;
    else {
        if (s.test(l))
            continue;
        break;
    }
} if (r === 0)
    return t; for (let a = t.length - 1; a > -1; a--) {
    let l = t[a];
    if (l === ")") {
        if (o = a, r--, r === 0)
            break;
    }
    else {
        if (s.test(l))
            continue;
        break;
    }
} return r !== 0 ? (e.push(new L(n.sourceSpan, "Unclosed parentheses in expression")), null) : t.slice(i, o); }
var _x = /^\d+\.?\d*(ms|s)?$/, Tx = /^\s$/, ip = new Map([[pt, Pe], [ms, ps], [Ut, ft]]), Le = function (n) { return n.IDLE = "idle", n.TIMER = "timer", n.INTERACTION = "interaction", n.IMMEDIATE = "immediate", n.HOVER = "hover", n.VIEWPORT = "viewport", n.NEVER = "never", n; }(Le || {});
function bx({ expression: n, sourceSpan: e }, t, s) { let r = n.indexOf("never"), i = new R(e.start.moveBy(r), e.start.moveBy(r + 5)), o = $u(n, e), a = Ou(n, e); r === -1 ? s.push(new L(e, "Could not find \"never\" keyword in expression")) : Vu("never", t, s, new Ua(i, e, o, null, a)); }
function da({ expression: n, sourceSpan: e }, t, s, r) { let i = n.indexOf("when"), o = new R(e.start.moveBy(i), e.start.moveBy(i + 4)), a = $u(n, e), l = Ou(n, e); if (i === -1)
    r.push(new L(e, "Could not find \"when\" keyword in expression"));
else {
    let u = ni(n, i + 1), p = t.parseBinding(n.slice(u), !1, e, e.start.offset + u);
    Vu("when", s, r, new Ha(p, e, a, o, l));
} }
function ma({ expression: n, sourceSpan: e }, t, s, r) { let i = n.indexOf("on"), o = new R(e.start.moveBy(i), e.start.moveBy(i + 2)), a = $u(n, e), l = Ou(n, e); if (i === -1)
    s.push(new L(e, "Could not find \"on\" keyword in expression"));
else {
    let u = ni(n, i + 1);
    new Rl(n, u, e, t, s, n.startsWith("hydrate") ? Mx : Bx, r, a, o, l).parse();
} }
function $u(n, e) { return n.startsWith("prefetch") ? new R(e.start, e.start.moveBy(8)) : null; }
function Ou(n, e) { return n.startsWith("hydrate") ? new R(e.start, e.start.moveBy(7)) : null; }
var Rl = class {
    expression;
    start;
    span;
    triggers;
    errors;
    validator;
    placeholder;
    prefetchSpan;
    onSourceSpan;
    hydrateSpan;
    index = 0;
    tokens;
    constructor(e, t, s, r, i, o, a, l, u, p) { this.expression = e, this.start = t, this.span = s, this.triggers = r, this.errors = i, this.validator = o, this.placeholder = a, this.prefetchSpan = l, this.onSourceSpan = u, this.hydrateSpan = p, this.tokens = new Kr().tokenize(e.slice(t)); }
    parse() { for (; this.tokens.length > 0 && this.index < this.tokens.length;) {
        let e = this.token();
        if (!e.isIdentifier()) {
            this.unexpectedToken(e);
            break;
        }
        if (this.isFollowedByOrLast(st))
            this.consumeTrigger(e, []), this.advance();
        else if (this.isFollowedByOrLast(Ut)) {
            this.advance();
            let t = this.errors.length, s = this.consumeParameters();
            if (this.errors.length !== t)
                break;
            this.consumeTrigger(e, s), this.advance();
        }
        else
            this.index < this.tokens.length - 1 && this.unexpectedToken(this.tokens[this.index + 1]);
        this.advance();
    } }
    advance() { this.index++; }
    isFollowedByOrLast(e) { return this.index === this.tokens.length - 1 ? !0 : this.tokens[this.index + 1].isCharacter(e); }
    token() { return this.tokens[Math.min(this.index, this.tokens.length - 1)]; }
    consumeTrigger(e, t) { let s = this.span.start.moveBy(this.start + e.index - this.tokens[0].index), r = new R(s, s.moveBy(e.strValue.length)), i = s.moveBy(this.token().end - e.index), o = e.index === 0, a = o ? this.onSourceSpan : null, l = o ? this.prefetchSpan : null, u = o ? this.hydrateSpan : null, p = new R(o ? this.span.start : s, i); try {
        switch (e.toString()) {
            case Le.IDLE:
                this.trackTrigger("idle", kx(t, r, p, l, a, u));
                break;
            case Le.TIMER:
                this.trackTrigger("timer", Ix(t, r, p, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));
                break;
            case Le.INTERACTION:
                this.trackTrigger("interaction", Px(t, r, p, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.placeholder, this.validator));
                break;
            case Le.IMMEDIATE:
                this.trackTrigger("immediate", Nx(t, r, p, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));
                break;
            case Le.HOVER:
                this.trackTrigger("hover", Dx(t, r, p, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.placeholder, this.validator));
                break;
            case Le.VIEWPORT:
                this.trackTrigger("viewport", Lx(t, r, p, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.placeholder, this.validator));
                break;
            default: throw new Error(`Unrecognized trigger type "${e}"`);
        }
    }
    catch (f) {
        this.error(e, f.message);
    } }
    consumeParameters() { let e = []; if (!this.token().isCharacter(Ut))
        return this.unexpectedToken(this.token()), e; this.advance(); let t = [], s = ""; for (; this.index < this.tokens.length;) {
        let r = this.token();
        if (r.isCharacter(ft) && t.length === 0) {
            s.length && e.push(s);
            break;
        }
        if (r.type === q.Character && ip.has(r.numValue) && t.push(ip.get(r.numValue)), t.length > 0 && r.isCharacter(t[t.length - 1]) && t.pop(), t.length === 0 && r.isCharacter(st) && s.length > 0) {
            e.push(s), s = "", this.advance();
            continue;
        }
        s += this.tokenText(), this.advance();
    } return (!this.token().isCharacter(ft) || t.length > 0) && this.error(this.token(), "Unexpected end of expression"), this.index < this.tokens.length - 1 && !this.tokens[this.index + 1].isCharacter(st) && this.unexpectedToken(this.tokens[this.index + 1]), e; }
    tokenText() { return this.expression.slice(this.start + this.token().index, this.start + this.token().end); }
    trackTrigger(e, t) { Vu(e, this.triggers, this.errors, t); }
    error(e, t) { let s = this.span.start.moveBy(this.start + e.index), r = s.moveBy(e.end - e.index); this.errors.push(new L(new R(s, r), t)); }
    unexpectedToken(e) { this.error(e, `Unexpected token "${e}"`); }
};
function Vu(n, e, t, s) { e[n] ? t.push(new L(s.sourceSpan, `Duplicate "${n}" trigger is not allowed`)) : e[n] = s; }
function kx(n, e, t, s, r, i) { if (n.length > 0)
    throw new Error(`"${Le.IDLE}" trigger cannot have parameters`); return new Wa(e, t, s, r, i); }
function Ix(n, e, t, s, r, i) { if (n.length !== 1)
    throw new Error(`"${Le.TIMER}" trigger must have exactly one parameter`); let o = Do(n[0]); if (o === null)
    throw new Error(`Could not parse time value of trigger "${Le.TIMER}"`); return new za(o, e, t, s, r, i); }
function Nx(n, e, t, s, r, i) { if (n.length > 0)
    throw new Error(`"${Le.IMMEDIATE}" trigger cannot have parameters`); return new ja(e, t, s, r, i); }
function Dx(n, e, t, s, r, i, o, a) { return a(Le.HOVER, n, o), new ji(n[0] ?? null, e, t, s, r, i); }
function Px(n, e, t, s, r, i, o, a) { return a(Le.INTERACTION, n, o), new zi(n[0] ?? null, e, t, s, r, i); }
function Lx(n, e, t, s, r, i, o, a) { return a(Le.VIEWPORT, n, o), new Gi(n[0] ?? null, e, t, s, r, i); }
function Bx(n, e, t) { if (e.length > 1)
    throw new Error(`"${n}" trigger can only have zero or one parameters`); if (e.length === 0) {
    if (t === null)
        throw new Error(`"${n}" trigger with no parameters can only be placed on an @defer that has a @placeholder block`);
    if (t.children.length !== 1 || !(t.children[0] instanceof Nt))
        throw new Error(`"${n}" trigger with no parameters can only be placed on an @defer that has a @placeholder block with exactly one root element node`);
} }
function Mx(n, e) { if (e.length > 0)
    throw new Error(`Hydration trigger "${n}" cannot have parameters`); }
function ni(n, e = 0) { let t = !1; for (let s = e; s < n.length; s++)
    if (Tx.test(n[s]))
        t = !0;
    else if (t)
        return s; return -1; }
function Do(n) { let e = n.match(_x); if (!e)
    return null; let [t, s] = e; return parseFloat(t) * (s === "s" ? 1e3 : 1); }
var Rx = /^prefetch\s+when\s/, Fx = /^prefetch\s+on\s/, $x = /^hydrate\s+when\s/, Ox = /^hydrate\s+on\s/, Vx = /^hydrate\s+never(\s*)$/, df = /^minimum\s/, qx = /^after\s/, Hx = /^when\s/, Ux = /^on\s/;
function Fl(n) { return n === "placeholder" || n === "loading" || n === "error"; }
function Wx(n, e, t, s) { let r = [], { placeholder: i, loading: o, error: a } = jx(e, r, t), { triggers: l, prefetchTriggers: u, hydrateTriggers: p } = Yx(n, s, r, i), f = n.endSourceSpan, g = n.sourceSpan.end; if (e.length > 0) {
    let _ = e[e.length - 1];
    f = _.endSourceSpan, g = _.sourceSpan.end;
} let v = new R(n.sourceSpan.start, g); return { node: new Xn(D(t, n.children, n.children), l, u, p, i, o, a, n.nameSpan, v, n.sourceSpan, n.startSourceSpan, f, n.i18n), errors: r }; }
function jx(n, e, t) { let s = null, r = null, i = null; for (let o of n)
    try {
        if (!Fl(o.name)) {
            e.push(new L(o.startSourceSpan, `Unrecognized block "@${o.name}"`));
            break;
        }
        switch (o.name) {
            case "placeholder":
                s !== null ? e.push(new L(o.startSourceSpan, "@defer block can only have one @placeholder block")) : s = zx(o, t);
                break;
            case "loading":
                r !== null ? e.push(new L(o.startSourceSpan, "@defer block can only have one @loading block")) : r = Gx(o, t);
                break;
            case "error":
                i !== null ? e.push(new L(o.startSourceSpan, "@defer block can only have one @error block")) : i = Xx(o, t);
                break;
        }
    }
    catch (a) {
        e.push(new L(o.startSourceSpan, a.message));
    } return { placeholder: s, loading: r, error: i }; }
function zx(n, e) { let t = null; for (let s of n.parameters)
    if (df.test(s.expression)) {
        if (t != null)
            throw new Error("@placeholder block can only have one \"minimum\" parameter");
        let r = Do(s.expression.slice(ni(s.expression)));
        if (r === null)
            throw new Error("Could not parse time value of parameter \"minimum\"");
        t = r;
    }
    else
        throw new Error(`Unrecognized parameter in @placeholder block: "${s.expression}"`); return new Ir(D(e, n.children, n.children), t, n.nameSpan, n.sourceSpan, n.startSourceSpan, n.endSourceSpan, n.i18n); }
function Gx(n, e) { let t = null, s = null; for (let r of n.parameters)
    if (qx.test(r.expression)) {
        if (t != null)
            throw new Error("@loading block can only have one \"after\" parameter");
        let i = Do(r.expression.slice(ni(r.expression)));
        if (i === null)
            throw new Error("Could not parse time value of parameter \"after\"");
        t = i;
    }
    else if (df.test(r.expression)) {
        if (s != null)
            throw new Error("@loading block can only have one \"minimum\" parameter");
        let i = Do(r.expression.slice(ni(r.expression)));
        if (i === null)
            throw new Error("Could not parse time value of parameter \"minimum\"");
        s = i;
    }
    else
        throw new Error(`Unrecognized parameter in @loading block: "${r.expression}"`); return new Nr(D(e, n.children, n.children), t, s, n.nameSpan, n.sourceSpan, n.startSourceSpan, n.endSourceSpan, n.i18n); }
function Xx(n, e) { if (n.parameters.length > 0)
    throw new Error("@error block cannot have parameters"); return new Dr(D(e, n.children, n.children), n.nameSpan, n.sourceSpan, n.startSourceSpan, n.endSourceSpan, n.i18n); }
function Yx(n, e, t, s) { let r = {}, i = {}, o = {}; for (let a of n.parameters)
    Hx.test(a.expression) ? da(a, e, r, t) : Ux.test(a.expression) ? ma(a, r, t, s) : Rx.test(a.expression) ? da(a, e, i, t) : Fx.test(a.expression) ? ma(a, i, t, s) : $x.test(a.expression) ? da(a, e, o, t) : Ox.test(a.expression) ? ma(a, o, t, s) : Vx.test(a.expression) ? bx(a, o, t) : t.push(new L(a.sourceSpan, "Unrecognized trigger")); return o.never && Object.keys(o).length > 1 && t.push(new L(n.startSourceSpan, "Cannot specify additional `hydrate` triggers if `hydrate never` is present")), { triggers: r, prefetchTriggers: i, hydrateTriggers: o }; }
var Qx = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/, op = 1, ap = 2, lp = 3, up = 4, cp = 5, Zx = 6, Js = 7, Jt = { BANANA_BOX: { start: "[(", end: ")]" }, PROPERTY: { start: "[", end: "]" }, EVENT: { start: "(", end: ")" } }, pp = "*";
function Jx(n, e, t) { let s = new $l(e, t), r = D(s, n, n), i = e.errors.concat(s.errors), o = { nodes: r, errors: i, styleUrls: s.styleUrls, styles: s.styles, ngContentSelectors: s.ngContentSelectors }; return t.collectCommentNodes && (o.commentNodes = s.commentNodes), o; }
var $l = class {
    bindingParser;
    options;
    errors = [];
    styles = [];
    styleUrls = [];
    ngContentSelectors = [];
    commentNodes = [];
    inI18nBlock = !1;
    processedNodes = new Set;
    constructor(e, t) { this.bindingParser = e, this.options = t; }
    visitElement(e) { let t = Pl(e.i18n); t && (this.inI18nBlock && this.reportError("Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.", e.sourceSpan), this.inI18nBlock = !0); let s = ff(e); if (s.type === Oe.SCRIPT)
        return null; if (s.type === Oe.STYLE) {
        let x = ey(e);
        return x !== null && this.styles.push(x), null;
    }
    else if (s.type === Oe.STYLESHEET && ex(s.hrefAttr))
        return this.styleUrls.push(s.hrefAttr), null; let r = Bd(e.name), i = [], o = [], a = [], l = [], u = [], p = {}, f = [], g = [], v = !1; for (let x of e.attrs) {
        let T = !1, M = hp(x.name), Z = !1;
        if (x.i18n && (p[x.name] = x.i18n), M.startsWith(pp)) {
            v && this.reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", x.sourceSpan), Z = !0, v = !0;
            let te = x.value, Te = M.substring(pp.length), es = [], $f = x.valueSpan ? x.valueSpan.start.offset : x.sourceSpan.start.offset + x.name.length;
            this.bindingParser.parseInlineTemplateBinding(Te, te, x.sourceSpan, $f, [], f, es, !0), g.push(...es.map(Gs => new mn(Gs.name, Gs.value, Gs.sourceSpan, Gs.keySpan, Gs.valueSpan)));
        }
        else
            T = this.parseAttribute(r, x, [], i, o, a, l);
        !T && !Z && u.push(this.visitAttribute(x));
    } let S; s.nonBindable ? S = D(Kx, e.children).flat(1 / 0) : S = D(this, e.children, e.children); let _; if (s.type === Oe.NG_CONTENT) {
        let x = s.selectAttr, T = e.attrs.map(M => this.visitAttribute(M));
        _ = new ks(x, T, S, e.sourceSpan, e.i18n), this.ngContentSelectors.push(x);
    }
    else if (r) {
        let x = this.extractAttributes(e.name, i, p);
        _ = new Ue(e.name, u, x.bound, o, [], S, l, a, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n);
    }
    else {
        let x = this.extractAttributes(e.name, i, p);
        _ = new Nt(e.name, u, x.bound, o, S, l, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n);
    } if (v) {
        let x = this.extractAttributes("ng-template", f, p), T = [];
        x.literal.forEach(Te => T.push(Te)), x.bound.forEach(Te => T.push(Te));
        let M = _ instanceof Nt ? { attributes: _.attributes, inputs: _.inputs, outputs: _.outputs } : { attributes: [], inputs: [], outputs: [] }, Z = r && t ? void 0 : e.i18n, te = _ instanceof Ue ? null : _.name;
        _ = new Ue(te, M.attributes, M.inputs, M.outputs, T, [_], [], g, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, Z);
    } return t && (this.inI18nBlock = !1), _; }
    visitAttribute(e) { return new Ts(e.name, e.value, e.sourceSpan, e.keySpan, e.valueSpan, e.i18n); }
    visitText(e) { return this.processedNodes.has(e) ? null : this._visitTextWithInterpolation(e.value, e.sourceSpan, e.tokens, e.i18n); }
    visitExpansion(e) { if (!e.i18n)
        return null; if (!Pl(e.i18n))
        throw new Error(`Invalid type "${e.i18n.constructor}" for "i18n" property of ${e.sourceSpan.toString()}. Expected a "Message"`); let t = e.i18n, s = {}, r = {}; return Object.keys(t.placeholders).forEach(i => { let o = t.placeholders[i]; if (i.startsWith(jd)) {
        let a = i.trim(), l = this.bindingParser.parseInterpolationExpression(o.text, o.sourceSpan);
        s[a] = new _s(l, o.sourceSpan);
    }
    else
        r[i] = this._visitTextWithInterpolation(o.text, o.sourceSpan, null); }), new Yp(s, r, e.sourceSpan, t); }
    visitExpansionCase(e) { return null; }
    visitComment(e) { return this.options.collectCommentNodes && this.commentNodes.push(new Ho(e.value || "", e.sourceSpan)), null; }
    visitLetDeclaration(e, t) { let s = this.bindingParser.parseBinding(e.value, !1, e.valueSpan, e.valueSpan.start.offset); return s.errors.length === 0 && s.ast instanceof Ne && this.reportError("@let declaration value cannot be empty", e.valueSpan), new vu(e.name, s, e.sourceSpan, e.nameSpan, e.valueSpan); }
    visitBlockParameter() { return null; }
    visitBlock(e, t) { let s = Array.isArray(t) ? t.indexOf(e) : -1; if (s === -1)
        throw new Error("Visitor invoked incorrectly. Expecting visitBlock to be invoked siblings array as its context"); if (this.processedNodes.has(e))
        return null; let r = null; switch (e.name) {
        case "defer":
            r = Wx(e, this.findConnectedBlocks(s, t, Fl), this, this.bindingParser);
            break;
        case "switch":
            r = Ex(e, this, this.bindingParser);
            break;
        case "for":
            r = wx(e, this.findConnectedBlocks(s, t, np), this, this.bindingParser);
            break;
        case "if":
            r = vx(e, this.findConnectedBlocks(s, t, sp), this, this.bindingParser);
            break;
        default:
            let i;
            Fl(e.name) ? (i = `@${e.name} block can only be used after an @defer block.`, this.processedNodes.add(e)) : np(e.name) ? (i = `@${e.name} block can only be used after an @for block.`, this.processedNodes.add(e)) : sp(e.name) ? (i = `@${e.name} block can only be used after an @if or @else if block.`, this.processedNodes.add(e)) : i = `Unrecognized block @${e.name}.`, r = { node: new Qi(e.name, e.sourceSpan, e.nameSpan), errors: [new L(e.sourceSpan, i)] };
            break;
    } return this.errors.push(...r.errors), r.node; }
    findConnectedBlocks(e, t, s) { let r = []; for (let i = e + 1; i < t.length; i++) {
        let o = t[i];
        if (!(o instanceof Sn)) {
            if (o instanceof Yt && o.value.trim().length === 0) {
                this.processedNodes.add(o);
                continue;
            }
            if (!(o instanceof Je) || !s(o.name))
                break;
            r.push(o), this.processedNodes.add(o);
        }
    } return r; }
    extractAttributes(e, t, s) { let r = [], i = []; return t.forEach(o => { let a = s[o.name]; if (o.isLiteral)
        i.push(new Ts(o.name, o.expression.source || "", o.sourceSpan, o.keySpan, o.valueSpan, a));
    else {
        let l = this.bindingParser.createBoundElementProperty(e, o, !0, !1);
        r.push(Va.fromBoundElementProperty(l, a));
    } }), { bound: r, literal: i }; }
    parseAttribute(e, t, s, r, i, o, a) { let l = hp(t.name), u = t.value, p = t.sourceSpan, f = t.valueSpan ? t.valueSpan.start.offset : p.start.offset; function g(T, M, Z) { let te = t.name.length - l.length, Te = T.start.moveBy(M.length + te), es = Te.moveBy(Z.length); return new R(Te, es, Te, Z); } let v = l.match(Qx); if (v) {
        if (v[op] != null) {
            let T = v[Js], M = g(p, v[op], T);
            this.bindingParser.parsePropertyBinding(T, u, !1, !1, p, f, t.valueSpan, s, r, M);
        }
        else if (v[ap]) {
            if (e) {
                let T = v[Js], M = g(p, v[ap], T);
                this.parseVariable(T, u, p, M, t.valueSpan, o);
            }
            else
                this.reportError("\"let-\" is only supported on ng-template elements.", p);
        }
        else if (v[lp]) {
            let T = v[Js], M = g(p, v[lp], T);
            this.parseReference(T, u, p, M, t.valueSpan, a);
        }
        else if (v[up]) {
            let T = [], M = v[Js], Z = g(p, v[up], M);
            this.bindingParser.parseEvent(M, u, !1, p, t.valueSpan || p, s, T, Z), ga(T, i);
        }
        else if (v[cp]) {
            let T = v[Js], M = g(p, v[cp], T);
            this.bindingParser.parsePropertyBinding(T, u, !1, !0, p, f, t.valueSpan, s, r, M), this.parseAssignmentEvent(T, u, p, t.valueSpan, s, i, M);
        }
        else if (v[Zx]) {
            let T = g(p, "", l);
            this.bindingParser.parseLiteralAttr(l, u, p, f, t.valueSpan, s, r, T);
        }
        return !0;
    } let S = null; if (l.startsWith(Jt.BANANA_BOX.start) ? S = Jt.BANANA_BOX : l.startsWith(Jt.PROPERTY.start) ? S = Jt.PROPERTY : l.startsWith(Jt.EVENT.start) && (S = Jt.EVENT), S !== null && l.endsWith(S.end) && l.length > S.start.length + S.end.length) {
        let T = l.substring(S.start.length, l.length - S.end.length), M = g(p, S.start, T);
        if (S.start === Jt.BANANA_BOX.start)
            this.bindingParser.parsePropertyBinding(T, u, !1, !0, p, f, t.valueSpan, s, r, M), this.parseAssignmentEvent(T, u, p, t.valueSpan, s, i, M);
        else if (S.start === Jt.PROPERTY.start)
            this.bindingParser.parsePropertyBinding(T, u, !1, !1, p, f, t.valueSpan, s, r, M);
        else {
            let Z = [];
            this.bindingParser.parseEvent(T, u, !1, p, t.valueSpan || p, s, Z, M), ga(Z, i);
        }
        return !0;
    } let _ = g(p, "", l); return this.bindingParser.parsePropertyInterpolation(l, u, p, t.valueSpan, s, r, _, t.valueTokens ?? null); }
    _visitTextWithInterpolation(e, t, s, r) { let i = qh(e), o = this.bindingParser.parseInterpolation(i, t, s); return o ? new _s(o, t, r) : new kn(i, t); }
    parseVariable(e, t, s, r, i, o) { e.indexOf("-") > -1 ? this.reportError("\"-\" is not allowed in variable names", s) : e.length === 0 && this.reportError("Variable does not have a name", s), o.push(new mn(e, t, s, r, i)); }
    parseReference(e, t, s, r, i, o) { e.indexOf("-") > -1 ? this.reportError("\"-\" is not allowed in reference names", s) : e.length === 0 ? this.reportError("Reference does not have a name", s) : o.some(a => a.name === e) && this.reportError(`Reference "#${e}" is defined more than once`, s), o.push(new Br(e, t, s, r, i)); }
    parseAssignmentEvent(e, t, s, r, i, o, a) { let l = []; this.bindingParser.parseEvent(`${e}Change`, t, !0, s, r || s, i, l, a), ga(l, o); }
    reportError(e, t, s = an.ERROR) { this.errors.push(new L(t, e, s)); }
}, Ol = class {
    visitElement(e) { let t = ff(e); if (t.type === Oe.SCRIPT || t.type === Oe.STYLE || t.type === Oe.STYLESHEET)
        return null; let s = D(this, e.children, null); return new Nt(e.name, D(this, e.attrs), [], [], s, [], e.sourceSpan, e.startSourceSpan, e.endSourceSpan); }
    visitComment(e) { return null; }
    visitAttribute(e) { return new Ts(e.name, e.value, e.sourceSpan, e.keySpan, e.valueSpan, e.i18n); }
    visitText(e) { return new kn(e.value, e.sourceSpan); }
    visitExpansion(e) { return null; }
    visitExpansionCase(e) { return null; }
    visitBlock(e, t) { let s = [new kn(e.startSourceSpan.toString(), e.startSourceSpan), ...D(this, e.children)]; return e.endSourceSpan !== null && s.push(new kn(e.endSourceSpan.toString(), e.endSourceSpan)), s; }
    visitBlockParameter(e, t) { return null; }
    visitLetDeclaration(e, t) { return new kn(`@let ${e.name} = ${e.value};`, e.sourceSpan); }
}, Kx = new Ol;
function hp(n) { return /^data-/i.test(n) ? n.substring(5) : n; }
function ga(n, e) { e.push(...n.map(t => qa.fromParsedEvent(t))); }
function ey(n) { return n.children.length !== 1 || !(n.children[0] instanceof Yt) ? null : n.children[0].value; }
var ty = [" ", `
`, "\r", "\t"];
function mf(n, e, t = {}) { let { interpolationConfig: s, preserveWhitespaces: r, enableI18nLegacyMessageIdFormat: i } = t, o = Po(s), l = new No().parse(n, e, ae(E({ leadingTriviaChars: ty }, t), { tokenizeExpansionForms: !0, tokenizeBlocks: t.enableBlockSyntax ?? !0, tokenizeLet: t.enableLetSyntax ?? !0 })); if (!t.alwaysAttemptHtmlToR3AstConversion && l.errors && l.errors.length > 0) {
    let te = { interpolationConfig: s, preserveWhitespaces: r, errors: l.errors, nodes: [], styleUrls: [], styles: [], ngContentSelectors: [] };
    return t.collectCommentNodes && (te.commentNodes = []), te;
} let u = l.rootNodes, p = !(t.preserveSignificantWhitespace ?? !0), f = new yo(s, !r, i, void 0, t.preserveSignificantWhitespace, p), g = f.visitAllWithErrors(u); if (!t.alwaysAttemptHtmlToR3AstConversion && g.errors && g.errors.length > 0) {
    let te = { interpolationConfig: s, preserveWhitespaces: r, errors: g.errors, nodes: [], styleUrls: [], styles: [], ngContentSelectors: [] };
    return t.collectCommentNodes && (te.commentNodes = []), te;
} u = g.rootNodes, r || (u = D(new Jr(!0, void 0, !1), u), f.hasI18nMeta && (u = D(new yo(s, !1, void 0, void 0, !0, p), u))); let { nodes: v, errors: S, styleUrls: _, styles: x, ngContentSelectors: T, commentNodes: M } = Jx(u, o, { collectCommentNodes: !!t.collectCommentNodes }); S.push(...l.errors, ...g.errors); let Z = { interpolationConfig: s, preserveWhitespaces: r, errors: S.length > 0 ? S : null, nodes: v, styleUrls: _, styles: x, ngContentSelectors: T }; return t.collectCommentNodes && (Z.commentNodes = M), Z; }
var ny = new $s;
function Po(n = et) { return new Bl(new xo(new Kr()), n, ny, []); }
var Lo = "%COMP%", Vl = `_nghost-${Lo}`, ql = `_ngcontent-${Lo}`;
function gf(n, e, t) { let s = new ie, r = $o(n.selector); return s.set("type", n.type.value), r.length > 0 && s.set("selectors", be(r)), n.queries.length > 0 && s.set("contentQueries", YS(n.queries, e, n.name)), n.viewQueries.length && s.set("viewQuery", XS(n.viewQueries, e, n.name)), s.set("hostBindings", ly(n.host, n.typeSourceSpan, t, e, n.selector || "", n.name, s)), s.set("inputs", el(n.inputs, !0)), s.set("outputs", el(n.outputs)), n.exportAs !== null && s.set("exportAs", B(n.exportAs.map(i => d(i)))), n.isStandalone === !1 && s.set("standalone", d(!1)), n.isSignal && s.set("signals", d(!0)), s; }
function vf(n, e) { let t = [], s = e.providers, r = e.viewProviders; if (s || r) {
    let i = [s || new at([])];
    r && i.push(r), t.push(y(h.ProvidersFeature).callFn(i));
} if (e.hostDirectives?.length && t.push(y(h.HostDirectivesFeature).callFn([fy(e.hostDirectives)])), e.usesInheritance && t.push(y(h.InheritDefinitionFeature)), e.fullInheritance && t.push(y(h.CopyDefinitionFeature)), e.lifecycle.usesOnChanges && t.push(y(h.NgOnChangesFeature)), "externalStyles" in e && e.externalStyles?.length) {
    let i = e.externalStyles.map(o => d(o));
    t.push(y(h.ExternalStylesFeature).callFn([B(i)]));
} t.length && n.set("features", B(t)); }
function sy(n, e, t) { let s = gf(n, e, t); vf(s, n); let r = y(h.defineDirective).callFn([s.toLiteralMap()], void 0, !0), i = Sf(n); return { expression: r, type: i, statements: [] }; }
function ry(n, e, t) { let s = gf(n, e, t); vf(s, n); let r = n.selector && On.parse(n.selector), i = r && r[0]; if (i) {
    let v = i.getAttrs();
    v.length && s.set("attrs", e.getConstLiteral(B(v.map(S => S != null ? d(S) : d(void 0))), !0));
} let o = n.name, a = null; if (n.defer.mode === 1 && n.defer.dependenciesFn !== null) {
    let v = `${o}_DeferFn`;
    e.statements.push(new ve(v, n.defer.dependenciesFn, void 0, oe.Final)), a = N(v);
} let l = _S(n.name, n.template.nodes, e, n.relativeContextFilePath, n.i18nUseExternalIds, n.defer, a, n.relativeTemplatePath, jS()); ef(l, C.Tmpl); let u = yS(l, e); if (l.contentSelectors !== null && s.set("ngContentSelectors", l.contentSelectors), s.set("decls", d(l.root.decls)), s.set("vars", d(l.root.vars)), l.consts.length > 0 && (l.constsInitializers.length > 0 ? s.set("consts", se([], [...l.constsInitializers, new ye(B(l.consts))])) : s.set("consts", B(l.consts))), s.set("template", u), n.declarationListEmitMode !== 3 && n.declarations.length > 0)
    s.set("dependencies", iy(B(n.declarations.map(v => v.type)), n.declarationListEmitMode));
else if (n.declarationListEmitMode === 3) {
    let v = [n.type.value];
    n.rawImports && v.push(n.rawImports), s.set("dependencies", y(h.getComponentDepsFactory).callFn(v));
} n.encapsulation === null && (n.encapsulation = ct.Emulated); let p = !!n.externalStyles?.length; if (n.styles && n.styles.length) {
    let S = (n.encapsulation == ct.Emulated ? hy(n.styles, ql, Vl) : n.styles).reduce((_, x) => (x.trim().length > 0 && _.push(e.getConstLiteral(d(x))), _), []);
    S.length > 0 && (p = !0, s.set("styles", B(S)));
} !p && n.encapsulation === ct.Emulated && (n.encapsulation = ct.None), n.encapsulation !== ct.Emulated && s.set("encapsulation", d(n.encapsulation)), n.animations !== null && s.set("data", ue([{ key: "animation", value: n.animations, quoted: !1 }])), n.changeDetection !== null && (typeof n.changeDetection == "number" && n.changeDetection !== si.Default ? s.set("changeDetection", d(n.changeDetection)) : typeof n.changeDetection == "object" && s.set("changeDetection", n.changeDetection)); let f = y(h.defineComponent).callFn([s.toLiteralMap()], void 0, !0), g = wf(n); return { expression: f, type: g, statements: [] }; }
function wf(n) { let e = Ef(n); return e.push(Ul(n.template.ngContentSelectors)), e.push(me(d(n.isStandalone))), e.push(xf(n)), n.isSignal && e.push(me(d(n.isSignal))), me(y(h.ComponentDeclaration, e)); }
function iy(n, e) { switch (e) {
    case 0: return n;
    case 1: return se([], n);
    case 2:
        let t = n.prop("map").callFn([y(h.resolveForwardRef)]);
        return se([], t);
    case 3: throw new Error("Unsupported with an array of pre-resolved dependencies");
} }
function oy(n) { return me(d(n)); }
function Hl(n) { let e = Object.keys(n).map(t => { let s = Array.isArray(n[t]) ? n[t][0] : n[t]; return { key: t, value: d(s), quoted: !0 }; }); return ue(e); }
function Ul(n) { return n.length > 0 ? me(B(n.map(e => d(e)))) : mt; }
function Ef(n) { let e = n.selector !== null ? n.selector.replace(/\n/g, "") : null; return [qo(n.type.type, n.typeArgumentCount), e !== null ? oy(e) : mt, n.exportAs !== null ? Ul(n.exportAs) : mt, me(ay(n)), me(Hl(n.outputs)), Ul(n.queries.map(t => t.propertyName))]; }
function ay(n) { return ue(Object.keys(n.inputs).map(e => { let t = n.inputs[e], s = [{ key: "alias", value: d(t.bindingPropertyName), quoted: !0 }, { key: "required", value: d(t.required), quoted: !0 }]; return t.isSignal && s.push({ key: "isSignal", value: d(t.isSignal), quoted: !0 }), { key: e, value: ue(s), quoted: !0 }; })); }
function Sf(n) { let e = Ef(n); return e.push(mt), e.push(me(d(n.isStandalone))), e.push(xf(n)), n.isSignal && e.push(me(d(n.isSignal))), me(y(h.DirectiveDeclaration, e)); }
function ly(n, e, t, s, r, i, o) { let a = t.createBoundHostProperties(n.properties, e), l = t.createDirectiveHostEventAsts(n.listeners, e); n.specialAttributes.styleAttr && (n.attributes.style = d(n.specialAttributes.styleAttr)), n.specialAttributes.classAttr && (n.attributes.class = d(n.specialAttributes.classAttr)); let u = TS({ componentName: i, componentSelector: r, properties: a, events: l, attributes: n.attributes }, t, s); ef(u, C.Host), o.set("hostAttrs", u.root.attributes); let p = u.root.vars; return p !== null && p > 0 && o.set("hostVars", d(p)), CS(u); }
var uy = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
function cy(n) { let e = {}, t = {}, s = {}, r = {}; for (let i of Object.keys(n)) {
    let o = n[i], a = i.match(uy);
    if (a === null)
        switch (i) {
            case "class":
                if (typeof o != "string")
                    throw new Error("Class binding must be string");
                r.classAttr = o;
                break;
            case "style":
                if (typeof o != "string")
                    throw new Error("Style binding must be string");
                r.styleAttr = o;
                break;
            default: typeof o == "string" ? e[i] = d(o) : e[i] = o;
        }
    else if (a[1] != null) {
        if (typeof o != "string")
            throw new Error("Property binding must be string");
        s[a[1]] = o;
    }
    else if (a[2] != null) {
        if (typeof o != "string")
            throw new Error("Event binding must be string");
        t[a[2]] = o;
    }
} return { attributes: e, listeners: t, properties: s, specialAttributes: r }; }
function py(n, e) { let t = Po(); return t.createDirectiveHostEventAsts(n.listeners, e), t.createBoundHostProperties(n.properties, e), t.errors; }
function hy(n, e, t) { let s = new no; return n.map(r => s.shimCssText(r, e, t)); }
function eA(n, e) { let t = new no, s = e ? ql.replace(Lo, e) : ql, r = e ? Vl.replace(Lo, e) : Vl; return t.shimCssText(n, s, r); }
function xf(n) { return n.hostDirectives?.length ? me(B(n.hostDirectives.map(e => ue([{ key: "directive", value: Vs(e.directive.type), quoted: !1 }, { key: "inputs", value: Hl(e.inputs || {}), quoted: !1 }, { key: "outputs", value: Hl(e.outputs || {}), quoted: !1 }])))) : mt; }
function fy(n) { let e = [], t = !1; for (let s of n) {
    if (!s.inputs && !s.outputs)
        e.push(s.directive.type);
    else {
        let r = [{ key: "directive", value: s.directive.type, quoted: !1 }];
        if (s.inputs) {
            let i = Bo(s.inputs);
            i && r.push({ key: "inputs", value: i, quoted: !1 });
        }
        if (s.outputs) {
            let i = Bo(s.outputs);
            i && r.push({ key: "outputs", value: i, quoted: !1 });
        }
        e.push(ue(r));
    }
    s.isForwardReference && (t = !0);
} return t ? new Ht([], [new ye(B(e))]) : B(e); }
function Bo(n) { let e = []; for (let t in n)
    n.hasOwnProperty(t) && e.push(d(t), d(n[t])); return e.length > 0 ? B(e) : null; }
function tA(n) { let e = []; if (n.mode === 0) {
    for (let t of n.dependencies)
        if (t.isDeferrable) {
            let s = se([new Y("m", Be)], N("m").prop(t.isDefaultImport ? "default" : t.symbolName)), r = new Hn(t.importPath).prop("then").callFn([s]);
            e.push(r);
        }
        else
            e.push(t.typeReference);
}
else
    for (let { symbolName: t, importPath: s, isDefaultImport: r } of n.dependencies) {
        let i = se([new Y("m", Be)], N("m").prop(r ? "default" : t)), o = new Hn(s).prop("then").callFn([i]);
        e.push(o);
    } return se([], B(e)); }
function fp(n, e) { let t = new Set(e); return n.filter(s => !t.has(s)); }
function nA(n, e) { let t = new fr; for (let u of e) {
    let p = { selector: u, exportAs: null, inputs: { hasBindingPropertyName() { return !1; } }, outputs: { hasBindingPropertyName() { return !1; } } };
    t.addSelectables(On.parse(u), [p]);
} let s = mf(n, ""), i = new Mo(t).bind({ template: s.nodes }), o = i.getEagerlyUsedDirectives().map(u => u.selector), a = i.getUsedDirectives().map(u => u.selector), l = i.getEagerlyUsedPipes(); return { directives: { regular: o, deferCandidates: fp(a, o) }, pipes: { regular: l, deferCandidates: fp(i.getUsedPipes(), l) } }; }
var Mo = class {
    directiveMatcher;
    constructor(e) { this.directiveMatcher = e; }
    bind(e) { if (!e.template)
        throw new Error("Empty bound targets are not supported"); let t = new Map, s = [], r = new Map, i = new Map, o = new Map, a = new Map, l = new Map, u = new Map, p = new Set, f = new Set, g = []; if (e.template) {
        let v = Wl.apply(e.template);
        dy(v, o), jl.apply(e.template, this.directiveMatcher, t, s, r, i), zl.applyWithScope(e.template, v, a, l, u, p, f, g);
    } return new Gl(e, t, s, r, i, a, l, u, o, p, f, g); }
}, Wl = class n {
    parentScope;
    rootNode;
    namedEntities = new Map;
    elementsInScope = new Set;
    childScopes = new Map;
    isDeferred;
    constructor(e, t) { this.parentScope = e, this.rootNode = t, this.isDeferred = e !== null && e.isDeferred ? !0 : t instanceof Xn; }
    static newRootScope() { return new n(null, null); }
    static apply(e) { let t = n.newRootScope(); return t.ingest(e), t; }
    ingest(e) { e instanceof Ue ? (e.variables.forEach(t => this.visitVariable(t)), e.children.forEach(t => t.visit(this))) : e instanceof Ln ? (e.expressionAlias !== null && this.visitVariable(e.expressionAlias), e.children.forEach(t => t.visit(this))) : e instanceof bs ? (this.visitVariable(e.item), e.contextVariables.forEach(t => this.visitVariable(t)), e.children.forEach(t => t.visit(this))) : e instanceof Pr || e instanceof Lr || e instanceof Xn || e instanceof Dr || e instanceof Ir || e instanceof Nr || e instanceof ks ? e.children.forEach(t => t.visit(this)) : e.forEach(t => t.visit(this)); }
    visitElement(e) { e.references.forEach(t => this.visitReference(t)), e.children.forEach(t => t.visit(this)), this.elementsInScope.add(e); }
    visitTemplate(e) { e.references.forEach(t => this.visitReference(t)), this.ingestScopedNode(e); }
    visitVariable(e) { this.maybeDeclare(e); }
    visitReference(e) { this.maybeDeclare(e); }
    visitDeferredBlock(e) { this.ingestScopedNode(e), e.placeholder?.visit(this), e.loading?.visit(this), e.error?.visit(this); }
    visitDeferredBlockPlaceholder(e) { this.ingestScopedNode(e); }
    visitDeferredBlockError(e) { this.ingestScopedNode(e); }
    visitDeferredBlockLoading(e) { this.ingestScopedNode(e); }
    visitSwitchBlock(e) { e.cases.forEach(t => t.visit(this)); }
    visitSwitchBlockCase(e) { this.ingestScopedNode(e); }
    visitForLoopBlock(e) { this.ingestScopedNode(e), e.empty?.visit(this); }
    visitForLoopBlockEmpty(e) { this.ingestScopedNode(e); }
    visitIfBlock(e) { e.branches.forEach(t => t.visit(this)); }
    visitIfBlockBranch(e) { this.ingestScopedNode(e); }
    visitContent(e) { this.ingestScopedNode(e); }
    visitLetDeclaration(e) { this.maybeDeclare(e); }
    visitBoundAttribute(e) { }
    visitBoundEvent(e) { }
    visitBoundText(e) { }
    visitText(e) { }
    visitTextAttribute(e) { }
    visitIcu(e) { }
    visitDeferredTrigger(e) { }
    visitUnknownBlock(e) { }
    maybeDeclare(e) { this.namedEntities.has(e.name) || this.namedEntities.set(e.name, e); }
    lookup(e) { return this.namedEntities.has(e) ? this.namedEntities.get(e) : this.parentScope !== null ? this.parentScope.lookup(e) : null; }
    getChildScope(e) { let t = this.childScopes.get(e); if (t === void 0)
        throw new Error(`Assertion error: child scope for ${e} not found`); return t; }
    ingestScopedNode(e) { let t = new n(this, e); t.ingest(e), this.childScopes.set(e, t); }
}, jl = class n {
    matcher;
    directives;
    eagerDirectives;
    bindings;
    references;
    isInDeferBlock = !1;
    constructor(e, t, s, r, i) { this.matcher = e, this.directives = t, this.eagerDirectives = s, this.bindings = r, this.references = i; }
    static apply(e, t, s, r, i, o) { new n(t, s, r, i, o).ingest(e); }
    ingest(e) { e.forEach(t => t.visit(this)); }
    visitElement(e) { this.visitElementOrTemplate(e); }
    visitTemplate(e) { this.visitElementOrTemplate(e); }
    visitElementOrTemplate(e) { let t = Gd(e), s = []; this.matcher.match(t, (i, o) => s.push(...o)), s.length > 0 && (this.directives.set(e, s), this.isInDeferBlock || this.eagerDirectives.push(...s)), e.references.forEach(i => { let o = null; if (i.value.trim() === "")
        o = s.find(a => a.isComponent) || null;
    else if (o = s.find(a => a.exportAs !== null && a.exportAs.some(l => l === i.value)) || null, o === null)
        return; o !== null ? this.references.set(i, { directive: o, node: e }) : this.references.set(i, e); }); let r = (i, o) => { let a = s.find(u => u[o].hasBindingPropertyName(i.name)), l = a !== void 0 ? a : e; this.bindings.set(i, l); }; e.inputs.forEach(i => r(i, "inputs")), e.attributes.forEach(i => r(i, "inputs")), e instanceof Ue && e.templateAttrs.forEach(i => r(i, "inputs")), e.outputs.forEach(i => r(i, "outputs")), e.children.forEach(i => i.visit(this)); }
    visitDeferredBlock(e) { let t = this.isInDeferBlock; this.isInDeferBlock = !0, e.children.forEach(s => s.visit(this)), this.isInDeferBlock = t, e.placeholder?.visit(this), e.loading?.visit(this), e.error?.visit(this); }
    visitDeferredBlockPlaceholder(e) { e.children.forEach(t => t.visit(this)); }
    visitDeferredBlockError(e) { e.children.forEach(t => t.visit(this)); }
    visitDeferredBlockLoading(e) { e.children.forEach(t => t.visit(this)); }
    visitSwitchBlock(e) { e.cases.forEach(t => t.visit(this)); }
    visitSwitchBlockCase(e) { e.children.forEach(t => t.visit(this)); }
    visitForLoopBlock(e) { e.item.visit(this), e.contextVariables.forEach(t => t.visit(this)), e.children.forEach(t => t.visit(this)), e.empty?.visit(this); }
    visitForLoopBlockEmpty(e) { e.children.forEach(t => t.visit(this)); }
    visitIfBlock(e) { e.branches.forEach(t => t.visit(this)); }
    visitIfBlockBranch(e) { e.expressionAlias?.visit(this), e.children.forEach(t => t.visit(this)); }
    visitContent(e) { e.children.forEach(t => t.visit(this)); }
    visitVariable(e) { }
    visitReference(e) { }
    visitTextAttribute(e) { }
    visitBoundAttribute(e) { }
    visitBoundEvent(e) { }
    visitBoundAttributeOrEvent(e) { }
    visitText(e) { }
    visitBoundText(e) { }
    visitIcu(e) { }
    visitDeferredTrigger(e) { }
    visitUnknownBlock(e) { }
    visitLetDeclaration(e) { }
}, zl = class n extends Hi {
    bindings;
    symbols;
    usedPipes;
    eagerPipes;
    deferBlocks;
    nestingLevel;
    scope;
    rootNode;
    level;
    visitNode;
    constructor(e, t, s, r, i, o, a, l, u) { super(), this.bindings = e, this.symbols = t, this.usedPipes = s, this.eagerPipes = r, this.deferBlocks = i, this.nestingLevel = o, this.scope = a, this.rootNode = l, this.level = u, this.visitNode = p => p.visit(this); }
    visit(e, t) { e instanceof re ? e.visit(this, t) : e.visit(this); }
    static applyWithScope(e, t, s, r, i, o, a, l) { let u = e instanceof Ue ? e : null; new n(s, r, o, a, l, i, t, u, 0).ingest(e); }
    ingest(e) { if (e instanceof Ue)
        e.variables.forEach(this.visitNode), e.children.forEach(this.visitNode), this.nestingLevel.set(e, this.level);
    else if (e instanceof Ln)
        e.expressionAlias !== null && this.visitNode(e.expressionAlias), e.children.forEach(this.visitNode), this.nestingLevel.set(e, this.level);
    else if (e instanceof bs)
        this.visitNode(e.item), e.contextVariables.forEach(t => this.visitNode(t)), e.trackBy.visit(this), e.children.forEach(this.visitNode), this.nestingLevel.set(e, this.level);
    else if (e instanceof Xn) {
        if (this.scope.rootNode !== e)
            throw new Error(`Assertion error: resolved incorrect scope for deferred block ${e}`);
        this.deferBlocks.push([e, this.scope]), e.children.forEach(t => t.visit(this)), this.nestingLevel.set(e, this.level);
    }
    else
        e instanceof Pr || e instanceof Lr || e instanceof Dr || e instanceof Ir || e instanceof Nr || e instanceof ks ? (e.children.forEach(t => t.visit(this)), this.nestingLevel.set(e, this.level)) : e.forEach(this.visitNode); }
    visitElement(e) { e.inputs.forEach(this.visitNode), e.outputs.forEach(this.visitNode), e.children.forEach(this.visitNode), e.references.forEach(this.visitNode); }
    visitTemplate(e) { e.inputs.forEach(this.visitNode), e.outputs.forEach(this.visitNode), e.templateAttrs.forEach(this.visitNode), e.references.forEach(this.visitNode), this.ingestScopedNode(e); }
    visitVariable(e) { this.rootNode !== null && this.symbols.set(e, this.rootNode); }
    visitReference(e) { this.rootNode !== null && this.symbols.set(e, this.rootNode); }
    visitText(e) { }
    visitTextAttribute(e) { }
    visitUnknownBlock(e) { }
    visitDeferredTrigger() { }
    visitIcu(e) { Object.keys(e.vars).forEach(t => e.vars[t].visit(this)), Object.keys(e.placeholders).forEach(t => e.placeholders[t].visit(this)); }
    visitBoundAttribute(e) { e.value.visit(this); }
    visitBoundEvent(e) { e.handler.visit(this); }
    visitDeferredBlock(e) { this.ingestScopedNode(e), e.triggers.when?.value.visit(this), e.prefetchTriggers.when?.value.visit(this), e.hydrateTriggers.when?.value.visit(this), e.hydrateTriggers.never?.visit(this), e.placeholder && this.visitNode(e.placeholder), e.loading && this.visitNode(e.loading), e.error && this.visitNode(e.error); }
    visitDeferredBlockPlaceholder(e) { this.ingestScopedNode(e); }
    visitDeferredBlockError(e) { this.ingestScopedNode(e); }
    visitDeferredBlockLoading(e) { this.ingestScopedNode(e); }
    visitSwitchBlock(e) { e.expression.visit(this), e.cases.forEach(this.visitNode); }
    visitSwitchBlockCase(e) { e.expression?.visit(this), this.ingestScopedNode(e); }
    visitForLoopBlock(e) { e.expression.visit(this), this.ingestScopedNode(e), e.empty?.visit(this); }
    visitForLoopBlockEmpty(e) { this.ingestScopedNode(e); }
    visitIfBlock(e) { e.branches.forEach(t => t.visit(this)); }
    visitIfBlockBranch(e) { e.expression?.visit(this), this.ingestScopedNode(e); }
    visitContent(e) { this.ingestScopedNode(e); }
    visitBoundText(e) { e.value.visit(this); }
    visitLetDeclaration(e) { e.value.visit(this), this.rootNode !== null && this.symbols.set(e, this.rootNode); }
    visitPipe(e, t) { return this.usedPipes.add(e.name), this.scope.isDeferred || this.eagerPipes.add(e.name), super.visitPipe(e, t); }
    visitPropertyRead(e, t) { return this.maybeMap(e, e.name), super.visitPropertyRead(e, t); }
    visitSafePropertyRead(e, t) { return this.maybeMap(e, e.name), super.visitSafePropertyRead(e, t); }
    visitPropertyWrite(e, t) { return this.maybeMap(e, e.name), super.visitPropertyWrite(e, t); }
    ingestScopedNode(e) { let t = this.scope.getChildScope(e); new n(this.bindings, this.symbols, this.usedPipes, this.eagerPipes, this.deferBlocks, this.nestingLevel, t, e, this.level + 1).ingest(e); }
    maybeMap(e, t) { if (!(e.receiver instanceof rt) || e.receiver instanceof zn)
        return; let s = this.scope.lookup(t); s !== null && this.bindings.set(e, s); }
}, Gl = class {
    target;
    directives;
    eagerDirectives;
    bindings;
    references;
    exprTargets;
    symbols;
    nestingLevel;
    scopedNodeEntities;
    usedPipes;
    eagerPipes;
    deferredBlocks;
    deferredScopes;
    constructor(e, t, s, r, i, o, a, l, u, p, f, g) { this.target = e, this.directives = t, this.eagerDirectives = s, this.bindings = r, this.references = i, this.exprTargets = o, this.symbols = a, this.nestingLevel = l, this.scopedNodeEntities = u, this.usedPipes = p, this.eagerPipes = f, this.deferredBlocks = g.map(v => v[0]), this.deferredScopes = new Map(g); }
    getEntitiesInScope(e) { return this.scopedNodeEntities.get(e) ?? new Set; }
    getDirectivesOfNode(e) { return this.directives.get(e) || null; }
    getReferenceTarget(e) { return this.references.get(e) || null; }
    getConsumerOfBinding(e) { return this.bindings.get(e) || null; }
    getExpressionTarget(e) { return this.exprTargets.get(e) || null; }
    getDefinitionNodeOfSymbol(e) { return this.symbols.get(e) || null; }
    getNestingLevel(e) { return this.nestingLevel.get(e) || 0; }
    getUsedDirectives() { let e = new Set; return this.directives.forEach(t => t.forEach(s => e.add(s))), Array.from(e.values()); }
    getEagerlyUsedDirectives() { let e = new Set(this.eagerDirectives); return Array.from(e.values()); }
    getUsedPipes() { return Array.from(this.usedPipes); }
    getEagerlyUsedPipes() { return Array.from(this.eagerPipes); }
    getDeferBlocks() { return this.deferredBlocks; }
    getDeferredTriggerTarget(e, t) { if (!(t instanceof zi) && !(t instanceof Gi) && !(t instanceof ji))
        return null; let s = t.reference; if (s === null) {
        let i = null;
        if (e.placeholder !== null) {
            for (let o of e.placeholder.children)
                if (!(o instanceof Ho)) {
                    if (i !== null)
                        return null;
                    o instanceof Nt && (i = o);
                }
        }
        return i;
    } let r = this.findEntityInScope(e, s); if (r instanceof Br && this.getDefinitionNodeOfSymbol(r) !== e) {
        let i = this.getReferenceTarget(r);
        if (i !== null)
            return this.referenceTargetToElement(i);
    } if (e.placeholder !== null) {
        let i = this.findEntityInScope(e.placeholder, s), o = i instanceof Br ? this.getReferenceTarget(i) : null;
        if (o !== null)
            return this.referenceTargetToElement(o);
    } return null; }
    isDeferred(e) { for (let t of this.deferredBlocks) {
        if (!this.deferredScopes.has(t))
            continue;
        let s = [this.deferredScopes.get(t)];
        for (; s.length > 0;) {
            let r = s.pop();
            if (r.elementsInScope.has(e))
                return !0;
            s.push(...r.childScopes.values());
        }
    } return !1; }
    findEntityInScope(e, t) { let s = this.getEntitiesInScope(e); for (let r of s)
        if (r.name === t)
            return r; return null; }
    referenceTargetToElement(e) { return e instanceof Nt ? e : e instanceof Ue ? null : this.referenceTargetToElement(e.node); }
};
function dy(n, e) { let t = new Map; function s(i) { if (t.has(i.rootNode))
    return t.get(i.rootNode); let o = i.namedEntities, a; return i.parentScope !== null ? a = new Map([...s(i.parentScope), ...o]) : a = new Map(o), t.set(i.rootNode, a), a; } let r = [n]; for (; r.length > 0;) {
    let i = r.pop();
    for (let o of i.childScopes.values())
        r.push(o);
    s(i);
} for (let [i, o] of t)
    e.set(i, new Set(o.values())); }
var Xl = class {
}, Yl = class {
    jitEvaluator;
    FactoryTarget = At;
    ResourceLoader = Xl;
    elementSchemaRegistry = new $s;
    constructor(e = new rl) { this.jitEvaluator = e; }
    compilePipe(e, t, s) { let r = { type: fe(s.type), typeArgumentCount: 0, pipeName: s.pipeName, pure: s.pure, isStandalone: s.isStandalone }, i = pc(r); return this.jitExpression(i.expression, e, t, []); }
    compilePipeDeclaration(e, t, s) { let r = Dy(s), i = pc(r); return this.jitExpression(i.expression, e, t, []); }
    compileInjectable(e, t, s) { let { expression: r, statements: i } = nc({ name: s.name, type: fe(s.type), typeArgumentCount: s.typeArgumentCount, providedIn: Ep(s.providedIn), useClass: is(s, "useClass"), useFactory: wp(s, "useFactory"), useValue: is(s, "useValue"), useExisting: is(s, "useExisting"), deps: s.deps?.map(_f) }, !0); return this.jitExpression(r, e, t, i); }
    compileInjectableDeclaration(e, t, s) { let { expression: r, statements: i } = nc({ name: s.type.name, type: fe(s.type), typeArgumentCount: 0, providedIn: Ep(s.providedIn), useClass: is(s, "useClass"), useFactory: wp(s, "useFactory"), useValue: is(s, "useValue"), useExisting: is(s, "useExisting"), deps: s.deps?.map(Sp) }, !0); return this.jitExpression(r, e, t, i); }
    compileInjector(e, t, s) { let r = { type: fe(s.type), providers: s.providers && s.providers.length > 0 ? new V(s.providers) : null, imports: s.imports.map(o => new V(o)) }, i = cc(r); return this.jitExpression(i.expression, e, t, []); }
    compileInjectorDeclaration(e, t, s) { let r = Py(s), i = cc(r); return this.jitExpression(i.expression, e, t, []); }
    compileNgModule(e, t, s) { let r = { kind: Vt.Global, type: fe(s.type), bootstrap: s.bootstrap.map(fe), declarations: s.declarations.map(fe), publicDeclarationTypes: null, imports: s.imports.map(fe), includeImportTypes: !0, exports: s.exports.map(fe), selectorScopeMode: to.Inline, containsForwardDecls: !1, schemas: s.schemas ? s.schemas.map(fe) : null, id: s.id ? new V(s.id) : null }, i = dm(r); return this.jitExpression(i.expression, e, t, []); }
    compileNgModuleDeclaration(e, t, s) { let r = mm(s); return this.jitExpression(r, e, t, []); }
    compileDirective(e, t, s) { let r = gp(s); return this.compileDirectiveFromMeta(e, t, r); }
    compileDirectiveDeclaration(e, t, s) { let r = this.createParseSourceSpan("Directive", s.type.name, t), i = Cf(s, r); return this.compileDirectiveFromMeta(e, t, i); }
    compileDirectiveFromMeta(e, t, s) { let r = new bi, i = Po(), o = sy(s, r, i); return this.jitExpression(o.expression, e, t, r.statements); }
    compileComponent(e, t, s) { let { template: r, interpolation: i, defer: o } = Af(s.template, s.name, t, s.preserveWhitespaces, s.interpolation, void 0), a = ae(E(E({}, s), gp(s)), { selector: s.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template: r, declarations: s.declarations.map(wy), declarationListEmitMode: 0, defer: o, styles: [...s.styles, ...r.styles], encapsulation: s.encapsulation, interpolation: i, changeDetection: s.changeDetection ?? null, animations: s.animations != null ? new V(s.animations) : null, viewProviders: s.viewProviders != null ? new V(s.viewProviders) : null, relativeContextFilePath: "", i18nUseExternalIds: !0, relativeTemplatePath: null }), l = `ng:///${s.name}.js`; return this.compileComponentFromMeta(e, l, a); }
    compileComponentDeclaration(e, t, s) { let r = this.createParseSourceSpan("Component", s.type.name, t), i = vy(s, r, t); return this.compileComponentFromMeta(e, t, i); }
    compileComponentFromMeta(e, t, s) { let r = new bi, i = Po(s.interpolation), o = ry(s, r, i); return this.jitExpression(o.expression, e, t, r.statements); }
    compileFactory(e, t, s) { let r = An({ name: s.name, type: fe(s.type), typeArgumentCount: s.typeArgumentCount, deps: xy(s.deps), target: s.target }); return this.jitExpression(r.expression, e, t, r.statements); }
    compileFactoryDeclaration(e, t, s) { let r = An({ name: s.type.name, type: fe(s.type), typeArgumentCount: 0, deps: Array.isArray(s.deps) ? s.deps.map(Sp) : s.deps, target: s.target }); return this.jitExpression(r.expression, e, t, r.statements); }
    createParseSourceSpan(e, t, s) { return lm(e, t, s); }
    jitExpression(e, t, s, r) { let i = [...r, new ve("$def", e, void 0, oe.Exported)]; return this.jitEvaluator.evaluateStatements(s, i, new ol(t), !0).$def; }
};
function dp(n) { return ae(E({}, n), { isSignal: n.isSignal, predicate: yf(n.predicate), read: n.read ? new V(n.read) : null, static: n.static, emitDistinctChangesOnly: n.emitDistinctChangesOnly }); }
function mp(n) { return { propertyName: n.propertyName, first: n.first ?? !1, predicate: yf(n.predicate), descendants: n.descendants ?? !1, read: n.read ? new V(n.read) : null, static: n.static ?? !1, emitDistinctChangesOnly: n.emitDistinctChangesOnly ?? !0, isSignal: !!n.isSignal }; }
function yf(n) { return Array.isArray(n) ? n : mu(new V(n), 1); }
function gp(n) { let e = Ny(n.inputs || []), t = wa(n.outputs || []), s = n.propMetadata, r = {}, i = {}; for (let a in s)
    s.hasOwnProperty(a) && s[a].forEach(l => { Ty(l) ? r[a] = { bindingPropertyName: l.alias || a, classPropertyName: a, required: l.required || !1, isSignal: !!l.isSignal, transformFunction: l.transform != null ? new V(l.transform) : null } : by(l) && (i[a] = l.alias || a); }); let o = n.hostDirectives?.length ? n.hostDirectives.map(a => typeof a == "function" ? { directive: fe(a), inputs: null, outputs: null, isForwardReference: !1 } : { directive: fe(a.directive), isForwardReference: !1, inputs: a.inputs ? wa(a.inputs) : null, outputs: a.outputs ? wa(a.outputs) : null }) : null; return ae(E({}, n), { typeArgumentCount: 0, typeSourceSpan: n.typeSourceSpan, type: fe(n.type), deps: null, host: E({}, Cy(n.propMetadata, n.typeSourceSpan, n.host)), inputs: E(E({}, e), r), outputs: E(E({}, t), i), queries: n.queries.map(dp), providers: n.providers != null ? new V(n.providers) : null, viewQueries: n.viewQueries.map(dp), fullInheritance: !1, hostDirectives: o }); }
function Cf(n, e) { let t = n.hostDirectives?.length ? n.hostDirectives.map(s => ({ directive: fe(s.directive), isForwardReference: !1, inputs: s.inputs ? vp(s.inputs) : null, outputs: s.outputs ? vp(s.outputs) : null })) : null; return { name: n.type.name, type: fe(n.type), typeSourceSpan: e, selector: n.selector ?? null, inputs: n.inputs ? ky(n.inputs) : {}, outputs: n.outputs ?? {}, host: my(n.host), queries: (n.queries ?? []).map(mp), viewQueries: (n.viewQueries ?? []).map(mp), providers: n.providers !== void 0 ? new V(n.providers) : null, exportAs: n.exportAs ?? null, usesInheritance: n.usesInheritance ?? !1, lifecycle: { usesOnChanges: n.usesOnChanges ?? !1 }, deps: null, typeArgumentCount: 0, fullInheritance: !1, isStandalone: n.isStandalone ?? zp(n.version), isSignal: n.isSignal ?? !1, hostDirectives: t }; }
function my(n = {}) { return { attributes: gy(n.attributes ?? {}), listeners: n.listeners ?? {}, properties: n.properties ?? {}, specialAttributes: { classAttr: n.classAttribute, styleAttr: n.styleAttribute } }; }
function vp(n) { let e = null; for (let t = 1; t < n.length; t += 2)
    e = e || {}, e[n[t - 1]] = n[t]; return e; }
function gy(n) { let e = {}; for (let t of Object.keys(n))
    e[t] = new V(n[t]); return e; }
function vy(n, e, t) { let { template: s, interpolation: r, defer: i } = Af(n.template, n.type.name, t, n.preserveWhitespaces ?? !1, n.interpolation, n.deferBlockDependencies), o = []; if (n.dependencies)
    for (let a of n.dependencies)
        switch (a.kind) {
            case "directive":
            case "component":
                o.push(va(a));
                break;
            case "pipe":
                o.push(Sy(a));
                break;
        }
else
    (n.components || n.directives || n.pipes) && (n.components && o.push(...n.components.map(a => va(a, !0))), n.directives && o.push(...n.directives.map(a => va(a))), n.pipes && o.push(...Ey(n.pipes))); return ae(E({}, Cf(n, e)), { template: s, styles: n.styles ?? [], declarations: o, viewProviders: n.viewProviders !== void 0 ? new V(n.viewProviders) : null, animations: n.animations !== void 0 ? new V(n.animations) : null, defer: i, changeDetection: n.changeDetection ?? si.Default, encapsulation: n.encapsulation ?? ct.Emulated, interpolation: r, declarationListEmitMode: 2, relativeContextFilePath: "", i18nUseExternalIds: !0, relativeTemplatePath: null }); }
function wy(n) { return ae(E({}, n), { type: new V(n.type) }); }
function va(n, e = null) { return { kind: Mn.Directive, isComponent: e || n.kind === "component", selector: n.selector, type: new V(n.type), inputs: n.inputs ?? [], outputs: n.outputs ?? [], exportAs: n.exportAs ?? null }; }
function Ey(n) { return n ? Object.keys(n).map(e => ({ kind: Mn.Pipe, name: e, type: new V(n[e]) })) : []; }
function Sy(n) { return { kind: Mn.Pipe, name: n.name, type: new V(n.type) }; }
function Af(n, e, t, s, r, i) { let o = r ? Ji.fromArray(r) : et, a = mf(n, t, { preserveWhitespaces: s, interpolationConfig: o }); if (a.errors !== null) {
    let p = a.errors.map(f => f.toString()).join(", ");
    throw new Error(`Errors during JIT compilation of template for ${e}: ${p}`);
} let u = new Mo(new fr()).bind({ template: a.nodes }); return { template: a, interpolation: o, defer: yy(u, i) }; }
function is(n, e) { if (n.hasOwnProperty(e))
    return mu(new V(n[e]), 0); }
function wp(n, e) { if (n.hasOwnProperty(e))
    return new V(n[e]); }
function Ep(n) { let e = typeof n == "function" ? new V(n) : new ge(n ?? null); return mu(e, 0); }
function xy(n) { return n == null ? null : n.map(_f); }
function _f(n) { let e = n.attribute != null, t = n.token === null ? null : new V(n.token), s = e ? new V(n.attribute) : t; return Tf(s, e, n.host, n.optional, n.self, n.skipSelf); }
function Sp(n) { let e = n.attribute ?? !1, t = n.token === null ? null : new V(n.token); return Tf(t, e, n.host ?? !1, n.optional ?? !1, n.self ?? !1, n.skipSelf ?? !1); }
function Tf(n, e, t, s, r, i) { let o = e ? d("unknown") : null; return { token: n, attributeNameType: o, host: t, optional: s, self: r, skipSelf: i }; }
function yy(n, e) { let t = n.getDeferBlocks(), s = new Map; for (let r = 0; r < t.length; r++) {
    let i = e?.[r];
    s.set(t[r], i ? new V(i) : null);
} return { mode: 0, blocks: s }; }
function Cy(n, e, t) {
    let s = cy(t || {}), r = py(s, e);
    if (r.length)
        throw new Error(r.map(i => i.msg).join(`
`));
    for (let i in n)
        n.hasOwnProperty(i) && n[i].forEach(o => { Ay(o) ? s.properties[o.hostPropertyName || i] = bd("this", i) : _y(o) && (s.listeners[o.eventName || i] = `${i}(${(o.args || []).join(",")})`); });
    return s;
}
function Ay(n) { return n.ngMetadataName === "HostBinding"; }
function _y(n) { return n.ngMetadataName === "HostListener"; }
function Ty(n) { return n.ngMetadataName === "Input"; }
function by(n) { return n.ngMetadataName === "Output"; }
function ky(n) { return Object.keys(n).reduce((e, t) => { let s = n[t]; return typeof s == "string" || Array.isArray(s) ? e[t] = Iy(s) : e[t] = { bindingPropertyName: s.publicName, classPropertyName: t, transformFunction: s.transformFunction !== null ? new V(s.transformFunction) : null, required: s.isRequired, isSignal: s.isSignal }, e; }, {}); }
function Iy(n) { return typeof n == "string" ? { bindingPropertyName: n, classPropertyName: n, transformFunction: null, required: !1, isSignal: !1 } : { bindingPropertyName: n[0], classPropertyName: n[1], transformFunction: n[2] ? new V(n[2]) : null, required: !1, isSignal: !1 }; }
function Ny(n) { return n.reduce((e, t) => { if (typeof t == "string") {
    let [s, r] = bf(t);
    e[r] = { bindingPropertyName: s, classPropertyName: r, required: !1, isSignal: !1, transformFunction: null };
}
else
    e[t.name] = { bindingPropertyName: t.alias || t.name, classPropertyName: t.name, required: t.required || !1, isSignal: !1, transformFunction: t.transform != null ? new V(t.transform) : null }; return e; }, {}); }
function wa(n) { return n.reduce((e, t) => { let [s, r] = bf(t); return e[r] = s, e; }, {}); }
function bf(n) { let [e, t] = n.split(":", 2).map(s => s.trim()); return [t ?? e, e]; }
function Dy(n) { return { name: n.type.name, type: fe(n.type), typeArgumentCount: 0, pipeName: n.name, deps: null, pure: n.pure ?? !0, isStandalone: n.isStandalone ?? zp(n.version) }; }
function Py(n) { return { name: n.type.name, type: fe(n.type), providers: n.providers !== void 0 && n.providers.length > 0 ? new V(n.providers) : null, imports: n.imports !== void 0 ? n.imports.map(e => new V(e)) : [] }; }
function sA(n) { let e = n.ng || (n.ng = {}); e.ɵcompilerFacade = new Yl; }
var rA = new Na("19.2.14"), xp = class {
    defaultEncapsulation;
    preserveWhitespaces;
    strictInjectionParameters;
    constructor({ defaultEncapsulation: e = ct.Emulated, preserveWhitespaces: t, strictInjectionParameters: s } = {}) { this.defaultEncapsulation = e, this.preserveWhitespaces = Ly(wd(t)), this.strictInjectionParameters = s === !0; }
};
function Ly(n, e = !1) { return n === null ? e : n; }
var kf = "i18n", Ks = "i18n-", By = /^i18n:?/, My = "|", Ry = "@@", yp = !1;
function Fy(n, e, t, s, r) { return new Ro(t, s, r).extract(n, e); }
function $y(n, e, t, s, r) { return new Ro(s, r).merge(n, e, t); }
var Ql = class {
    messages;
    errors;
    constructor(e, t) { this.messages = e, this.errors = t; }
}, yt = function (n) { return n[n.Extract = 0] = "Extract", n[n.Merge = 1] = "Merge", n; }(yt || {}), Ro = class {
    _implicitTags;
    _implicitAttrs;
    _preserveSignificantWhitespace;
    _depth;
    _inI18nNode;
    _inImplicitNode;
    _inI18nBlock;
    _blockMeaningAndDesc;
    _blockChildren;
    _blockStartDepth;
    _inIcu;
    _msgCountAtSectionStart;
    _errors;
    _mode;
    _messages;
    _translations;
    _createI18nMessage;
    constructor(e, t, s = !0) { this._implicitTags = e, this._implicitAttrs = t, this._preserveSignificantWhitespace = s; }
    extract(e, t) { return this._init(yt.Extract, t), e.forEach(s => s.visit(this, null)), this._inI18nBlock && this._reportError(e[e.length - 1], "Unclosed block"), new Ql(this._messages, this._errors); }
    merge(e, t, s) { this._init(yt.Merge, s), this._translations = t; let i = new De("wrapper", [], e, void 0, void 0, void 0).visit(this, null); return this._inI18nBlock && this._reportError(e[e.length - 1], "Unclosed block"), new Fs(i.children, this._errors); }
    visitExpansionCase(e, t) { let s = D(this, e.expression, t); if (this._mode === yt.Merge)
        return new Yr(e.value, s, e.sourceSpan, e.valueSourceSpan, e.expSourceSpan); }
    visitExpansion(e, t) { this._mayBeAddBlockChildren(e); let s = this._inIcu; this._inIcu || (this._isInTranslatableSection && this._addMessage([e]), this._inIcu = !0); let r = D(this, e.cases, t); return this._mode === yt.Merge && (e = new un(e.switchValue, e.type, r, e.sourceSpan, e.switchValueSourceSpan)), this._inIcu = s, e; }
    visitComment(e, t) { let s = Oy(e); if (s && this._isInTranslatableSection) {
        this._reportError(e, "Could not start a block inside a translatable section");
        return;
    } let r = Vy(e); if (r && !this._inI18nBlock) {
        this._reportError(e, "Trying to close an unopened block");
        return;
    } if (!this._inI18nNode && !this._inIcu) {
        if (this._inI18nBlock) {
            if (r)
                if (this._depth == this._blockStartDepth) {
                    this._closeTranslatableSection(e, this._blockChildren), this._inI18nBlock = !1;
                    let i = this._addMessage(this._blockChildren, this._blockMeaningAndDesc), o = this._translateMessage(e, i);
                    return D(this, o);
                }
                else {
                    this._reportError(e, "I18N blocks should not cross element boundaries");
                    return;
                }
        }
        else if (s) {
            if (!yp && console && console.warn) {
                yp = !0;
                let i = e.sourceSpan.details ? `, ${e.sourceSpan.details}` : "";
                console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${e.sourceSpan.start}${i})`);
            }
            this._inI18nBlock = !0, this._blockStartDepth = this._depth, this._blockChildren = [], this._blockMeaningAndDesc = e.value.replace(By, "").trim(), this._openTranslatableSection(e);
        }
    } }
    visitText(e, t) { return this._isInTranslatableSection && this._mayBeAddBlockChildren(e), e; }
    visitElement(e, t) { this._mayBeAddBlockChildren(e), this._depth++; let s = this._inI18nNode, r = this._inImplicitNode, i = [], o, a = qy(e), l = a ? a.value : "", u = this._implicitTags.some(f => e.name === f) && !this._inIcu && !this._isInTranslatableSection, p = !r && u; if (this._inImplicitNode = r || u, !this._isInTranslatableSection && !this._inIcu) {
        if (a || p) {
            this._inI18nNode = !0;
            let f = this._addMessage(e.children, l);
            o = this._translateMessage(e, f);
        }
        if (this._mode == yt.Extract) {
            let f = a || p;
            f && this._openTranslatableSection(e), D(this, e.children), f && this._closeTranslatableSection(e, e.children);
        }
    }
    else
        (a || p) && this._reportError(e, "Could not mark an element as translatable inside a translatable section"), this._mode == yt.Extract && D(this, e.children); if (this._mode === yt.Merge && (o || e.children).forEach(g => { let v = g.visit(this, t); v && !this._isInTranslatableSection && (i = i.concat(v)); }), this._visitAttributesOf(e), this._depth--, this._inI18nNode = s, this._inImplicitNode = r, this._mode === yt.Merge) {
        let f = this._translateAttributes(e);
        return new De(e.name, f, i, e.sourceSpan, e.startSourceSpan, e.endSourceSpan);
    } return null; }
    visitAttribute(e, t) { throw new Error("unreachable code"); }
    visitBlock(e, t) { D(this, e.children, t); }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _init(e, t) { this._mode = e, this._inI18nBlock = !1, this._inI18nNode = !1, this._depth = 0, this._inIcu = !1, this._msgCountAtSectionStart = void 0, this._errors = [], this._messages = [], this._inImplicitNode = !1, this._createI18nMessage = zh(t, nh, !this._preserveSignificantWhitespace, this._preserveSignificantWhitespace); }
    _visitAttributesOf(e) { let t = {}, s = this._implicitAttrs[e.name] || []; e.attrs.filter(r => r.name.startsWith(Ks)).forEach(r => t[r.name.slice(Ks.length)] = r.value), e.attrs.forEach(r => { r.name in t ? this._addMessage([r], t[r.name]) : s.some(i => r.name === i) && this._addMessage([r]); }); }
    _addMessage(e, t) { if (e.length == 0 || this._isEmptyAttributeValue(e) || this._isPlaceholderOnlyAttributeValue(e) || this._isPlaceholderOnlyMessage(e))
        return null; let { meaning: s, description: r, id: i } = Cp(t), o = this._createI18nMessage(e, s, r, i); return this._messages.push(o), o; }
    _isEmptyAttributeValue(e) { return Ap(e) ? e[0].value.trim() === "" : !1; }
    _isPlaceholderOnlyAttributeValue(e) { if (!Ap(e))
        return !1; let t = e[0].valueTokens ?? [], s = t.filter(i => i.type === 17), r = t.filter(i => i.type === 16).map(i => i.parts[0].trim()).join(""); return s.length === 1 && r === ""; }
    _isPlaceholderOnlyMessage(e) { if (!Hy(e))
        return !1; let t = e[0].tokens, s = t.filter(i => i.type === 8), r = t.filter(i => i.type === 5).map(i => i.parts[0].trim()).join(""); return s.length === 1 && r === ""; }
    _translateMessage(e, t) { if (t && this._mode === yt.Merge) {
        let s = this._translations.get(t);
        if (s)
            return s;
        this._reportError(e, `Translation unavailable for message id="${this._translations.digest(t)}"`);
    } return []; }
    _translateAttributes(e) { let t = e.attrs, s = {}; t.forEach(i => { i.name.startsWith(Ks) && (s[i.name.slice(Ks.length)] = Cp(i.value)); }); let r = []; return t.forEach(i => { if (!(i.name === kf || i.name.startsWith(Ks)))
        if (i.value && i.value != "" && s.hasOwnProperty(i.name)) {
            let { meaning: o, description: a, id: l } = s[i.name], u = this._createI18nMessage([i], o, a, l), p = this._translations.get(u);
            if (p) {
                if (p.length == 0)
                    r.push(new Rs(i.name, "", i.sourceSpan, void 0, void 0, void 0, void 0));
                else if (p[0] instanceof Yt) {
                    let f = p[0].value;
                    r.push(new Rs(i.name, f, i.sourceSpan, void 0, void 0, void 0, void 0));
                }
                else
                    this._reportError(e, `Unexpected translation for attribute "${i.name}" (id="${l || this._translations.digest(u)}")`);
            }
            else
                this._reportError(e, `Translation unavailable for attribute "${i.name}" (id="${l || this._translations.digest(u)}")`);
        }
        else
            r.push(i); }), r; }
    _mayBeAddBlockChildren(e) { this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth && this._blockChildren.push(e); }
    _openTranslatableSection(e) { this._isInTranslatableSection ? this._reportError(e, "Unexpected section start") : this._msgCountAtSectionStart = this._messages.length; }
    get _isInTranslatableSection() { return this._msgCountAtSectionStart !== void 0; }
    _closeTranslatableSection(e, t) { if (!this._isInTranslatableSection) {
        this._reportError(e, "Unexpected section end");
        return;
    } let s = this._msgCountAtSectionStart; if (t.reduce((i, o) => i + (o instanceof Sn ? 0 : 1), 0) == 1)
        for (let i = this._messages.length - 1; i >= s; i--) {
            let o = this._messages[i].nodes;
            if (!(o.length == 1 && o[0] instanceof Tt)) {
                this._messages.splice(i, 1);
                break;
            }
        } this._msgCountAtSectionStart = void 0; }
    _reportError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
};
function Oy(n) { return !!(n instanceof Sn && n.value && n.value.startsWith("i18n")); }
function Vy(n) { return !!(n instanceof Sn && n.value && n.value === "/i18n"); }
function qy(n) { return n.attrs.find(e => e.name === kf) || null; }
function Cp(n) { if (!n)
    return { meaning: "", description: "", id: "" }; let e = n.indexOf(Ry), t = n.indexOf(My), [s, r] = e > -1 ? [n.slice(0, e), n.slice(e + 2)] : [n, ""], [i, o] = t > -1 ? [s.slice(0, t), s.slice(t + 1)] : ["", s]; return { meaning: i, description: o, id: r.trim() }; }
function Hy(n) { return n.length === 1 && n[0] instanceof Yt; }
function Ap(n) { return n.length === 1 && n[0] instanceof Rs; }
var Zl = class {
    closedByParent = !1;
    implicitNamespacePrefix = null;
    isVoid = !1;
    ignoreFirstLf = !1;
    canSelfClose = !0;
    preventNamespaceInheritance = !1;
    requireExtraParent(e) { return !1; }
    isClosedByChild(e) { return !1; }
    getContentType() { return _t.PARSABLE_DATA; }
}, Uy = new Zl;
function Wy(n) { return Uy; }
var xn = class extends $h {
    constructor() { super(Wy); }
    parse(e, t, s = {}) { return super.parse(e, t, ae(E({}, s), { tokenizeBlocks: !1, tokenizeLet: !1 })); }
}, jy = "1.2", zy = "urn:oasis:names:tc:xliff:document:1.2", Gy = "en", Ft = "x", Xy = "mrk", Yy = "file", If = "source", Qy = "seg-source", Zy = "alt-trans", Jy = "target", Jl = "trans-unit", Ky = "context-group", _p = "context", Kl = class extends Is {
    write(e, t) { let s = new eC, r = []; e.forEach(l => { let u = []; l.sources.forEach(f => { let g = new P(Ky, { purpose: "location" }); g.children.push(new U(10), new P(_p, { "context-type": "sourcefile" }, [new G(f.filePath)]), new U(10), new P(_p, { "context-type": "linenumber" }, [new G(`${f.startLine}`)]), new U(8)), u.push(new U(8), g); }); let p = new P(Jl, { id: l.id, datatype: "html" }); p.children.push(new U(8), new P(If, {}, s.serialize(l.nodes)), ...u), l.description && p.children.push(new U(8), new P("note", { priority: "1", from: "description" }, [new G(l.description)])), l.meaning && p.children.push(new U(8), new P("note", { priority: "1", from: "meaning" }, [new G(l.meaning)])), p.children.push(new U(6)), r.push(new U(6), p); }); let i = new P("body", {}, [...r, new U(4)]), o = new P("file", { "source-language": t || Gy, datatype: "plaintext", original: "ng2.template" }, [new U(4), i, new U(2)]), a = new P("xliff", { version: jy, xmlns: zy }, [new U(2), o, new U]); return wu([new Mr({ version: "1.0", encoding: "UTF-8" }), new U, a, new U]); }
    load(e, t) {
        let s = new eu, { locale: r, msgIdToHtml: i, errors: o } = s.parse(e, t), a = {}, l = new tC;
        if (Object.keys(i).forEach(u => { let { i18nNodes: p, errors: f } = l.convert(i[u], t); o.push(...f), a[u] = p; }), o.length)
            throw new Error(`xliff parse errors:
${o.join(`
`)}`);
        return { locale: r, i18nNodesByMsgId: a };
    }
    digest(e) { return Pp(e); }
}, eC = class {
    visitText(e, t) { return [new G(e.value)]; }
    visitContainer(e, t) { let s = []; return e.children.forEach(r => s.push(...r.visit(this))), s; }
    visitIcu(e, t) { let s = [new G(`{${e.expressionPlaceholder}, ${e.type}, `)]; return Object.keys(e.cases).forEach(r => { s.push(new G(`${r} {`), ...e.cases[r].visit(this), new G("} ")); }), s.push(new G("}")), s; }
    visitTagPlaceholder(e, t) { let s = nC(e.tag); if (e.isVoid)
        return [new P(Ft, { id: e.startName, ctype: s, "equiv-text": `<${e.tag}/>` })]; let r = new P(Ft, { id: e.startName, ctype: s, "equiv-text": `<${e.tag}>` }), i = new P(Ft, { id: e.closeName, ctype: s, "equiv-text": `</${e.tag}>` }); return [r, ...this.serialize(e.children), i]; }
    visitPlaceholder(e, t) { return [new P(Ft, { id: e.name, "equiv-text": `{{${e.value}}}` })]; }
    visitBlockPlaceholder(e, t) { let s = `x-${e.name.toLowerCase().replace(/[^a-z0-9]/g, "-")}`, r = new P(Ft, { id: e.startName, ctype: s, "equiv-text": `@${e.name}` }), i = new P(Ft, { id: e.closeName, ctype: s, "equiv-text": "}" }); return [r, ...this.serialize(e.children), i]; }
    visitIcuPlaceholder(e, t) { let s = `{${e.value.expression}, ${e.value.type}, ${Object.keys(e.value.cases).map(r => r + " {...}").join(" ")}}`; return [new P(Ft, { id: e.name, "equiv-text": s })]; }
    serialize(e) { return [].concat(...e.map(t => t.visit(this))); }
}, eu = class {
    _unitMlString;
    _errors;
    _msgIdToHtml;
    _locale = null;
    parse(e, t) { this._unitMlString = null, this._msgIdToHtml = {}; let s = new xn().parse(e, t); return this._errors = s.errors, D(this, s.rootNodes, null), { msgIdToHtml: this._msgIdToHtml, errors: this._errors, locale: this._locale }; }
    visitElement(e, t) { switch (e.name) {
        case Jl:
            this._unitMlString = null;
            let s = e.attrs.find(u => u.name === "id");
            if (!s)
                this._addError(e, `<${Jl}> misses the "id" attribute`);
            else {
                let u = s.value;
                this._msgIdToHtml.hasOwnProperty(u) ? this._addError(e, `Duplicated translations for msg ${u}`) : (D(this, e.children, null), typeof this._unitMlString == "string" ? this._msgIdToHtml[u] = this._unitMlString : this._addError(e, `Message ${u} misses a translation`));
            }
            break;
        case If:
        case Qy:
        case Zy: break;
        case Jy:
            let r = e.startSourceSpan.end.offset, i = e.endSourceSpan.start.offset, a = e.startSourceSpan.start.file.content.slice(r, i);
            this._unitMlString = a;
            break;
        case Yy:
            let l = e.attrs.find(u => u.name === "target-language");
            l && (this._locale = l.value), D(this, e.children, null);
            break;
        default: D(this, e.children, null);
    } }
    visitAttribute(e, t) { }
    visitText(e, t) { }
    visitComment(e, t) { }
    visitExpansion(e, t) { }
    visitExpansionCase(e, t) { }
    visitBlock(e, t) { }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
}, tC = class {
    _errors;
    convert(e, t) { let s = new xn().parse(e, t, { tokenizeExpansionForms: !0 }); return this._errors = s.errors, { i18nNodes: this._errors.length > 0 || s.rootNodes.length == 0 ? [] : [].concat(...D(this, s.rootNodes)), errors: this._errors }; }
    visitText(e, t) { return new Tt(e.value, e.sourceSpan); }
    visitElement(e, t) { if (e.name === Ft) {
        let s = e.attrs.find(r => r.name === "id");
        return s ? new ot("", s.value, e.sourceSpan) : (this._addError(e, `<${Ft}> misses the "id" attribute`), null);
    } return e.name === Xy ? [].concat(...D(this, e.children)) : (this._addError(e, "Unexpected tag"), null); }
    visitExpansion(e, t) { let s = {}; return D(this, e.cases).forEach(r => { s[r.value] = new We(r.nodes, e.sourceSpan); }), new gn(e.switchValue, e.type, s, e.sourceSpan); }
    visitExpansionCase(e, t) { return { value: e.value, nodes: D(this, e.expression) }; }
    visitComment(e, t) { }
    visitAttribute(e, t) { }
    visitBlock(e, t) { }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
};
function nC(n) { switch (n.toLowerCase()) {
    case "br": return "lb";
    case "img": return "image";
    default: return `x-${n}`;
} }
var sC = "2.0", rC = "urn:oasis:names:tc:xliff:document:2.0", iC = "en", Dn = "ph", tu = "pc", oC = "mrk", Nf = "xliff", Df = "source", aC = "target", nu = "unit", su = class extends Is {
    write(e, t) { let s = new ru, r = []; e.forEach(a => { let l = new P(nu, { id: a.id }), u = new P("notes"); (a.description || a.meaning) && (a.description && u.children.push(new U(8), new P("note", { category: "description" }, [new G(a.description)])), a.meaning && u.children.push(new U(8), new P("note", { category: "meaning" }, [new G(a.meaning)]))), a.sources.forEach(f => { u.children.push(new U(8), new P("note", { category: "location" }, [new G(`${f.filePath}:${f.startLine}${f.endLine !== f.startLine ? "," + f.endLine : ""}`)])); }), u.children.push(new U(6)), l.children.push(new U(6), u); let p = new P("segment"); p.children.push(new U(8), new P(Df, {}, s.serialize(a.nodes)), new U(6)), l.children.push(new U(6), p, new U(4)), r.push(new U(4), l); }); let i = new P("file", { original: "ng.template", id: "ngi18n" }, [...r, new U(2)]), o = new P(Nf, { version: sC, xmlns: rC, srcLang: t || iC }, [new U(2), i, new U]); return wu([new Mr({ version: "1.0", encoding: "UTF-8" }), new U, o, new U]); }
    load(e, t) {
        let s = new iu, { locale: r, msgIdToHtml: i, errors: o } = s.parse(e, t), a = {}, l = new lC;
        if (Object.keys(i).forEach(u => { let { i18nNodes: p, errors: f } = l.convert(i[u], t); o.push(...f), a[u] = p; }), o.length)
            throw new Error(`xliff2 parse errors:
${o.join(`
`)}`);
        return { locale: r, i18nNodesByMsgId: a };
    }
    digest(e) { return hu(e); }
}, ru = class {
    _nextPlaceholderId = 0;
    visitText(e, t) { return [new G(e.value)]; }
    visitContainer(e, t) { let s = []; return e.children.forEach(r => s.push(...r.visit(this))), s; }
    visitIcu(e, t) { let s = [new G(`{${e.expressionPlaceholder}, ${e.type}, `)]; return Object.keys(e.cases).forEach(r => { s.push(new G(`${r} {`), ...e.cases[r].visit(this), new G("} ")); }), s.push(new G("}")), s; }
    visitTagPlaceholder(e, t) { let s = uC(e.tag); if (e.isVoid)
        return [new P(Dn, { id: (this._nextPlaceholderId++).toString(), equiv: e.startName, type: s, disp: `<${e.tag}/>` })]; let r = new P(tu, { id: (this._nextPlaceholderId++).toString(), equivStart: e.startName, equivEnd: e.closeName, type: s, dispStart: `<${e.tag}>`, dispEnd: `</${e.tag}>` }), i = [].concat(...e.children.map(o => o.visit(this))); return i.length ? i.forEach(o => r.children.push(o)) : r.children.push(new G("")), [r]; }
    visitPlaceholder(e, t) { let s = (this._nextPlaceholderId++).toString(); return [new P(Dn, { id: s, equiv: e.name, disp: `{{${e.value}}}` })]; }
    visitBlockPlaceholder(e, t) { let s = new P(tu, { id: (this._nextPlaceholderId++).toString(), equivStart: e.startName, equivEnd: e.closeName, type: "other", dispStart: `@${e.name}`, dispEnd: "}" }), r = [].concat(...e.children.map(i => i.visit(this))); return r.length ? r.forEach(i => s.children.push(i)) : s.children.push(new G("")), [s]; }
    visitIcuPlaceholder(e, t) { let s = Object.keys(e.value.cases).map(i => i + " {...}").join(" "), r = (this._nextPlaceholderId++).toString(); return [new P(Dn, { id: r, equiv: e.name, disp: `{${e.value.expression}, ${e.value.type}, ${s}}` })]; }
    serialize(e) { return this._nextPlaceholderId = 0, [].concat(...e.map(t => t.visit(this))); }
}, iu = class {
    _unitMlString;
    _errors;
    _msgIdToHtml;
    _locale = null;
    parse(e, t) { this._unitMlString = null, this._msgIdToHtml = {}; let s = new xn().parse(e, t); return this._errors = s.errors, D(this, s.rootNodes, null), { msgIdToHtml: this._msgIdToHtml, errors: this._errors, locale: this._locale }; }
    visitElement(e, t) { switch (e.name) {
        case nu:
            this._unitMlString = null;
            let s = e.attrs.find(p => p.name === "id");
            if (!s)
                this._addError(e, `<${nu}> misses the "id" attribute`);
            else {
                let p = s.value;
                this._msgIdToHtml.hasOwnProperty(p) ? this._addError(e, `Duplicated translations for msg ${p}`) : (D(this, e.children, null), typeof this._unitMlString == "string" ? this._msgIdToHtml[p] = this._unitMlString : this._addError(e, `Message ${p} misses a translation`));
            }
            break;
        case Df: break;
        case aC:
            let r = e.startSourceSpan.end.offset, i = e.endSourceSpan.start.offset, a = e.startSourceSpan.start.file.content.slice(r, i);
            this._unitMlString = a;
            break;
        case Nf:
            let l = e.attrs.find(p => p.name === "trgLang");
            l && (this._locale = l.value);
            let u = e.attrs.find(p => p.name === "version");
            if (u) {
                let p = u.value;
                p !== "2.0" ? this._addError(e, `The XLIFF file version ${p} is not compatible with XLIFF 2.0 serializer`) : D(this, e.children, null);
            }
            break;
        default: D(this, e.children, null);
    } }
    visitAttribute(e, t) { }
    visitText(e, t) { }
    visitComment(e, t) { }
    visitExpansion(e, t) { }
    visitExpansionCase(e, t) { }
    visitBlock(e, t) { }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
}, lC = class {
    _errors;
    convert(e, t) { let s = new xn().parse(e, t, { tokenizeExpansionForms: !0 }); return this._errors = s.errors, { i18nNodes: this._errors.length > 0 || s.rootNodes.length == 0 ? [] : [].concat(...D(this, s.rootNodes)), errors: this._errors }; }
    visitText(e, t) { return new Tt(e.value, e.sourceSpan); }
    visitElement(e, t) { switch (e.name) {
        case Dn:
            let s = e.attrs.find(o => o.name === "equiv");
            if (s)
                return [new ot("", s.value, e.sourceSpan)];
            this._addError(e, `<${Dn}> misses the "equiv" attribute`);
            break;
        case tu:
            let r = e.attrs.find(o => o.name === "equivStart"), i = e.attrs.find(o => o.name === "equivEnd");
            if (!r)
                this._addError(e, `<${Dn}> misses the "equivStart" attribute`);
            else if (!i)
                this._addError(e, `<${Dn}> misses the "equivEnd" attribute`);
            else {
                let o = r.value, a = i.value;
                return [].concat(new ot("", o, e.sourceSpan), ...e.children.map(u => u.visit(this, null)), new ot("", a, e.sourceSpan));
            }
            break;
        case oC: return [].concat(...D(this, e.children));
        default: this._addError(e, "Unexpected tag");
    } return null; }
    visitExpansion(e, t) { let s = {}; return D(this, e.cases).forEach(r => { s[r.value] = new We(r.nodes, e.sourceSpan); }), new gn(e.switchValue, e.type, s, e.sourceSpan); }
    visitExpansionCase(e, t) { return { value: e.value, nodes: [].concat(...D(this, e.expression)) }; }
    visitComment(e, t) { }
    visitAttribute(e, t) { }
    visitBlock(e, t) { }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
};
function uC(n) { switch (n.toLowerCase()) {
    case "br":
    case "b":
    case "i":
    case "u": return "fmt";
    case "img": return "image";
    case "a": return "link";
    default: return "other";
} }
var Tp = "translationbundle", bp = "translation", kp = "ph", ou = class extends Is {
    write(e, t) { throw new Error("Unsupported"); }
    load(e, t) {
        let s = new au, { locale: r, msgIdToHtml: i, errors: o } = s.parse(e, t), a = {}, l = new lu;
        if (Object.keys(i).forEach(u => {
            cC(a, u, function () {
                let { i18nNodes: f, errors: g } = l.convert(i[u], t);
                if (g.length)
                    throw new Error(`xtb parse errors:
${g.join(`
`)}`);
                return f;
            });
        }), o.length)
            throw new Error(`xtb parse errors:
${o.join(`
`)}`);
        return { locale: r, i18nNodesByMsgId: a };
    }
    digest(e) { return Qp(e); }
    createNameMapper(e) { return new Zi(e, Eu); }
};
function cC(n, e, t) { Object.defineProperty(n, e, { configurable: !0, enumerable: !0, get: function () { let s = t(); return Object.defineProperty(n, e, { enumerable: !0, value: s }), s; }, set: s => { throw new Error("Could not overwrite an XTB translation"); } }); }
var au = class {
    _bundleDepth;
    _errors;
    _msgIdToHtml;
    _locale = null;
    parse(e, t) { this._bundleDepth = 0, this._msgIdToHtml = {}; let s = new xn().parse(e, t); return this._errors = s.errors, D(this, s.rootNodes), { msgIdToHtml: this._msgIdToHtml, errors: this._errors, locale: this._locale }; }
    visitElement(e, t) { switch (e.name) {
        case Tp:
            this._bundleDepth++, this._bundleDepth > 1 && this._addError(e, `<${Tp}> elements can not be nested`);
            let s = e.attrs.find(i => i.name === "lang");
            s && (this._locale = s.value), D(this, e.children, null), this._bundleDepth--;
            break;
        case bp:
            let r = e.attrs.find(i => i.name === "id");
            if (!r)
                this._addError(e, `<${bp}> misses the "id" attribute`);
            else {
                let i = r.value;
                if (this._msgIdToHtml.hasOwnProperty(i))
                    this._addError(e, `Duplicated translations for msg ${i}`);
                else {
                    let o = e.startSourceSpan.end.offset, a = e.endSourceSpan.start.offset, u = e.startSourceSpan.start.file.content.slice(o, a);
                    this._msgIdToHtml[i] = u;
                }
            }
            break;
        default: this._addError(e, "Unexpected tag");
    } }
    visitAttribute(e, t) { }
    visitText(e, t) { }
    visitComment(e, t) { }
    visitExpansion(e, t) { }
    visitExpansionCase(e, t) { }
    visitBlock(e, t) { }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
}, lu = class {
    _errors;
    convert(e, t) { let s = new xn().parse(e, t, { tokenizeExpansionForms: !0 }); return this._errors = s.errors, { i18nNodes: this._errors.length > 0 || s.rootNodes.length == 0 ? [] : D(this, s.rootNodes), errors: this._errors }; }
    visitText(e, t) { return new Tt(e.value, e.sourceSpan); }
    visitExpansion(e, t) { let s = {}; return D(this, e.cases).forEach(r => { s[r.value] = new We(r.nodes, e.sourceSpan); }), new gn(e.switchValue, e.type, s, e.sourceSpan); }
    visitExpansionCase(e, t) { return { value: e.value, nodes: D(this, e.expression) }; }
    visitElement(e, t) { if (e.name === kp) {
        let s = e.attrs.find(r => r.name === "name");
        if (s)
            return new ot("", s.value, e.sourceSpan);
        this._addError(e, `<${kp}> misses the "name" attribute`);
    }
    else
        this._addError(e, "Unexpected tag"); return null; }
    visitComment(e, t) { }
    visitAttribute(e, t) { }
    visitBlock(e, t) { }
    visitBlockParameter(e, t) { }
    visitLetDeclaration(e, t) { }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
}, Fo = class n {
    _i18nNodesByMsgId;
    digest;
    mapperFactory;
    _i18nToHtml;
    constructor(e = {}, t, s, r, i = vs.Warning, o) { this._i18nNodesByMsgId = e, this.digest = s, this.mapperFactory = r, this._i18nToHtml = new uu(e, t, s, r, i, o); }
    static load(e, t, s, r, i) { let { locale: o, i18nNodesByMsgId: a } = s.load(e, t), l = p => s.digest(p), u = p => s.createNameMapper(p); return new n(a, o, l, u, r, i); }
    get(e) {
        let t = this._i18nToHtml.convert(e);
        if (t.errors.length)
            throw new Error(t.errors.join(`
`));
        return t.nodes;
    }
    has(e) { return this.digest(e) in this._i18nNodesByMsgId; }
}, uu = class {
    _i18nNodesByMsgId;
    _locale;
    _digest;
    _mapperFactory;
    _missingTranslationStrategy;
    _console;
    _srcMsg;
    _errors = [];
    _contextStack = [];
    _mapper;
    constructor(e = {}, t, s, r, i, o) { this._i18nNodesByMsgId = e, this._locale = t, this._digest = s, this._mapperFactory = r, this._missingTranslationStrategy = i, this._console = o; }
    convert(e) { this._contextStack.length = 0, this._errors.length = 0; let t = this._convertToText(e), s = e.nodes[0].sourceSpan.start.file.url, r = new No().parse(t, s, { tokenizeExpansionForms: !0 }); return { nodes: r.rootNodes, errors: [...this._errors, ...r.errors] }; }
    visitText(e, t) { return Uo(e.value); }
    visitContainer(e, t) { return e.children.map(s => s.visit(this)).join(""); }
    visitIcu(e, t) { let s = Object.keys(e.cases).map(i => `${i} {${e.cases[i].visit(this)}}`); return `{${this._srcMsg.placeholders.hasOwnProperty(e.expression) ? this._srcMsg.placeholders[e.expression].text : e.expression}, ${e.type}, ${s.join(" ")}}`; }
    visitPlaceholder(e, t) { let s = this._mapper(e.name); return this._srcMsg.placeholders.hasOwnProperty(s) ? this._srcMsg.placeholders[s].text : this._srcMsg.placeholderToMessage.hasOwnProperty(s) ? this._convertToText(this._srcMsg.placeholderToMessage[s]) : (this._addError(e, `Unknown placeholder "${e.name}"`), ""); }
    visitTagPlaceholder(e, t) { let s = `${e.tag}`, r = Object.keys(e.attrs).map(o => `${o}="${e.attrs[o]}"`).join(" "); if (e.isVoid)
        return `<${s} ${r}/>`; let i = e.children.map(o => o.visit(this)).join(""); return `<${s} ${r}>${i}</${s}>`; }
    visitIcuPlaceholder(e, t) { return this._convertToText(this._srcMsg.placeholderToMessage[e.name]); }
    visitBlockPlaceholder(e, t) { let s = e.parameters.length === 0 ? "" : ` (${e.parameters.join("; ")})`, r = e.children.map(i => i.visit(this)).join(""); return `@${e.name}${s} {${r}}`; }
    _convertToText(e) { let t = this._digest(e), s = this._mapperFactory ? this._mapperFactory(e) : null, r; if (this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper }), this._srcMsg = e, this._i18nNodesByMsgId.hasOwnProperty(t))
        r = this._i18nNodesByMsgId[t], this._mapper = a => s ? s.toInternalName(a) : a;
    else {
        if (this._missingTranslationStrategy === vs.Error) {
            let a = this._locale ? ` for locale "${this._locale}"` : "";
            this._addError(e.nodes[0], `Missing translation for message "${t}"${a}`);
        }
        else if (this._console && this._missingTranslationStrategy === vs.Warning) {
            let a = this._locale ? ` for locale "${this._locale}"` : "";
            this._console.warn(`Missing translation for message "${t}"${a}`);
        }
        r = e.nodes, this._mapper = a => a;
    } let i = r.map(a => a.visit(this)).join(""), o = this._contextStack.pop(); return this._srcMsg = o.msg, this._mapper = o.mapper, i; }
    _addError(e, t) { this._errors.push(new xt(e.sourceSpan, t)); }
}, Ip = class {
    _htmlParser;
    getTagDefinition;
    _translationBundle;
    constructor(e, t, s, r = vs.Warning, i) { if (this._htmlParser = e, t) {
        let o = pC(s);
        this._translationBundle = Fo.load(t, "i18n", o, r, i);
    }
    else
        this._translationBundle = new Fo({}, null, Pp, void 0, r, i); }
    parse(e, t, s = {}) { let r = s.interpolationConfig || et, i = this._htmlParser.parse(e, t, E({ interpolationConfig: r }, s)); return i.errors.length ? new Fs(i.rootNodes, i.errors) : $y(i.rootNodes, this._translationBundle, r, [], {}); }
};
function pC(n) { switch (n = (n || "xlf").toLowerCase(), n) {
    case "xmb": return new Za;
    case "xtb": return new ou;
    case "xliff2":
    case "xlf2": return new su;
    case "xliff":
    case "xlf":
    default: return new Kl;
} }
var Np = class {
    _htmlParser;
    _implicitTags;
    _implicitAttrs;
    _locale;
    _preserveWhitespace;
    _messages = [];
    constructor(e, t, s, r = null, i = !0) { this._htmlParser = e, this._implicitTags = t, this._implicitAttrs = s, this._locale = r, this._preserveWhitespace = i; }
    updateFromTemplate(e, t, s) { let r = this._htmlParser.parse(e, t, { tokenizeExpansionForms: !0, interpolationConfig: s }); if (r.errors.length)
        return r.errors; let i = this._preserveWhitespace ? r.rootNodes : _n(new Jr(!1), r.rootNodes), o = Fy(i, s, this._implicitTags, this._implicitAttrs, this._preserveWhitespace); return o.errors.length ? o.errors : (this._messages.push(...o.messages), []); }
    getMessages() { return this._messages; }
    write(e, t) { let s = {}, r = new cu; this._messages.forEach(o => { let a = e.digest(o); s.hasOwnProperty(a) ? s[a].sources.push(...o.sources) : s[a] = o; }); let i = Object.keys(s).map(o => { let a = e.createNameMapper(s[o]), l = s[o], u = a ? r.convert(l.nodes, a) : l.nodes, p = new Ae(u, {}, {}, l.meaning, l.description, o); return p.sources = l.sources, t && p.sources.forEach(f => f.filePath = t(f.filePath)), p; }); return e.write(i, this._locale); }
}, cu = class extends Ga {
    convert(e, t) { return t ? e.map(s => s.visit(this, t)) : e; }
    visitTagPlaceholder(e, t) { let s = t.toPublicName(e.startName), r = e.closeName ? t.toPublicName(e.closeName) : e.closeName, i = e.children.map(o => o.visit(this, t)); return new Pt(e.tag, e.attrs, s, r, i, e.isVoid, e.sourceSpan, e.startSourceSpan, e.endSourceSpan); }
    visitBlockPlaceholder(e, t) { let s = t.toPublicName(e.startName), r = e.closeName ? t.toPublicName(e.closeName) : e.closeName, i = e.children.map(o => o.visit(this, t)); return new Lt(e.name, e.parameters, s, r, i, e.sourceSpan, e.startSourceSpan, e.endSourceSpan); }
    visitPlaceholder(e, t) { return new ot(e.value, t.toPublicName(e.name), e.sourceSpan); }
    visitIcuPlaceholder(e, t) { return new vn(e.value, t.toPublicName(e.name), e.sourceSpan); }
};
function hC(n) { let e = Pf(n); return se([], [xr(e).toStmt()]).callFn([]); }
function Pf(n) { return y(h.setClassMetadata).callFn([n.type, n.decorators, n.ctorParameters ?? d(null), n.propDecorators ?? d(null)]); }
function lA(n, e) { return e === null || e.length === 0 ? hC(n) : Lf(n, e.map(t => new Y(t.symbolName, Be)), Bf(e)); }
function uA(n, e, t) { return Lf(n, t.map(s => new Y(s, Be)), e); }
function Lf(n, e, t) { let s = Pf(n), r = se(e, [s.toStmt()]), i = y(h.setClassMetadataAsync).callFn([n.type, t, r]); return se([], [xr(i).toStmt()]).callFn([]); }
function Bf(n) { let e = n.map(({ symbolName: t, importPath: s, isDefaultImport: r }) => { let i = se([new Y("m", Be)], N("m").prop(r ? "default" : t)); return new Hn(s).prop("then").callFn([i]); }); return se([], B(e)); }
function cA(n) { let e = { className: n.className }; n.filePath && (e.filePath = n.filePath, e.lineNumber = n.lineNumber), n.forbidOrphanRendering && (e.forbidOrphanRendering = d(!0)); let t = y(h.setClassDebugInfo).callFn([n.type, vo(e)]); return se([], [xr(t).toStmt()]).callFn([]); }
function pA(n) { let e = "m", t = "d", s = "t", r = "id", i = `${n.className}_HmrLoad`, o = n.namespaceDependencies.map(x => new jt({ moduleName: x.moduleName, name: null })), a = N(e).prop("default"), l = y(h.replaceMetadata).callFn([n.type, a, B(o), B(n.localDependencies.map(x => x.runtimeRepresentation)), N("import").prop("meta"), N(r)]), u = se([new Y(e)], a.and(l)), p = y(h.getReplaceMetadataURL).callFn([N(r), N(s), N("import").prop("meta").prop("url")]), f = new dn(i, [new Y(s)], [new Hn(p, null, "@vite-ignore").prop("then").callFn([u]).toStmt()], null, oe.Final), g = se([new Y(t)], N(t).prop("id").identical(N(r)).and(N(i).callFn([N(t).prop("timestamp")]))), v = N(i).callFn([N("Date").prop("now").callFn([])]), S = N("import").prop("meta").prop("hot"), _ = S.clone().prop("on").callFn([d("angular:component-update"), g]); return se([], [new ve(r, d(encodeURIComponent(`${n.filePath}@${n.className}`)), null, oe.Final), f, xr(v).toStmt(), xr(S.and(_)).toStmt()]).callFn([]); }
function hA(n, e, t) { let s = "\u0275\u0275namespaces", r = [t.className, s].map(o => new Y(o, Be)), i = []; for (let o of t.localDependencies)
    r.push(new Y(o.name)); for (let o = 0; o < t.namespaceDependencies.length; o++)
    i.push(new ve(t.namespaceDependencies[o].assignedName, N(s).key(d(o)), Be, oe.Final)); i.push(...e); for (let o of n)
    if (o.initializer !== null) {
        i.push(N(t.className).prop(o.name).set(o.initializer).toStmt());
        for (let a of o.statements)
            i.push(a);
    } return new dn(`${t.className}_UpdateMetadata`, r, i, null, oe.Final); }
var fC = "12.0.0", dC = "18.0.0";
function mC(n) { let e = new ie; return e.set("minVersion", d(fC)), e.set("version", d("19.2.14")), e.set("ngImport", y(h.core)), e.set("type", n.type), e.set("decorators", n.decorators), e.set("ctorParameters", n.ctorParameters), e.set("propDecorators", n.propDecorators), y(h.declareClassMetadata).callFn([e.toLiteralMap()]); }
function fA(n, e) { if (e === null || e.length === 0)
    return mC(n); let t = new ie, s = new ie; return s.set("decorators", n.decorators), s.set("ctorParameters", n.ctorParameters ?? d(null)), s.set("propDecorators", n.propDecorators ?? d(null)), t.set("minVersion", d(dC)), t.set("version", d("19.2.14")), t.set("ngImport", y(h.core)), t.set("type", n.type), t.set("resolveDeferredDeps", Bf(e)), t.set("resolveMetadata", se(e.map(r => new Y(r.symbolName, Be)), s.toLiteralMap())), y(h.declareClassMetadataAsync).callFn([t.toLiteralMap()]); }
function rr(n, e) { return n === null || n.length === 0 ? null : B(n.map(t => e(t))); }
function Ea(n, e) { let t = Object.keys(n).map(s => { let r = n[s]; return { key: s, value: e(r), quoted: !0 }; }); return t.length > 0 ? ue(t) : null; }
function gC(n) { return n === "invalid" ? d("invalid") : n === null ? d(null) : B(n.map(Mf)); }
function Mf(n) { let e = new ie; return e.set("token", n.token), n.attributeNameType !== null && e.set("attribute", d(!0)), n.host && e.set("host", d(!0)), n.optional && e.set("optional", d(!0)), n.self && e.set("self", d(!0)), n.skipSelf && e.set("skipSelf", d(!0)), e.toLiteralMap(); }
function dA(n) { let e = Rf(n), t = y(h.declareDirective).callFn([e.toLiteralMap()]), s = Sf(n); return { expression: t, type: s, statements: [] }; }
function Rf(n) { let e = new ie, t = vC(n); return e.set("minVersion", d(t)), e.set("version", d("19.2.14")), e.set("type", n.type.value), n.isStandalone !== void 0 && e.set("isStandalone", d(n.isStandalone)), n.isSignal && e.set("isSignal", d(n.isSignal)), n.selector !== null && e.set("selector", d(n.selector)), e.set("inputs", Ff(n) ? SC(n.inputs) : xC(n.inputs)), e.set("outputs", el(n.outputs)), e.set("host", wC(n.host)), e.set("providers", n.providers), n.queries.length > 0 && e.set("queries", B(n.queries.map(Dp))), n.viewQueries.length > 0 && e.set("viewQueries", B(n.viewQueries.map(Dp))), n.exportAs !== null && e.set("exportAs", be(n.exportAs)), n.usesInheritance && e.set("usesInheritance", d(!0)), n.lifecycle.usesOnChanges && e.set("usesOnChanges", d(!0)), n.hostDirectives?.length && e.set("hostDirectives", EC(n.hostDirectives)), e.set("ngImport", y(h.core)), e; }
function vC(n) { let e = "14.0.0"; return Object.values(n.inputs).some(s => s.transformFunction !== null) && (e = "16.1.0"), Ff(n) && (e = "17.1.0"), (n.queries.some(s => s.isSignal) || n.viewQueries.some(s => s.isSignal)) && (e = "17.2.0"), e; }
function Ff(n) { return Object.values(n.inputs).some(e => e.isSignal); }
function Dp(n) { let e = new ie; return e.set("propertyName", d(n.propertyName)), n.first && e.set("first", d(!0)), e.set("predicate", Array.isArray(n.predicate) ? be(n.predicate) : us(n.predicate)), n.emitDistinctChangesOnly || e.set("emitDistinctChangesOnly", d(!1)), n.descendants && e.set("descendants", d(!0)), e.set("read", n.read), n.static && e.set("static", d(!0)), n.isSignal && e.set("isSignal", d(!0)), e.toLiteralMap(); }
function wC(n) { let e = new ie; return e.set("attributes", Ea(n.attributes, t => t)), e.set("listeners", Ea(n.listeners, d)), e.set("properties", Ea(n.properties, d)), n.specialAttributes.styleAttr && e.set("styleAttribute", d(n.specialAttributes.styleAttr)), n.specialAttributes.classAttr && e.set("classAttribute", d(n.specialAttributes.classAttr)), e.values.length > 0 ? e.toLiteralMap() : null; }
function EC(n) { let e = n.map(t => { let s = [{ key: "directive", value: t.isForwardReference ? gu(t.directive.type) : t.directive.type, quoted: !1 }], r = t.inputs ? Bo(t.inputs) : null, i = t.outputs ? Bo(t.outputs) : null; return r && s.push({ key: "inputs", value: r, quoted: !1 }), i && s.push({ key: "outputs", value: i, quoted: !1 }), ue(s); }); return B(e); }
function SC(n) { let e = Object.getOwnPropertyNames(n); return e.length === 0 ? null : ue(e.map(t => { let s = n[t]; return { key: t, quoted: xu.test(t), value: ue([{ key: "classPropertyName", quoted: !1, value: be(s.classPropertyName) }, { key: "publicName", quoted: !1, value: be(s.bindingPropertyName) }, { key: "isSignal", quoted: !1, value: be(s.isSignal) }, { key: "isRequired", quoted: !1, value: be(s.required) }, { key: "transformFunction", quoted: !1, value: s.transformFunction ?? Wn }]) }; })); }
function xC(n) { let e = Object.getOwnPropertyNames(n); return e.length === 0 ? null : ue(e.map(t => { let s = n[t], r = s.bindingPropertyName, i = r !== t, o; if (i || s.transformFunction !== null) {
    let a = [be(r), be(t)];
    s.transformFunction !== null && a.push(s.transformFunction), o = B(a);
}
else
    o = be(r); return { key: t, quoted: xu.test(t), value: o }; })); }
function mA(n, e, t) { let s = yC(n, e, t), r = y(h.declareComponent).callFn([s.toLiteralMap()]), i = wf(n); return { expression: r, type: i, statements: [] }; }
function yC(n, e, t) { let s = Rf(n), r = new pu; if (ne(r, e.nodes), s.set("template", CC(e, t)), t.isInline && s.set("isInline", d(!0)), r.hasBlocks && s.set("minVersion", d("17.0.0")), s.set("styles", rr(n.styles, d)), s.set("dependencies", _C(n)), s.set("viewProviders", n.viewProviders), s.set("animations", n.animations), n.changeDetection !== null) {
    if (typeof n.changeDetection == "object")
        throw new Error("Impossible state! Change detection flag is not resolved!");
    s.set("changeDetection", y(h.ChangeDetectionStrategy).prop(si[n.changeDetection]));
} if (n.encapsulation !== ct.Emulated && s.set("encapsulation", y(h.ViewEncapsulation).prop(ct[n.encapsulation])), n.interpolation !== et && s.set("interpolation", B([d(n.interpolation.start), d(n.interpolation.end)])), e.preserveWhitespaces === !0 && s.set("preserveWhitespaces", d(!0)), n.defer.mode === 0) {
    let i = [], o = !1;
    for (let a of n.defer.blocks.values())
        a === null ? i.push(d(null)) : (i.push(a), o = !0);
    o && s.set("deferBlockDependencies", B(i));
}
else
    throw new Error("Unsupported defer function emit mode in partial compilation"); return s; }
function CC(n, e) { if (e.inlineTemplateLiteralExpression !== null)
    return e.inlineTemplateLiteralExpression; if (e.isInline)
    return d(e.content, null, null); let t = e.content, s = new qr(t, e.sourceUrl), r = new Qn(s, 0, 0, 0), i = AC(s, t), o = new R(r, i); return d(t, null, o); }
function AC(n, e) {
    let t = e.length, s = 0, r = 0, i = 0;
    do
        s = e.indexOf(`
`, r), s !== -1 && (r = s + 1, i++);
    while (s !== -1);
    return new Qn(n, t, i, t - r);
}
function _C(n) { let e = n.declarationListEmitMode !== 0 ? gu : t => t; if (n.declarationListEmitMode === 3)
    throw new Error("Unsupported emit mode"); return rr(n.declarations, t => { switch (t.kind) {
    case Mn.Directive:
        let s = new ie;
        return s.set("kind", d(t.isComponent ? "component" : "directive")), s.set("type", e(t.type)), s.set("selector", d(t.selector)), s.set("inputs", rr(t.inputs, d)), s.set("outputs", rr(t.outputs, d)), s.set("exportAs", rr(t.exportAs, d)), s.toLiteralMap();
    case Mn.Pipe:
        let r = new ie;
        return r.set("kind", d("pipe")), r.set("type", e(t.type)), r.set("name", d(t.name)), r.toLiteralMap();
    case Mn.NgModule:
        let i = new ie;
        return i.set("kind", d("ngmodule")), i.set("type", e(t.type)), i.toLiteralMap();
} }); }
var pu = class extends Md {
    hasBlocks = !1;
    visitDeferredBlock() { this.hasBlocks = !0; }
    visitDeferredBlockPlaceholder() { this.hasBlocks = !0; }
    visitDeferredBlockLoading() { this.hasBlocks = !0; }
    visitDeferredBlockError() { this.hasBlocks = !0; }
    visitIfBlock() { this.hasBlocks = !0; }
    visitIfBlockBranch() { this.hasBlocks = !0; }
    visitForLoopBlock() { this.hasBlocks = !0; }
    visitForLoopBlockEmpty() { this.hasBlocks = !0; }
    visitSwitchBlock() { this.hasBlocks = !0; }
    visitSwitchBlockCase() { this.hasBlocks = !0; }
}, TC = "12.0.0";
function gA(n) { let e = new ie; return e.set("minVersion", d(TC)), e.set("version", d("19.2.14")), e.set("ngImport", y(h.core)), e.set("type", n.type.value), e.set("deps", gC(n.deps)), e.set("target", y(h.FactoryTarget).prop(At[n.target])), { expression: y(h.declareFactory).callFn([e.toLiteralMap()]), statements: [], type: Xp(n) }; }
var bC = "12.0.0";
function vA(n) { let e = kC(n), t = y(h.declareInjectable).callFn([e.toLiteralMap()]), s = th(n); return { expression: t, type: s, statements: [] }; }
function kC(n) { let e = new ie; if (e.set("minVersion", d(bC)), e.set("version", d("19.2.14")), e.set("ngImport", y(h.core)), e.set("type", n.type.value), n.providedIn !== void 0) {
    let t = us(n.providedIn);
    t.value !== null && e.set("providedIn", t);
} return n.useClass !== void 0 && e.set("useClass", us(n.useClass)), n.useExisting !== void 0 && e.set("useExisting", us(n.useExisting)), n.useValue !== void 0 && e.set("useValue", us(n.useValue)), n.useFactory !== void 0 && e.set("useFactory", n.useFactory), n.deps !== void 0 && e.set("deps", B(n.deps.map(Mf))), e; }
var IC = "12.0.0";
function wA(n) { let e = NC(n), t = y(h.declareInjector).callFn([e.toLiteralMap()]), s = gh(n); return { expression: t, type: s, statements: [] }; }
function NC(n) { let e = new ie; return e.set("minVersion", d(IC)), e.set("version", d("19.2.14")), e.set("ngImport", y(h.core)), e.set("type", n.type.value), e.set("providers", n.providers), n.imports.length > 0 && e.set("imports", B(n.imports)), e; }
var DC = "14.0.0";
function EA(n) { let e = PC(n), t = y(h.declareNgModule).callFn([e.toLiteralMap()]), s = vh(n); return { expression: t, type: s, statements: [] }; }
function PC(n) { let e = new ie; if (n.kind === Vt.Local)
    throw new Error("Invalid path! Local compilation mode should not get into the partial compilation path"); return e.set("minVersion", d(DC)), e.set("version", d("19.2.14")), e.set("ngImport", y(h.core)), e.set("type", n.type.value), n.bootstrap.length > 0 && e.set("bootstrap", ht(n.bootstrap, n.containsForwardDecls)), n.declarations.length > 0 && e.set("declarations", ht(n.declarations, n.containsForwardDecls)), n.imports.length > 0 && e.set("imports", ht(n.imports, n.containsForwardDecls)), n.exports.length > 0 && e.set("exports", ht(n.exports, n.containsForwardDecls)), n.schemas !== null && n.schemas.length > 0 && e.set("schemas", B(n.schemas.map(t => t.value))), n.id !== null && e.set("id", n.id), e; }
var LC = "14.0.0";
function SA(n) { let e = BC(n), t = y(h.declarePipe).callFn([e.toLiteralMap()]), s = wh(n); return { expression: t, type: s, statements: [] }; }
function BC(n) { let e = new ie; return e.set("minVersion", d(LC)), e.set("version", d("19.2.14")), e.set("ngImport", y(h.core)), e.set("type", n.type.value), n.isStandalone !== void 0 && e.set("isStandalone", d(n.isStandalone)), e.set("name", d(n.pipeName)), n.pure === !1 && e.set("pure", d(n.pure)), e; }
export { re as AST, Cs as ASTWithName, Ke as ASTWithSource, qe as AbsoluteSourceSpan, _a as ArrayType, pn as ArrowFunctionExpr, Rs as Attribute, ut as Binary, b as BinaryOperator, W as BinaryOperatorExpr, Mi as BindingPipe, K as BindingType, Je as Block, wo as BlockParameter, Wi as BoundElementProperty, dt as BuiltinType, Mt as BuiltinTypeName, ya as CUSTOM_ELEMENTS_SCHEMA, Tr as Call, As as Chain, si as ChangeDetectionStrategy, Ia as CommaExpr, Sn as Comment, xp as CompilerConfig, Yl as CompilerFacadeImpl, Ni as Conditional, kt as ConditionalExpr, bi as ConstantPool, On as CssSelector, et as DEFAULT_INTERPOLATION_CONFIG, Be as DYNAMIC_TYPE, dn as DeclareFunctionStmt, ve as DeclareVarStmt, $s as DomElementSchemaRegistry, Hn as DynamicImportExpr, fi as EOF, De as Element, Tl as ElementSchemaRegistry, La as EmitterVisitorContext, Ne as EmptyExpr, un as Expansion, Yr as ExpansionCase, j as Expression, Ma as ExpressionBinding, Ge as ExpressionStatement, He as ExpressionType, jt as ExternalExpr, ka as ExternalReference, At as FactoryTarget, Ht as FunctionExpr, No as HtmlParser, O as HtmlTagDefinition, Ip as I18NHtmlParser, Sr as IfStmt, rt as ImplicitReceiver, Ss as InstantiateExpr, ii as Interpolation, Ji as InterpolationConfig, Ie as InvokeFunctionExpr, Er as JSDocComment, rl as JitEvaluator, Cr as KeyedRead, Bi as KeyedWrite, wr as LeadingComment, Eo as LetDeclaration, Kr as Lexer, Ri as LiteralArray, at as LiteralArrayExpr, ge as LiteralExpr, Fi as LiteralMap, gt as LiteralMapExpr, Ze as LiteralPrimitive, vr as LocalizedString, Ta as MapType, Np as MessageBundle, mt as NONE_TYPE, Ca as NO_ERRORS_SCHEMA, En as NodeWithI18n, _r as NonNullAssert, ys as NotExpr, L as ParseError, an as ParseErrorLevel, Qn as ParseLocation, qr as ParseSourceFile, R as ParseSourceSpan, jn as ParseSpan, Fs as ParseTreeResult, Ui as ParsedEvent, it as ParsedEventType, ir as ParsedProperty, sn as ParsedPropertyType, Ra as ParsedVariable, xo as Parser, yr as ParserError, $i as PrefixNot, Gn as PropertyRead, Di as PropertyWrite, Gl as R3BoundTarget, h as R3Identifiers, Vt as R3NgModuleMetadataKind, to as R3SelectorScopeMode, Mo as R3TargetBinder, Mn as R3TemplateDependencyKind, It as ReadKeyExpr, Me as ReadPropExpr, ze as ReadVarExpr, Hi as RecursiveAstVisitor, Ac as RecursiveVisitor, Xl as ResourceLoader, ye as ReturnStatement, Lc as SECURITY_SCHEMA, Vo as STRING_TYPE, Vi as SafeCall, Li as SafeKeyedRead, Pi as SafePropertyRead, xa as SelectorContext, Sa as SelectorListContext, fr as SelectorMatcher, Is as Serializer, yl as SplitInterpolation, fn as Statement, oe as StmtModifier, cr as StringToken, Rn as StringTokenKind, _t as TagContentType, mr as TaggedTemplateLiteralExpr, Cl as TemplateBindingParseResult, br as TemplateLiteral, qi as TemplateLiteralElement, gr as TemplateLiteralElementExpr, xs as TemplateLiteralExpr, Yt as Text, zn as ThisReceiver, lt as TmplAstBlockNode, Va as TmplAstBoundAttribute, Ha as TmplAstBoundDeferredTrigger, qa as TmplAstBoundEvent, _s as TmplAstBoundText, ks as TmplAstContent, Xn as TmplAstDeferredBlock, Dr as TmplAstDeferredBlockError, Nr as TmplAstDeferredBlockLoading, Ir as TmplAstDeferredBlockPlaceholder, Dt as TmplAstDeferredTrigger, Nt as TmplAstElement, bs as TmplAstForLoopBlock, Lr as TmplAstForLoopBlockEmpty, ji as TmplAstHoverDeferredTrigger, Yp as TmplAstIcu, Wa as TmplAstIdleDeferredTrigger, Yi as TmplAstIfBlock, Ln as TmplAstIfBlockBranch, ja as TmplAstImmediateDeferredTrigger, zi as TmplAstInteractionDeferredTrigger, vu as TmplAstLetDeclaration, Ua as TmplAstNeverDeferredTrigger, Md as TmplAstRecursiveVisitor, Br as TmplAstReference, Xi as TmplAstSwitchBlock, Pr as TmplAstSwitchBlockCase, Ue as TmplAstTemplate, kn as TmplAstText, Ts as TmplAstTextAttribute, za as TmplAstTimerDeferredTrigger, Qi as TmplAstUnknownBlock, mn as TmplAstVariable, Gi as TmplAstViewportDeferredTrigger, St as Token, q as TokenType, _i as TransplantedType, Ee as TreeError, cn as Type, du as TypeModifier, Vn as TypeofExpr, Oi as TypeofExpression, Ar as Unary, ws as UnaryOperator, hn as UnaryOperatorExpr, rA as VERSION, kr as VariableBinding, Na as Version, ct as ViewEncapsulation, V as WrappedNodeExpr, Es as WriteKeyExpr, qn as WritePropExpr, dr as WriteVarExpr, Kl as Xliff, su as Xliff2, Za as Xmb, xn as XmlParser, ou as Xtb, cA as compileClassDebugInfo, hC as compileClassMetadata, lA as compileComponentClassMetadata, fA as compileComponentDeclareClassMetadata, ry as compileComponentFromMetadata, mC as compileDeclareClassMetadata, mA as compileDeclareComponentFromMetadata, dA as compileDeclareDirectiveFromMetadata, gA as compileDeclareFactoryFunction, vA as compileDeclareInjectableFromMetadata, wA as compileDeclareInjectorFromMetadata, EA as compileDeclareNgModuleFromMetadata, SA as compileDeclarePipeFromMetadata, tA as compileDeferResolverFunction, sy as compileDirectiveFromMetadata, An as compileFactoryFunction, pA as compileHmrInitializer, hA as compileHmrUpdateCallback, nc as compileInjectable, cc as compileInjector, dm as compileNgModule, uA as compileOpaqueAsyncClassMetadata, pc as compilePipeFromMetadata, Mp as computeMsgId, MC as core, Gd as createCssSelectorFromNode, th as createInjectableType, mu as createMayBeForwardRefExpression, xr as devOnlyGuardedExpression, Of as emitDistinctChangesOnlyDefaultValue, eA as encapsulateStyle, $C as escapeRegExp, nA as findMatchingDirectivesAndPipes, jh as getHtmlTagDefinition, $a as getNsPrefix, bd as getSafePropertyAccessString, cm as identifierName, ec as isNgContainer, Fa as isNgContent, Bd as isNgTemplate, Vp as jsDocComment, rd as leadingComment, d as literal, ue as literalMap, Po as makeBindingParser, Oa as mergeNsAndName, FC as outputAst, cy as parseHostBindings, mf as parseTemplate, Ly as preserveWhitespacesDefault, sA as publishFacade, lm as r3JitTypeSourceSpan, ar as sanitizeIdentifier, KC as setEnableTemplateSourceLocations, vt as splitNsName, ne as tmplAstVisitAll, py as verifyHostBindings, D as visitAll }; /*! Bundled license information:

@angular/compiler/fesm2022/compiler.mjs:
  (**
   * @license Angular v19.2.14
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/compiler/fesm2022/compiler.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)
  (**
   *
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)
*/
