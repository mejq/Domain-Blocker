import{A as M,B as V,C as G,D as b,E as j,a as A,b as s,c as C,d as N,e as c,f as E,g as o,h as w,i as k,j as I,k as W,l as D,m as a,n as O,o as i,p as f,q as p,r as d,s as P,t as v,u as R,v as L,w as U,x as _,y as T,z as x}from"./chunk-R3Y5LEMG.js";import{a as u,b as l}from"./chunk-4CLCTAJ7.js";function H(r,h,m){let e=Object.create(q);m&&(e.consumerAllowSignalWrites=!0),e.fn=r,e.schedule=h;let S=n=>{e.cleanupFn=n};function g(n){return n.fn===null&&n.schedule===null}function F(n){g(n)||(d(n),n.cleanupFn(),n.fn=null,n.schedule=null,n.cleanupFn=t)}let y=()=>{if(e.fn===null)return;if(c())throw new Error("Schedulers cannot synchronously execute watches while scheduling.");if(e.dirty=!1,e.hasRun&&!p(e))return;e.hasRun=!0;let n=i(e);try{e.cleanupFn(),e.cleanupFn=t,e.fn(S)}finally{f(e,n)}};return e.ref={notify:()=>a(e),run:y,cleanup:()=>e.cleanupFn(),destroy:()=>F(e),[s]:e},e.ref}var t=()=>{},q=l(u({},o),{consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!1,consumerMarkedDirty:r=>{r.schedule!==null&&r.schedule(r.ref)},hasRun:!1,cleanupFn:t});export{o as REACTIVE_NODE,s as SIGNAL,x as SIGNAL_NODE,f as consumerAfterComputation,i as consumerBeforeComputation,d as consumerDestroy,a as consumerMarkDirty,p as consumerPollProducersForChange,P as createComputed,M as createLinkedSignal,R as createSignal,H as createWatch,A as defaultEquals,N as getActiveConsumer,c as isInNotificationPhase,E as isReactive,V as linkedSignalSetFn,G as linkedSignalUpdateFn,w as producerAccessed,k as producerIncrementEpoch,O as producerMarkClean,W as producerNotifyConsumers,I as producerUpdateValueVersion,D as producerUpdatesAllowed,T as runPostSignalSetFn,C as setActiveConsumer,b as setAlternateWeakRefImpl,L as setPostSignalSetFn,v as setThrowInvalidWriteToSignalError,U as signalSetFn,_ as signalUpdateFn,j as untracked};/*! Bundled license information:

@angular/core/fesm2022/primitives/signals.mjs:
  (**
   * @license Angular v19.2.14
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/