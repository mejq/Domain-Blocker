import { operate } from "@nf-internal/chunk-TJH3PFHU";
import { createInvalidObservableTypeError, innerFrom, isArrayLike, isAsyncIterable, isInteropObservable, isIterable, isPromise, isReadableStreamLike, iterator, readableStreamLikeToAsyncGenerator } from "@nf-internal/chunk-AJNCDELN";
import { createOperatorSubscriber } from "@nf-internal/chunk-2234RIIE";
import { dateTimestampProvider } from "@nf-internal/chunk-IESWVQ3L";
import { Observable, Subscription, arrRemove, isFunction } from "@nf-internal/chunk-AKW5RHFP";
// ../node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function () {
    function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
            now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
    }
    Scheduler2.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
}();
// ../node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function (subscriber) {
    return subscriber.complete();
});
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) {
        return scheduler.schedule(function () {
            return subscriber.complete();
        });
    });
}
// ../node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
        delay = 0;
    }
    if (repeat === void 0) {
        repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function () {
        work();
        if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
        }
        else {
            this.unsubscribe();
        }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
        return scheduleSubscription;
    }
}
// ../node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return operate(function (source, subscriber) {
        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
            return executeSchedule(subscriber, scheduler, function () {
                return subscriber.next(value);
            }, delay);
        }, function () {
            return executeSchedule(subscriber, scheduler, function () {
                return subscriber.complete();
            }, delay);
        }, function (err) {
            return executeSchedule(subscriber, scheduler, function () {
                return subscriber.error(err);
            }, delay);
        }));
    });
}
// ../node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return operate(function (source, subscriber) {
        subscriber.add(scheduler.schedule(function () {
            return source.subscribe(subscriber);
        }, delay));
    });
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var i = 0;
        return scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
            }
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    this.schedule();
                }
            }
        });
    });
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
    return new Observable(function (subscriber) {
        var iterator2;
        executeSchedule(subscriber, scheduler, function () {
            iterator2 = input[iterator]();
            executeSchedule(subscriber, scheduler, function () {
                var _a;
                var value;
                var done;
                try {
                    _a = iterator2.next(), value = _a.value, done = _a.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                }
            }, 0, true);
        });
        return function () {
            return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
        };
    });
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
        throw new Error("Iterable cannot be null");
    }
    return new Observable(function (subscriber) {
        executeSchedule(subscriber, scheduler, function () {
            var iterator2 = input[Symbol.asyncIterator]();
            executeSchedule(subscriber, scheduler, function () {
                iterator2.next().then(function (result) {
                    if (result.done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(result.value);
                    }
                });
            }, 0, true);
        });
    });
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
// ../node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        if (isArrayLike(input)) {
            return scheduleArray(input, scheduler);
        }
        if (isPromise(input)) {
            return schedulePromise(input, scheduler);
        }
        if (isAsyncIterable(input)) {
            return scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable(input)) {
            return scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike(input)) {
            return scheduleReadableStreamLike(input, scheduler);
        }
    }
    throw createInvalidObservableTypeError(input);
}
// ../node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
// ../node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
    return value && isFunction(value.schedule);
}
// ../node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
    return arr[arr.length - 1];
}
function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
}
// ../node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
}
// ../node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () {
        return errorOrErrorFactory;
    };
    var init = function (subscriber) {
        return subscriber.error(errorFactory());
    };
    return new Observable(scheduler ? function (subscriber) {
        return scheduler.schedule(init, 0, subscriber);
    } : init);
}
// ../node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function (NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function () {
    function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function (observer) {
        return observeNotification(this, observer);
    };
    Notification2.prototype.do = function (nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
    };
    Notification2.prototype.accept = function (nextOrObserver, error, complete) {
        var _a;
        return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification2.prototype.toObservable = function () {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of(value) : kind === "E" ? throwError(function () {
            return error;
        }) : kind === "C" ? EMPTY : 0;
        if (!result) {
            throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
    };
    Notification2.createNext = function (value) {
        return new Notification2("N", value);
    };
    Notification2.createError = function (err) {
        return new Notification2("E", void 0, err);
    };
    Notification2.createComplete = function () {
        return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
}();
function observeNotification(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}
// ../node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
import { __read, __spreadArray } from "tslib";
var intervalProvider = {
    setInterval: function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
            return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function (handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: void 0
};
// ../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
import { __extends as __extends2 } from "tslib";
// ../node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
import { __extends } from "tslib";
var Action = function (_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
        return _super.call(this) || this;
    }
    Action2.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action2;
}(Subscription);
// ../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function (_super) {
    __extends2(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction2.prototype.schedule = function (state, delay) {
        var _a;
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction2.prototype.requestAsyncId = function (scheduler, _id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function (_scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
            return id;
        }
        if (id != null) {
            intervalProvider.clearInterval(id);
        }
        return void 0;
    };
    AsyncAction2.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction2.prototype._execute = function (state, _delay) {
        var errored = false;
        var errorValue;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction2.prototype.unsubscribe = function () {
        if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            arrRemove(actions, this);
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
        }
    };
    return AsyncAction2;
}(Action);
// ../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
import { __extends as __extends3 } from "tslib";
var AsyncScheduler = function (_super) {
    __extends3(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
    }
    AsyncScheduler2.prototype.flush = function (action) {
        var actions = this.actions;
        if (this._active) {
            actions.push(action);
            return;
        }
        var error;
        this._active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler2;
}(Scheduler);
export { intervalProvider, AsyncAction, Scheduler, AsyncScheduler, EMPTY, empty, isScheduler, popResultSelector, popScheduler, popNumber, executeSchedule, observeOn, subscribeOn, scheduleIterable, scheduled, from, of, throwError, NotificationKind, Notification, observeNotification };
