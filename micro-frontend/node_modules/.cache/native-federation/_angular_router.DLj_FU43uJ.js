import { a as h, b as D } from "@nf-internal/chunk-4CLCTAJ7";
import { DOCUMENT as bn, Location as Ht } from "@angular/common";
import * as m from "@angular/core";
import { ɵisPromise as In, ɵRuntimeError as b, ɵisNgModule as rs, isStandalone as ns, createEnvironmentInjector as An, InjectionToken as oe, EventEmitter as He, input as Tn, inject as g, ViewContainerRef as On, ChangeDetectorRef as Mn, reflectComponentType as Dn, ɵisInjectable as En, runInInjectionContext as H, NgModuleFactory as Un, Compiler as Nn, NgZone as Pn, afterNextRender as xn, EnvironmentInjector as _n, DestroyRef as jn, ɵConsole as kn, ɵPendingTasksInternal as Ln } from "@angular/core";
import { isObservable as $n, from as $, of as f, BehaviorSubject as U, combineLatest as Wt, EmptyError as zn, concat as Fn, defer as vr, pipe as qn, throwError as mt, EMPTY as G, ConnectableObservable as ar, Subject as Ae, Subscription as Bn } from "rxjs";
import { map as R, switchMap as j, take as Te, startWith as Vn, filter as Oe, mergeMap as P, first as se, concatMap as Xe, tap as w, catchError as we, scan as Hn, defaultIfEmpty as mr, last as Wn, takeLast as Rr, finalize as Et, refCount as ur, takeUntil as Gn } from "rxjs/operators";
import * as Sr from "@angular/platform-browser";
var d = "primary", je = Symbol("RouteTitle"), Ut = class {
    params;
    constructor(n) { this.params = n || {}; }
    has(n) { return Object.prototype.hasOwnProperty.call(this.params, n); }
    get(n) { if (this.has(n)) {
        let e = this.params[n];
        return Array.isArray(e) ? e[0] : e;
    } return null; }
    getAll(n) { if (this.has(n)) {
        let e = this.params[n];
        return Array.isArray(e) ? e : [e];
    } return []; }
    get keys() { return Object.keys(this.params); }
};
function ie(t) { return new Ut(t); }
function yr(t, n, e) { let r = e.path.split("/"); if (r.length > t.length || e.pathMatch === "full" && (n.hasChildren() || r.length < t.length))
    return null; let i = {}; for (let s = 0; s < r.length; s++) {
    let o = r[s], a = t[s];
    if (o[0] === ":")
        i[o.substring(1)] = a;
    else if (o !== a.path)
        return null;
} return { consumed: t.slice(0, r.length), posParams: i }; }
function Qn(t, n) { if (t.length !== n.length)
    return !1; for (let e = 0; e < t.length; ++e)
    if (!k(t[e], n[e]))
        return !1; return !0; }
function k(t, n) { let e = t ? Nt(t) : void 0, r = n ? Nt(n) : void 0; if (!e || !r || e.length != r.length)
    return !1; let i; for (let s = 0; s < e.length; s++)
    if (i = e[s], !Cr(t[i], n[i]))
        return !1; return !0; }
function Nt(t) { return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)]; }
function Cr(t, n) { if (Array.isArray(t) && Array.isArray(n)) {
    if (t.length !== n.length)
        return !1;
    let e = [...t].sort(), r = [...n].sort();
    return e.every((i, s) => r[s] === i);
}
else
    return t === n; }
function wr(t) { return t.length > 0 ? t[t.length - 1] : null; }
function X(t) { return $n(t) ? t : In(t) ? $(Promise.resolve(t)) : f(t); }
var Kn = { exact: Ir, subset: Ar }, br = { exact: Zn, subset: Yn, ignored: () => !0 };
function cr(t, n, e) { return Kn[e.paths](t.root, n.root, e.matrixParams) && br[e.queryParams](t.queryParams, n.queryParams) && !(e.fragment === "exact" && t.fragment !== n.fragment); }
function Zn(t, n) { return k(t, n); }
function Ir(t, n, e) { if (!re(t.segments, n.segments) || !Qe(t.segments, n.segments, e) || t.numberOfChildren !== n.numberOfChildren)
    return !1; for (let r in n.children)
    if (!t.children[r] || !Ir(t.children[r], n.children[r], e))
        return !1; return !0; }
function Yn(t, n) { return Object.keys(n).length <= Object.keys(t).length && Object.keys(n).every(e => Cr(t[e], n[e])); }
function Ar(t, n, e) { return Tr(t, n, n.segments, e); }
function Tr(t, n, e, r) { if (t.segments.length > e.length) {
    let i = t.segments.slice(0, e.length);
    return !(!re(i, e) || n.hasChildren() || !Qe(i, e, r));
}
else if (t.segments.length === e.length) {
    if (!re(t.segments, e) || !Qe(t.segments, e, r))
        return !1;
    for (let i in n.children)
        if (!t.children[i] || !Ar(t.children[i], n.children[i], r))
            return !1;
    return !0;
}
else {
    let i = e.slice(0, t.segments.length), s = e.slice(t.segments.length);
    return !re(t.segments, i) || !Qe(t.segments, i, r) || !t.children[d] ? !1 : Tr(t.children[d], n, s, r);
} }
function Qe(t, n, e) { return n.every((r, i) => br[e](t[i].parameters, r.parameters)); }
var z = class {
    root;
    queryParams;
    fragment;
    _queryParamMap;
    constructor(n = new v([], {}), e = {}, r = null) { this.root = n, this.queryParams = e, this.fragment = r; }
    get queryParamMap() { return this._queryParamMap ??= ie(this.queryParams), this._queryParamMap; }
    toString() { return ei.serialize(this); }
}, v = class {
    segments;
    children;
    parent = null;
    constructor(n, e) { this.segments = n, this.children = e, Object.values(e).forEach(r => r.parent = this); }
    hasChildren() { return this.numberOfChildren > 0; }
    get numberOfChildren() { return Object.keys(this.children).length; }
    toString() { return Ke(this); }
}, Q = class {
    path;
    parameters;
    _parameterMap;
    constructor(n, e) { this.path = n, this.parameters = e; }
    get parameterMap() { return this._parameterMap ??= ie(this.parameters), this._parameterMap; }
    toString() { return Mr(this); }
};
function Xn(t, n) { return re(t, n) && t.every((e, r) => k(e.parameters, n[r].parameters)); }
function re(t, n) { return t.length !== n.length ? !1 : t.every((e, r) => e.path === n[r].path); }
function Jn(t, n) { let e = []; return Object.entries(t.children).forEach(([r, i]) => { r === d && (e = e.concat(n(i, r))); }), Object.entries(t.children).forEach(([r, i]) => { r !== d && (e = e.concat(n(i, r))); }), e; }
var J = (() => { class t {
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: () => new K, providedIn: "root" });
} return t; })(), K = class {
    parse(n) { let e = new xt(n); return new z(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()); }
    serialize(n) { let e = `/${ye(n.root, !0)}`, r = ni(n.queryParams), i = typeof n.fragment == "string" ? `#${ti(n.fragment)}` : ""; return `${e}${r}${i}`; }
}, ei = new K;
function Ke(t) { return t.segments.map(n => Mr(n)).join("/"); }
function ye(t, n) { if (!t.hasChildren())
    return Ke(t); if (n) {
    let e = t.children[d] ? ye(t.children[d], !1) : "", r = [];
    return Object.entries(t.children).forEach(([i, s]) => { i !== d && r.push(`${i}:${ye(s, !1)}`); }), r.length > 0 ? `${e}(${r.join("//")})` : e;
}
else {
    let e = Jn(t, (r, i) => i === d ? [ye(t.children[d], !1)] : [`${i}:${ye(r, !1)}`]);
    return Object.keys(t.children).length === 1 && t.children[d] != null ? `${Ke(t)}/${e[0]}` : `${Ke(t)}/(${e.join("//")})`;
} }
function Or(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ","); }
function We(t) { return Or(t).replace(/%3B/gi, ";"); }
function ti(t) { return encodeURI(t); }
function Pt(t) { return Or(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&"); }
function Ze(t) { return decodeURIComponent(t); }
function lr(t) { return Ze(t.replace(/\+/g, "%20")); }
function Mr(t) { return `${Pt(t.path)}${ri(t.parameters)}`; }
function ri(t) { return Object.entries(t).map(([n, e]) => `;${Pt(n)}=${Pt(e)}`).join(""); }
function ni(t) { let n = Object.entries(t).map(([e, r]) => Array.isArray(r) ? r.map(i => `${We(e)}=${We(i)}`).join("&") : `${We(e)}=${We(r)}`).filter(e => e); return n.length ? `?${n.join("&")}` : ""; }
var ii = /^[^\/()?;#]+/;
function Tt(t) { let n = t.match(ii); return n ? n[0] : ""; }
var oi = /^[^\/()?;=#]+/;
function si(t) { let n = t.match(oi); return n ? n[0] : ""; }
var ai = /^[^=?&#]+/;
function ui(t) { let n = t.match(ai); return n ? n[0] : ""; }
var ci = /^[^&#]+/;
function li(t) { let n = t.match(ci); return n ? n[0] : ""; }
var xt = class {
    url;
    remaining;
    constructor(n) { this.url = n, this.remaining = n; }
    parseRootSegment() { return this.consumeOptional("/"), this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new v([], {}) : new v([], this.parseChildren()); }
    parseQueryParams() { let n = {}; if (this.consumeOptional("?"))
        do
            this.parseQueryParam(n);
        while (this.consumeOptional("&")); return n; }
    parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null; }
    parseChildren() { if (this.remaining === "")
        return {}; this.consumeOptional("/"); let n = []; for (this.peekStartsWith("(") || n.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)
        this.capture("/"), n.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (n.length > 0 || Object.keys(e).length > 0) && (r[d] = new v(n, e)), r; }
    parseSegment() { let n = Tt(this.remaining); if (n === "" && this.peekStartsWith(";"))
        throw new b(4009, !1); return this.capture(n), new Q(Ze(n), this.parseMatrixParams()); }
    parseMatrixParams() { let n = {}; for (; this.consumeOptional(";");)
        this.parseParam(n); return n; }
    parseParam(n) { let e = si(this.remaining); if (!e)
        return; this.capture(e); let r = ""; if (this.consumeOptional("=")) {
        let i = Tt(this.remaining);
        i && (r = i, this.capture(r));
    } n[Ze(e)] = Ze(r); }
    parseQueryParam(n) { let e = ui(this.remaining); if (!e)
        return; this.capture(e); let r = ""; if (this.consumeOptional("=")) {
        let o = li(this.remaining);
        o && (r = o, this.capture(r));
    } let i = lr(e), s = lr(r); if (n.hasOwnProperty(i)) {
        let o = n[i];
        Array.isArray(o) || (o = [o], n[i] = o), o.push(s);
    }
    else
        n[i] = s; }
    parseParens(n) { let e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) {
        let r = Tt(this.remaining), i = this.remaining[r.length];
        if (i !== "/" && i !== ")" && i !== ";")
            throw new b(4010, !1);
        let s;
        r.indexOf(":") > -1 ? (s = r.slice(0, r.indexOf(":")), this.capture(s), this.capture(":")) : n && (s = d);
        let o = this.parseChildren();
        e[s] = Object.keys(o).length === 1 ? o[d] : new v([], o), this.consumeOptional("//");
    } return e; }
    peekStartsWith(n) { return this.remaining.startsWith(n); }
    consumeOptional(n) { return this.peekStartsWith(n) ? (this.remaining = this.remaining.substring(n.length), !0) : !1; }
    capture(n) { if (!this.consumeOptional(n))
        throw new b(4011, !1); }
};
function Dr(t) { return t.segments.length > 0 ? new v([], { [d]: t }) : t; }
function Er(t) { let n = {}; for (let [r, i] of Object.entries(t.children)) {
    let s = Er(i);
    if (r === d && s.segments.length === 0 && s.hasChildren())
        for (let [o, a] of Object.entries(s.children))
            n[o] = a;
    else
        (s.segments.length > 0 || s.hasChildren()) && (n[r] = s);
} let e = new v(t.segments, n); return hi(e); }
function hi(t) { if (t.numberOfChildren === 1 && t.children[d]) {
    let n = t.children[d];
    return new v(t.segments.concat(n.segments), n.children);
} return t; }
function Z(t) { return t instanceof z; }
function Ur(t, n, e = null, r = null) { let i = Nr(t); return Pr(i, n, e, r); }
function Nr(t) { let n; function e(s) { let o = {}; for (let u of s.children) {
    let c = e(u);
    o[u.outlet] = c;
} let a = new v(s.url, o); return s === t && (n = a), a; } let r = e(t.root), i = Dr(r); return n ?? i; }
function Pr(t, n, e, r) { let i = t; for (; i.parent;)
    i = i.parent; if (n.length === 0)
    return Ot(i, i, i, e, r); let s = di(n); if (s.toRoot())
    return Ot(i, i, new v([], {}), e, r); let o = fi(s, i, t), a = o.processChildren ? be(o.segmentGroup, o.index, s.commands) : _r(o.segmentGroup, o.index, s.commands); return Ot(i, o.segmentGroup, a, e, r); }
function Je(t) { return typeof t == "object" && t != null && !t.outlets && !t.segmentPath; }
function Me(t) { return typeof t == "object" && t != null && t.outlets; }
function Ot(t, n, e, r, i) { let s = {}; r && Object.entries(r).forEach(([u, c]) => { s[u] = Array.isArray(c) ? c.map(p => `${p}`) : `${c}`; }); let o; t === n ? o = e : o = xr(t, n, e); let a = Dr(Er(o)); return new z(a, s, i); }
function xr(t, n, e) { let r = {}; return Object.entries(t.children).forEach(([i, s]) => { s === n ? r[i] = e : r[i] = xr(s, n, e); }), new v(t.segments, r); }
var et = class {
    isAbsolute;
    numberOfDoubleDots;
    commands;
    constructor(n, e, r) { if (this.isAbsolute = n, this.numberOfDoubleDots = e, this.commands = r, n && r.length > 0 && Je(r[0]))
        throw new b(4003, !1); let i = r.find(Me); if (i && i !== wr(r))
        throw new b(4004, !1); }
    toRoot() { return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/"; }
};
function di(t) { if (typeof t[0] == "string" && t.length === 1 && t[0] === "/")
    return new et(!0, 0, t); let n = 0, e = !1, r = t.reduce((i, s, o) => { if (typeof s == "object" && s != null) {
    if (s.outlets) {
        let a = {};
        return Object.entries(s.outlets).forEach(([u, c]) => { a[u] = typeof c == "string" ? c.split("/") : c; }), [...i, { outlets: a }];
    }
    if (s.segmentPath)
        return [...i, s.segmentPath];
} return typeof s != "string" ? [...i, s] : o === 0 ? (s.split("/").forEach((a, u) => { u == 0 && a === "." || (u == 0 && a === "" ? e = !0 : a === ".." ? n++ : a != "" && i.push(a)); }), i) : [...i, s]; }, []); return new et(e, n, r); }
var he = class {
    segmentGroup;
    processChildren;
    index;
    constructor(n, e, r) { this.segmentGroup = n, this.processChildren = e, this.index = r; }
};
function fi(t, n, e) { if (t.isAbsolute)
    return new he(n, !0, 0); if (!e)
    return new he(n, !1, NaN); if (e.parent === null)
    return new he(e, !0, 0); let r = Je(t.commands[0]) ? 0 : 1, i = e.segments.length - 1 + r; return pi(e, i, t.numberOfDoubleDots); }
function pi(t, n, e) { let r = t, i = n, s = e; for (; s > i;) {
    if (s -= i, r = r.parent, !r)
        throw new b(4005, !1);
    i = r.segments.length;
} return new he(r, !1, i - s); }
function gi(t) { return Me(t[0]) ? t[0].outlets : { [d]: t }; }
function _r(t, n, e) { if (t ??= new v([], {}), t.segments.length === 0 && t.hasChildren())
    return be(t, n, e); let r = vi(t, n, e), i = e.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) {
    let s = new v(t.segments.slice(0, r.pathIndex), {});
    return s.children[d] = new v(t.segments.slice(r.pathIndex), t.children), be(s, 0, i);
}
else
    return r.match && i.length === 0 ? new v(t.segments, {}) : r.match && !t.hasChildren() ? _t(t, n, e) : r.match ? be(t, 0, i) : _t(t, n, e); }
function be(t, n, e) { if (e.length === 0)
    return new v(t.segments, {}); {
    let r = gi(e), i = {};
    if (Object.keys(r).some(s => s !== d) && t.children[d] && t.numberOfChildren === 1 && t.children[d].segments.length === 0) {
        let s = be(t.children[d], n, e);
        return new v(t.segments, s.children);
    }
    return Object.entries(r).forEach(([s, o]) => { typeof o == "string" && (o = [o]), o !== null && (i[s] = _r(t.children[s], n, o)); }), Object.entries(t.children).forEach(([s, o]) => { r[s] === void 0 && (i[s] = o); }), new v(t.segments, i);
} }
function vi(t, n, e) { let r = 0, i = n, s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < t.segments.length;) {
    if (r >= e.length)
        return s;
    let o = t.segments[i], a = e[r];
    if (Me(a))
        break;
    let u = `${a}`, c = r < e.length - 1 ? e[r + 1] : null;
    if (i > 0 && u === void 0)
        break;
    if (u && c && typeof c == "object" && c.outlets === void 0) {
        if (!dr(u, c, o))
            return s;
        r += 2;
    }
    else {
        if (!dr(u, {}, o))
            return s;
        r++;
    }
    i++;
} return { match: !0, pathIndex: i, commandIndex: r }; }
function _t(t, n, e) { let r = t.segments.slice(0, n), i = 0; for (; i < e.length;) {
    let s = e[i];
    if (Me(s)) {
        let u = mi(s.outlets);
        return new v(r, u);
    }
    if (i === 0 && Je(e[0])) {
        let u = t.segments[n];
        r.push(new Q(u.path, hr(e[0]))), i++;
        continue;
    }
    let o = Me(s) ? s.outlets[d] : `${s}`, a = i < e.length - 1 ? e[i + 1] : null;
    o && a && Je(a) ? (r.push(new Q(o, hr(a))), i += 2) : (r.push(new Q(o, {})), i++);
} return new v(r, {}); }
function mi(t) { let n = {}; return Object.entries(t).forEach(([e, r]) => { typeof r == "string" && (r = [r]), r !== null && (n[e] = _t(new v([], {}), 0, r)); }), n; }
function hr(t) { let n = {}; return Object.entries(t).forEach(([e, r]) => n[e] = `${r}`), n; }
function dr(t, n, e) { return t == e.path && k(n, e.parameters); }
var Ye = "imperative", S = function (t) { return t[t.NavigationStart = 0] = "NavigationStart", t[t.NavigationEnd = 1] = "NavigationEnd", t[t.NavigationCancel = 2] = "NavigationCancel", t[t.NavigationError = 3] = "NavigationError", t[t.RoutesRecognized = 4] = "RoutesRecognized", t[t.ResolveStart = 5] = "ResolveStart", t[t.ResolveEnd = 6] = "ResolveEnd", t[t.GuardsCheckStart = 7] = "GuardsCheckStart", t[t.GuardsCheckEnd = 8] = "GuardsCheckEnd", t[t.RouteConfigLoadStart = 9] = "RouteConfigLoadStart", t[t.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd", t[t.ChildActivationStart = 11] = "ChildActivationStart", t[t.ChildActivationEnd = 12] = "ChildActivationEnd", t[t.ActivationStart = 13] = "ActivationStart", t[t.ActivationEnd = 14] = "ActivationEnd", t[t.Scroll = 15] = "Scroll", t[t.NavigationSkipped = 16] = "NavigationSkipped", t; }(S || {}), O = class {
    id;
    url;
    constructor(n, e) { this.id = n, this.url = e; }
}, Y = class extends O {
    type = S.NavigationStart;
    navigationTrigger;
    restoredState;
    constructor(n, e, r = "imperative", i = null) { super(n, e), this.navigationTrigger = r, this.restoredState = i; }
    toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')`; }
}, M = class extends O {
    urlAfterRedirects;
    type = S.NavigationEnd;
    constructor(n, e, r) { super(n, e), this.urlAfterRedirects = r; }
    toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`; }
}, I = function (t) { return t[t.Redirect = 0] = "Redirect", t[t.SupersededByNewNavigation = 1] = "SupersededByNewNavigation", t[t.NoDataFromResolver = 2] = "NoDataFromResolver", t[t.GuardRejected = 3] = "GuardRejected", t; }(I || {}), fe = function (t) { return t[t.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation", t[t.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy", t; }(fe || {}), L = class extends O {
    reason;
    code;
    type = S.NavigationCancel;
    constructor(n, e, r, i) { super(n, e), this.reason = r, this.code = i; }
    toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')`; }
}, F = class extends O {
    reason;
    code;
    type = S.NavigationSkipped;
    constructor(n, e, r, i) { super(n, e), this.reason = r, this.code = i; }
}, pe = class extends O {
    error;
    target;
    type = S.NavigationError;
    constructor(n, e, r, i) { super(n, e), this.error = r, this.target = i; }
    toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`; }
}, De = class extends O {
    urlAfterRedirects;
    state;
    type = S.RoutesRecognized;
    constructor(n, e, r, i) { super(n, e), this.urlAfterRedirects = r, this.state = i; }
    toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`; }
}, tt = class extends O {
    urlAfterRedirects;
    state;
    type = S.GuardsCheckStart;
    constructor(n, e, r, i) { super(n, e), this.urlAfterRedirects = r, this.state = i; }
    toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`; }
}, rt = class extends O {
    urlAfterRedirects;
    state;
    shouldActivate;
    type = S.GuardsCheckEnd;
    constructor(n, e, r, i, s) { super(n, e), this.urlAfterRedirects = r, this.state = i, this.shouldActivate = s; }
    toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`; }
}, nt = class extends O {
    urlAfterRedirects;
    state;
    type = S.ResolveStart;
    constructor(n, e, r, i) { super(n, e), this.urlAfterRedirects = r, this.state = i; }
    toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`; }
}, it = class extends O {
    urlAfterRedirects;
    state;
    type = S.ResolveEnd;
    constructor(n, e, r, i) { super(n, e), this.urlAfterRedirects = r, this.state = i; }
    toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`; }
}, ot = class {
    route;
    type = S.RouteConfigLoadStart;
    constructor(n) { this.route = n; }
    toString() { return `RouteConfigLoadStart(path: ${this.route.path})`; }
}, st = class {
    route;
    type = S.RouteConfigLoadEnd;
    constructor(n) { this.route = n; }
    toString() { return `RouteConfigLoadEnd(path: ${this.route.path})`; }
}, at = class {
    snapshot;
    type = S.ChildActivationStart;
    constructor(n) { this.snapshot = n; }
    toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`; }
}, ut = class {
    snapshot;
    type = S.ChildActivationEnd;
    constructor(n) { this.snapshot = n; }
    toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`; }
}, ct = class {
    snapshot;
    type = S.ActivationStart;
    constructor(n) { this.snapshot = n; }
    toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`; }
}, lt = class {
    snapshot;
    type = S.ActivationEnd;
    constructor(n) { this.snapshot = n; }
    toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`; }
}, ge = class {
    routerEvent;
    position;
    anchor;
    type = S.Scroll;
    constructor(n, e, r) { this.routerEvent = n, this.position = e, this.anchor = r; }
    toString() { let n = this.position ? `${this.position[0]}, ${this.position[1]}` : null; return `Scroll(anchor: '${this.anchor}', position: '${n}')`; }
}, Ee = class {
}, ve = class {
    url;
    navigationBehaviorOptions;
    constructor(n, e) { this.url = n, this.navigationBehaviorOptions = e; }
};
function Ri(t, n) { return t.providers && !t._injector && (t._injector = An(t.providers, n, `Route: ${t.path}`)), t._injector ?? n; }
function N(t) { return t.outlet || d; }
function Si(t, n) { let e = t.filter(r => N(r) === n); return e.push(...t.filter(r => N(r) !== n)), e; }
function ke(t) { if (!t)
    return null; if (t.routeConfig?._injector)
    return t.routeConfig._injector; for (let n = t.parent; n; n = n.parent) {
    let e = n.routeConfig;
    if (e?._loadedInjector)
        return e._loadedInjector;
    if (e?._injector)
        return e._injector;
} return null; }
var ht = class {
    rootInjector;
    outlet = null;
    route = null;
    children;
    attachRef = null;
    get injector() { return ke(this.route?.snapshot) ?? this.rootInjector; }
    constructor(n) { this.rootInjector = n, this.children = new ae(this.rootInjector); }
}, ae = (() => { class t {
    rootInjector;
    contexts = new Map;
    constructor(e) { this.rootInjector = e; }
    onChildOutletCreated(e, r) { let i = this.getOrCreateContext(e); i.outlet = r, this.contexts.set(e, i); }
    onChildOutletDestroyed(e) { let r = this.getContext(e); r && (r.outlet = null, r.attachRef = null); }
    onOutletDeactivated() { let e = this.contexts; return this.contexts = new Map, e; }
    onOutletReAttached(e) { this.contexts = e; }
    getOrCreateContext(e) { let r = this.getContext(e); return r || (r = new ht(this.rootInjector), this.contexts.set(e, r)), r; }
    getContext(e) { return this.contexts.get(e) || null; }
    static ɵfac = function (r) { return new (r || t)(m.ɵɵinject(m.EnvironmentInjector)); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), dt = class {
    _root;
    constructor(n) { this._root = n; }
    get root() { return this._root.value; }
    parent(n) { let e = this.pathFromRoot(n); return e.length > 1 ? e[e.length - 2] : null; }
    children(n) { let e = jt(n, this._root); return e ? e.children.map(r => r.value) : []; }
    firstChild(n) { let e = jt(n, this._root); return e && e.children.length > 0 ? e.children[0].value : null; }
    siblings(n) { let e = kt(n, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(i => i.value).filter(i => i !== n); }
    pathFromRoot(n) { return kt(n, this._root).map(e => e.value); }
};
function jt(t, n) { if (t === n.value)
    return n; for (let e of n.children) {
    let r = jt(t, e);
    if (r)
        return r;
} return null; }
function kt(t, n) { if (t === n.value)
    return [n]; for (let e of n.children) {
    let r = kt(t, e);
    if (r.length)
        return r.unshift(n), r;
} return []; }
var T = class {
    value;
    children;
    constructor(n, e) { this.value = n, this.children = e; }
    toString() { return `TreeNode(${this.value})`; }
};
function le(t) { let n = {}; return t && t.children.forEach(e => n[e.value.outlet] = e), n; }
var Ue = class extends dt {
    snapshot;
    constructor(n, e) { super(n), this.snapshot = e, Gt(this, n); }
    toString() { return this.snapshot.toString(); }
};
function jr(t) { let n = yi(t), e = new U([new Q("", {})]), r = new U({}), i = new U({}), s = new U({}), o = new U(""), a = new q(e, r, s, o, i, d, t, n.root); return a.snapshot = n.root, new Ue(new T(a, []), n); }
function yi(t) { let n = {}, e = {}, r = {}, i = "", s = new ne([], n, r, i, e, d, t, null, {}); return new Ne("", new T(s, [])); }
var q = class {
    urlSubject;
    paramsSubject;
    queryParamsSubject;
    fragmentSubject;
    dataSubject;
    outlet;
    component;
    snapshot;
    _futureSnapshot;
    _routerState;
    _paramMap;
    _queryParamMap;
    title;
    url;
    params;
    queryParams;
    fragment;
    data;
    constructor(n, e, r, i, s, o, a, u) { this.urlSubject = n, this.paramsSubject = e, this.queryParamsSubject = r, this.fragmentSubject = i, this.dataSubject = s, this.outlet = o, this.component = a, this._futureSnapshot = u, this.title = this.dataSubject?.pipe(R(c => c[je])) ?? f(void 0), this.url = n, this.params = e, this.queryParams = r, this.fragment = i, this.data = s; }
    get routeConfig() { return this._futureSnapshot.routeConfig; }
    get root() { return this._routerState.root; }
    get parent() { return this._routerState.parent(this); }
    get firstChild() { return this._routerState.firstChild(this); }
    get children() { return this._routerState.children(this); }
    get pathFromRoot() { return this._routerState.pathFromRoot(this); }
    get paramMap() { return this._paramMap ??= this.params.pipe(R(n => ie(n))), this._paramMap; }
    get queryParamMap() { return this._queryParamMap ??= this.queryParams.pipe(R(n => ie(n))), this._queryParamMap; }
    toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`; }
};
function ft(t, n, e = "emptyOnly") { let r, { routeConfig: i } = t; return n !== null && (e === "always" || i?.path === "" || !n.component && !n.routeConfig?.loadComponent) ? r = { params: h(h({}, n.params), t.params), data: h(h({}, n.data), t.data), resolve: h(h(h(h({}, t.data), n.data), i?.data), t._resolvedData) } : r = { params: h({}, t.params), data: h({}, t.data), resolve: h(h({}, t.data), t._resolvedData ?? {}) }, i && Lr(i) && (r.resolve[je] = i.title), r; }
var ne = class {
    url;
    params;
    queryParams;
    fragment;
    data;
    outlet;
    component;
    routeConfig;
    _resolve;
    _resolvedData;
    _routerState;
    _paramMap;
    _queryParamMap;
    get title() { return this.data?.[je]; }
    constructor(n, e, r, i, s, o, a, u, c) { this.url = n, this.params = e, this.queryParams = r, this.fragment = i, this.data = s, this.outlet = o, this.component = a, this.routeConfig = u, this._resolve = c; }
    get root() { return this._routerState.root; }
    get parent() { return this._routerState.parent(this); }
    get firstChild() { return this._routerState.firstChild(this); }
    get children() { return this._routerState.children(this); }
    get pathFromRoot() { return this._routerState.pathFromRoot(this); }
    get paramMap() { return this._paramMap ??= ie(this.params), this._paramMap; }
    get queryParamMap() { return this._queryParamMap ??= ie(this.queryParams), this._queryParamMap; }
    toString() { let n = this.url.map(r => r.toString()).join("/"), e = this.routeConfig ? this.routeConfig.path : ""; return `Route(url:'${n}', path:'${e}')`; }
}, Ne = class extends dt {
    url;
    constructor(n, e) { super(e), this.url = n, Gt(this, e); }
    toString() { return kr(this._root); }
};
function Gt(t, n) { n.value._routerState = t, n.children.forEach(e => Gt(t, e)); }
function kr(t) { let n = t.children.length > 0 ? ` { ${t.children.map(kr).join(", ")} } ` : ""; return `${t.value}${n}`; }
function Mt(t) { if (t.snapshot) {
    let n = t.snapshot, e = t._futureSnapshot;
    t.snapshot = e, k(n.queryParams, e.queryParams) || t.queryParamsSubject.next(e.queryParams), n.fragment !== e.fragment && t.fragmentSubject.next(e.fragment), k(n.params, e.params) || t.paramsSubject.next(e.params), Qn(n.url, e.url) || t.urlSubject.next(e.url), k(n.data, e.data) || t.dataSubject.next(e.data);
}
else
    t.snapshot = t._futureSnapshot, t.dataSubject.next(t._futureSnapshot.data); }
function Lt(t, n) { let e = k(t.params, n.params) && Xn(t.url, n.url), r = !t.parent != !n.parent; return e && !r && (!t.parent || Lt(t.parent, n.parent)); }
function Lr(t) { return typeof t.title == "string" || t.title === null; }
var $r = new oe(""), Qt = (() => { class t {
    activated = null;
    get activatedComponentRef() { return this.activated; }
    _activatedRoute = null;
    name = d;
    activateEvents = new He;
    deactivateEvents = new He;
    attachEvents = new He;
    detachEvents = new He;
    routerOutletData = Tn(void 0);
    parentContexts = g(ae);
    location = g(On);
    changeDetector = g(Mn);
    inputBinder = g(Le, { optional: !0 });
    supportsBindingToComponentInputs = !0;
    ngOnChanges(e) { if (e.name) {
        let { firstChange: r, previousValue: i } = e.name;
        if (r)
            return;
        this.isTrackedInParentContexts(i) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(i)), this.initializeOutletWithName();
    } }
    ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this); }
    isTrackedInParentContexts(e) { return this.parentContexts.getContext(e)?.outlet === this; }
    ngOnInit() { this.initializeOutletWithName(); }
    initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated)
        return; let e = this.parentContexts.getContext(this.name); e?.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.injector)); }
    get isActivated() { return !!this.activated; }
    get component() { if (!this.activated)
        throw new b(4012, !1); return this.activated.instance; }
    get activatedRoute() { if (!this.activated)
        throw new b(4012, !1); return this._activatedRoute; }
    get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {}; }
    detach() { if (!this.activated)
        throw new b(4012, !1); this.location.detach(); let e = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e; }
    attach(e, r) { this.activated = e, this._activatedRoute = r, this.location.insert(e.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(e.instance); }
    deactivate() { if (this.activated) {
        let e = this.component;
        this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e);
    } }
    activateWith(e, r) { if (this.isActivated)
        throw new b(4013, !1); this._activatedRoute = e; let i = this.location, o = e.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, u = new $t(e, a, i.injector, this.routerOutletData); this.activated = i.createComponent(o, { index: i.length, injector: u, environmentInjector: r }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance); }
    static ɵfac = function (r) { return new (r || t); };
    static ɵdir = m.ɵɵdefineDirective({ type: t, selectors: [["router-outlet"]], inputs: { name: "name", routerOutletData: [1, "routerOutletData"] }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], features: [m.ɵɵNgOnChangesFeature] });
} return t; })(), $t = class {
    route;
    childContexts;
    parent;
    outletData;
    constructor(n, e, r, i) { this.route = n, this.childContexts = e, this.parent = r, this.outletData = i; }
    get(n, e) { return n === q ? this.route : n === ae ? this.childContexts : n === $r ? this.outletData : this.parent.get(n, e); }
}, Le = new oe(""), Kt = (() => { class t {
    outletDataSubscriptions = new Map;
    bindActivatedRouteToOutletComponent(e) { this.unsubscribeFromRouteData(e), this.subscribeToRouteData(e); }
    unsubscribeFromRouteData(e) { this.outletDataSubscriptions.get(e)?.unsubscribe(), this.outletDataSubscriptions.delete(e); }
    subscribeToRouteData(e) { let { activatedRoute: r } = e, i = Wt([r.queryParams, r.params, r.data]).pipe(j(([s, o, a], u) => (a = h(h(h({}, s), o), a), u === 0 ? f(a) : Promise.resolve(a)))).subscribe(s => { if (!e.isActivated || !e.activatedComponentRef || e.activatedRoute !== r || r.component === null) {
        this.unsubscribeFromRouteData(e);
        return;
    } let o = Dn(r.component); if (!o) {
        this.unsubscribeFromRouteData(e);
        return;
    } for (let { templateName: a } of o.inputs)
        e.activatedComponentRef.setInput(a, s[a]); }); this.outletDataSubscriptions.set(e, i); }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac });
} return t; })(), Zt = (() => { class t {
    static ɵfac = function (r) { return new (r || t); };
    static ɵcmp = m.ɵɵdefineComponent({ type: t, selectors: [["ng-component"]], exportAs: ["emptyRouterOutlet"], decls: 1, vars: 0, template: function (r, i) { r & 1 && m.ɵɵelement(0, "router-outlet"); }, dependencies: [Qt], encapsulation: 2 });
} return t; })();
function Yt(t) { let n = t.children && t.children.map(Yt), e = n ? D(h({}, t), { children: n }) : h({}, t); return !e.component && !e.loadComponent && (n || e.loadChildren) && e.outlet && e.outlet !== d && (e.component = Zt), e; }
function Ci(t, n, e) { let r = Pe(t, n._root, e ? e._root : void 0); return new Ue(r, n); }
function Pe(t, n, e) { if (e && t.shouldReuseRoute(n.value, e.value.snapshot)) {
    let r = e.value;
    r._futureSnapshot = n.value;
    let i = wi(t, n, e);
    return new T(r, i);
}
else {
    if (t.shouldAttach(n.value)) {
        let s = t.retrieve(n.value);
        if (s !== null) {
            let o = s.route;
            return o.value._futureSnapshot = n.value, o.children = n.children.map(a => Pe(t, a)), o;
        }
    }
    let r = bi(n.value), i = n.children.map(s => Pe(t, s));
    return new T(r, i);
} }
function wi(t, n, e) { return n.children.map(r => { for (let i of e.children)
    if (t.shouldReuseRoute(r.value, i.value.snapshot))
        return Pe(t, r, i); return Pe(t, r); }); }
function bi(t) { return new q(new U(t.url), new U(t.params), new U(t.queryParams), new U(t.fragment), new U(t.data), t.outlet, t.component, t); }
var me = class {
    redirectTo;
    navigationBehaviorOptions;
    constructor(n, e) { this.redirectTo = n, this.navigationBehaviorOptions = e; }
}, zr = "ngNavigationCancelingError";
function pt(t, n) { let { redirectTo: e, navigationBehaviorOptions: r } = Z(n) ? { redirectTo: n, navigationBehaviorOptions: void 0 } : n, i = Fr(!1, I.Redirect); return i.url = e, i.navigationBehaviorOptions = r, i; }
function Fr(t, n) { let e = new Error(`NavigationCancelingError: ${t || ""}`); return e[zr] = !0, e.cancellationCode = n, e; }
function Ii(t) { return qr(t) && Z(t.url); }
function qr(t) { return !!t && t[zr]; }
var Ai = (t, n, e, r) => R(i => (new zt(n, i.targetRouterState, i.currentRouterState, e, r).activate(t), i)), zt = class {
    routeReuseStrategy;
    futureState;
    currState;
    forwardEvent;
    inputBindingEnabled;
    constructor(n, e, r, i, s) { this.routeReuseStrategy = n, this.futureState = e, this.currState = r, this.forwardEvent = i, this.inputBindingEnabled = s; }
    activate(n) { let e = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, r, n), Mt(this.futureState.root), this.activateChildRoutes(e, r, n); }
    deactivateChildRoutes(n, e, r) { let i = le(e); n.children.forEach(s => { let o = s.value.outlet; this.deactivateRoutes(s, i[o], r), delete i[o]; }), Object.values(i).forEach(s => { this.deactivateRouteAndItsChildren(s, r); }); }
    deactivateRoutes(n, e, r) { let i = n.value, s = e ? e.value : null; if (i === s) {
        if (i.component) {
            let o = r.getContext(i.outlet);
            o && this.deactivateChildRoutes(n, e, o.children);
        }
        else
            this.deactivateChildRoutes(n, e, r);
    }
    else
        s && this.deactivateRouteAndItsChildren(e, r); }
    deactivateRouteAndItsChildren(n, e) { n.value.component && this.routeReuseStrategy.shouldDetach(n.value.snapshot) ? this.detachAndStoreRouteSubtree(n, e) : this.deactivateRouteAndOutlet(n, e); }
    detachAndStoreRouteSubtree(n, e) { let r = e.getContext(n.value.outlet), i = r && n.value.component ? r.children : e, s = le(n); for (let o of Object.values(s))
        this.deactivateRouteAndItsChildren(o, i); if (r && r.outlet) {
        let o = r.outlet.detach(), a = r.children.onOutletDeactivated();
        this.routeReuseStrategy.store(n.value.snapshot, { componentRef: o, route: n, contexts: a });
    } }
    deactivateRouteAndOutlet(n, e) { let r = e.getContext(n.value.outlet), i = r && n.value.component ? r.children : e, s = le(n); for (let o of Object.values(s))
        this.deactivateRouteAndItsChildren(o, i); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null); }
    activateChildRoutes(n, e, r) { let i = le(e); n.children.forEach(s => { this.activateRoutes(s, i[s.value.outlet], r), this.forwardEvent(new lt(s.value.snapshot)); }), n.children.length && this.forwardEvent(new ut(n.value.snapshot)); }
    activateRoutes(n, e, r) { let i = n.value, s = e ? e.value : null; if (Mt(i), i === s) {
        if (i.component) {
            let o = r.getOrCreateContext(i.outlet);
            this.activateChildRoutes(n, e, o.children);
        }
        else
            this.activateChildRoutes(n, e, r);
    }
    else if (i.component) {
        let o = r.getOrCreateContext(i.outlet);
        if (this.routeReuseStrategy.shouldAttach(i.snapshot)) {
            let a = this.routeReuseStrategy.retrieve(i.snapshot);
            this.routeReuseStrategy.store(i.snapshot, null), o.children.onOutletReAttached(a.contexts), o.attachRef = a.componentRef, o.route = a.route.value, o.outlet && o.outlet.attach(a.componentRef, a.route.value), Mt(a.route.value), this.activateChildRoutes(n, null, o.children);
        }
        else
            o.attachRef = null, o.route = i, o.outlet && o.outlet.activateWith(i, o.injector), this.activateChildRoutes(n, null, o.children);
    }
    else
        this.activateChildRoutes(n, null, r); }
}, gt = class {
    path;
    route;
    constructor(n) { this.path = n, this.route = this.path[this.path.length - 1]; }
}, de = class {
    component;
    route;
    constructor(n, e) { this.component = n, this.route = e; }
};
function Ti(t, n, e) { let r = t._root, i = n ? n._root : null; return Ce(r, i, e, [r.value]); }
function Oi(t) { let n = t.routeConfig ? t.routeConfig.canActivateChild : null; return !n || n.length === 0 ? null : { node: t, guards: n }; }
function Se(t, n) { let e = Symbol(), r = n.get(t, e); return r === e ? typeof t == "function" && !En(t) ? t : n.get(t) : r; }
function Ce(t, n, e, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { let s = le(n); return t.children.forEach(o => { Mi(o, s[o.value.outlet], e, r.concat([o.value]), i), delete s[o.value.outlet]; }), Object.entries(s).forEach(([o, a]) => Ie(a, e.getContext(o), i)), i; }
function Mi(t, n, e, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { let s = t.value, o = n ? n.value : null, a = e ? e.getContext(t.value.outlet) : null; if (o && s.routeConfig === o.routeConfig) {
    let u = Di(o, s, s.routeConfig.runGuardsAndResolvers);
    u ? i.canActivateChecks.push(new gt(r)) : (s.data = o.data, s._resolvedData = o._resolvedData), s.component ? Ce(t, n, a ? a.children : null, r, i) : Ce(t, n, e, r, i), u && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new de(a.outlet.component, o));
}
else
    o && Ie(n, a, i), i.canActivateChecks.push(new gt(r)), s.component ? Ce(t, null, a ? a.children : null, r, i) : Ce(t, null, e, r, i); return i; }
function Di(t, n, e) { if (typeof e == "function")
    return e(t, n); switch (e) {
    case "pathParamsChange": return !re(t.url, n.url);
    case "pathParamsOrQueryParamsChange": return !re(t.url, n.url) || !k(t.queryParams, n.queryParams);
    case "always": return !0;
    case "paramsOrQueryParamsChange": return !Lt(t, n) || !k(t.queryParams, n.queryParams);
    case "paramsChange":
    default: return !Lt(t, n);
} }
function Ie(t, n, e) { let r = le(t), i = t.value; Object.entries(r).forEach(([s, o]) => { i.component ? n ? Ie(o, n.children.getContext(s), e) : Ie(o, null, e) : Ie(o, n, e); }), i.component ? n && n.outlet && n.outlet.isActivated ? e.canDeactivateChecks.push(new de(n.outlet.component, i)) : e.canDeactivateChecks.push(new de(null, i)) : e.canDeactivateChecks.push(new de(null, i)); }
function $e(t) { return typeof t == "function"; }
function Ei(t) { return typeof t == "boolean"; }
function Ui(t) { return t && $e(t.canLoad); }
function Ni(t) { return t && $e(t.canActivate); }
function Pi(t) { return t && $e(t.canActivateChild); }
function xi(t) { return t && $e(t.canDeactivate); }
function _i(t) { return t && $e(t.canMatch); }
function Br(t) { return t instanceof zn || t?.name === "EmptyError"; }
var Ge = Symbol("INITIAL_VALUE");
function Re() { return j(t => Wt(t.map(n => n.pipe(Te(1), Vn(Ge)))).pipe(R(n => { for (let e of n)
    if (e !== !0) {
        if (e === Ge)
            return Ge;
        if (e === !1 || ji(e))
            return e;
    } return !0; }), Oe(n => n !== Ge), Te(1))); }
function ji(t) { return Z(t) || t instanceof me; }
function ki(t, n) { return P(e => { let { targetSnapshot: r, currentSnapshot: i, guards: { canActivateChecks: s, canDeactivateChecks: o } } = e; return o.length === 0 && s.length === 0 ? f(D(h({}, e), { guardsResult: !0 })) : Li(o, r, i, t).pipe(P(a => a && Ei(a) ? $i(r, s, t, n) : f(a)), R(a => D(h({}, e), { guardsResult: a }))); }); }
function Li(t, n, e, r) { return $(t).pipe(P(i => Vi(i.component, i.route, e, n, r)), se(i => i !== !0, !0)); }
function $i(t, n, e, r) { return $(n).pipe(Xe(i => Fn(Fi(i.route.parent, r), zi(i.route, r), Bi(t, i.path, e), qi(t, i.route, e))), se(i => i !== !0, !0)); }
function zi(t, n) { return t !== null && n && n(new ct(t)), f(!0); }
function Fi(t, n) { return t !== null && n && n(new at(t)), f(!0); }
function qi(t, n, e) { let r = n.routeConfig ? n.routeConfig.canActivate : null; if (!r || r.length === 0)
    return f(!0); let i = r.map(s => vr(() => { let o = ke(n) ?? e, a = Se(s, o), u = Ni(a) ? a.canActivate(n, t) : H(o, () => a(n, t)); return X(u).pipe(se()); })); return f(i).pipe(Re()); }
function Bi(t, n, e) { let r = n[n.length - 1], s = n.slice(0, n.length - 1).reverse().map(o => Oi(o)).filter(o => o !== null).map(o => vr(() => { let a = o.guards.map(u => { let c = ke(o.node) ?? e, p = Se(u, c), y = Pi(p) ? p.canActivateChild(r, t) : H(c, () => p(r, t)); return X(y).pipe(se()); }); return f(a).pipe(Re()); })); return f(s).pipe(Re()); }
function Vi(t, n, e, r, i) { let s = n && n.routeConfig ? n.routeConfig.canDeactivate : null; if (!s || s.length === 0)
    return f(!0); let o = s.map(a => { let u = ke(n) ?? i, c = Se(a, u), p = xi(c) ? c.canDeactivate(t, n, e, r) : H(u, () => c(t, n, e, r)); return X(p).pipe(se()); }); return f(o).pipe(Re()); }
function Hi(t, n, e, r) { let i = n.canLoad; if (i === void 0 || i.length === 0)
    return f(!0); let s = i.map(o => { let a = Se(o, t), u = Ui(a) ? a.canLoad(n, e) : H(t, () => a(n, e)); return X(u); }); return f(s).pipe(Re(), Vr(r)); }
function Vr(t) { return qn(w(n => { if (typeof n != "boolean")
    throw pt(t, n); }), R(n => n === !0)); }
function Wi(t, n, e, r) { let i = n.canMatch; if (!i || i.length === 0)
    return f(!0); let s = i.map(o => { let a = Se(o, t), u = _i(a) ? a.canMatch(n, e) : H(t, () => a(n, e)); return X(u); }); return f(s).pipe(Re(), Vr(r)); }
var xe = class {
    segmentGroup;
    constructor(n) { this.segmentGroup = n || null; }
}, _e = class extends Error {
    urlTree;
    constructor(n) { super(), this.urlTree = n; }
};
function ce(t) { return mt(new xe(t)); }
function Gi(t) { return mt(new b(4e3, !1)); }
function Qi(t) { return mt(Fr(!1, I.GuardRejected)); }
var Ft = class {
    urlSerializer;
    urlTree;
    constructor(n, e) { this.urlSerializer = n, this.urlTree = e; }
    lineralizeSegments(n, e) { let r = [], i = e.root; for (;;) {
        if (r = r.concat(i.segments), i.numberOfChildren === 0)
            return f(r);
        if (i.numberOfChildren > 1 || !i.children[d])
            return Gi(`${n.redirectTo}`);
        i = i.children[d];
    } }
    applyRedirectCommands(n, e, r, i, s) { if (typeof e != "string") {
        let a = e, { queryParams: u, fragment: c, routeConfig: p, url: y, outlet: A, params: _, data: C, title: W } = i, V = H(s, () => a({ params: _, data: C, queryParams: u, fragment: c, routeConfig: p, url: y, outlet: A, title: W }));
        if (V instanceof z)
            throw new _e(V);
        e = V;
    } let o = this.applyRedirectCreateUrlTree(e, this.urlSerializer.parse(e), n, r); if (e[0] === "/")
        throw new _e(o); return o; }
    applyRedirectCreateUrlTree(n, e, r, i) { let s = this.createSegmentGroup(n, e.root, r, i); return new z(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment); }
    createQueryParams(n, e) { let r = {}; return Object.entries(n).forEach(([i, s]) => { if (typeof s == "string" && s[0] === ":") {
        let a = s.substring(1);
        r[i] = e[a];
    }
    else
        r[i] = s; }), r; }
    createSegmentGroup(n, e, r, i) { let s = this.createSegments(n, e.segments, r, i), o = {}; return Object.entries(e.children).forEach(([a, u]) => { o[a] = this.createSegmentGroup(n, u, r, i); }), new v(s, o); }
    createSegments(n, e, r, i) { return e.map(s => s.path[0] === ":" ? this.findPosParam(n, s, i) : this.findOrReturn(s, r)); }
    findPosParam(n, e, r) { let i = r[e.path.substring(1)]; if (!i)
        throw new b(4001, !1); return i; }
    findOrReturn(n, e) { let r = 0; for (let i of e) {
        if (i.path === n.path)
            return e.splice(r), i;
        r++;
    } return n; }
}, qt = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} };
function Ki(t, n, e, r, i) { let s = Hr(t, n, e); return s.matched ? (r = Ri(n, r), Wi(r, n, e, i).pipe(R(o => o === !0 ? s : h({}, qt)))) : f(s); }
function Hr(t, n, e) { if (n.path === "**")
    return Zi(e); if (n.path === "")
    return n.pathMatch === "full" && (t.hasChildren() || e.length > 0) ? h({}, qt) : { matched: !0, consumedSegments: [], remainingSegments: e, parameters: {}, positionalParamSegments: {} }; let i = (n.matcher || yr)(e, t, n); if (!i)
    return h({}, qt); let s = {}; Object.entries(i.posParams ?? {}).forEach(([a, u]) => { s[a] = u.path; }); let o = i.consumed.length > 0 ? h(h({}, s), i.consumed[i.consumed.length - 1].parameters) : s; return { matched: !0, consumedSegments: i.consumed, remainingSegments: e.slice(i.consumed.length), parameters: o, positionalParamSegments: i.posParams ?? {} }; }
function Zi(t) { return { matched: !0, parameters: t.length > 0 ? wr(t).parameters : {}, consumedSegments: t, remainingSegments: [], positionalParamSegments: {} }; }
function fr(t, n, e, r) { return e.length > 0 && Ji(t, e, r) ? { segmentGroup: new v(n, Xi(r, new v(e, t.children))), slicedSegments: [] } : e.length === 0 && eo(t, e, r) ? { segmentGroup: new v(t.segments, Yi(t, e, r, t.children)), slicedSegments: e } : { segmentGroup: new v(t.segments, t.children), slicedSegments: e }; }
function Yi(t, n, e, r) { let i = {}; for (let s of e)
    if (Rt(t, n, s) && !r[N(s)]) {
        let o = new v([], {});
        i[N(s)] = o;
    } return h(h({}, r), i); }
function Xi(t, n) { let e = {}; e[d] = n; for (let r of t)
    if (r.path === "" && N(r) !== d) {
        let i = new v([], {});
        e[N(r)] = i;
    } return e; }
function Ji(t, n, e) { return e.some(r => Rt(t, n, r) && N(r) !== d); }
function eo(t, n, e) { return e.some(r => Rt(t, n, r)); }
function Rt(t, n, e) { return (t.hasChildren() || n.length > 0) && e.pathMatch === "full" ? !1 : e.path === ""; }
function to(t, n, e) { return n.length === 0 && !t.children[e]; }
var Bt = class {
};
function ro(t, n, e, r, i, s, o = "emptyOnly") { return new Vt(t, n, e, r, i, o, s).recognize(); }
var no = 31, Vt = class {
    injector;
    configLoader;
    rootComponentType;
    config;
    urlTree;
    paramsInheritanceStrategy;
    urlSerializer;
    applyRedirects;
    absoluteRedirectCount = 0;
    allowRedirects = !0;
    constructor(n, e, r, i, s, o, a) { this.injector = n, this.configLoader = e, this.rootComponentType = r, this.config = i, this.urlTree = s, this.paramsInheritanceStrategy = o, this.urlSerializer = a, this.applyRedirects = new Ft(this.urlSerializer, this.urlTree); }
    noMatchError(n) { return new b(4002, `'${n.segmentGroup}'`); }
    recognize() { let n = fr(this.urlTree.root, [], [], this.config).segmentGroup; return this.match(n).pipe(R(({ children: e, rootSnapshot: r }) => { let i = new T(r, e), s = new Ne("", i), o = Ur(r, [], this.urlTree.queryParams, this.urlTree.fragment); return o.queryParams = this.urlTree.queryParams, s.url = this.urlSerializer.serialize(o), { state: s, tree: o }; })); }
    match(n) { let e = new ne([], Object.freeze({}), Object.freeze(h({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), d, this.rootComponentType, null, {}); return this.processSegmentGroup(this.injector, this.config, n, d, e).pipe(R(r => ({ children: r, rootSnapshot: e })), we(r => { if (r instanceof _e)
        return this.urlTree = r.urlTree, this.match(r.urlTree.root); throw r instanceof xe ? this.noMatchError(r) : r; })); }
    processSegmentGroup(n, e, r, i, s) { return r.segments.length === 0 && r.hasChildren() ? this.processChildren(n, e, r, s) : this.processSegment(n, e, r, r.segments, i, !0, s).pipe(R(o => o instanceof T ? [o] : [])); }
    processChildren(n, e, r, i) { let s = []; for (let o of Object.keys(r.children))
        o === "primary" ? s.unshift(o) : s.push(o); return $(s).pipe(Xe(o => { let a = r.children[o], u = Si(e, o); return this.processSegmentGroup(n, u, a, o, i); }), Hn((o, a) => (o.push(...a), o)), mr(null), Wn(), P(o => { if (o === null)
        return ce(r); let a = Wr(o); return io(a), f(a); })); }
    processSegment(n, e, r, i, s, o, a) { return $(e).pipe(Xe(u => this.processSegmentAgainstRoute(u._injector ?? n, e, u, r, i, s, o, a).pipe(we(c => { if (c instanceof xe)
        return f(null); throw c; }))), se(u => !!u), we(u => { if (Br(u))
        return to(r, i, s) ? f(new Bt) : ce(r); throw u; })); }
    processSegmentAgainstRoute(n, e, r, i, s, o, a, u) { return N(r) !== o && (o === d || !Rt(i, s, r)) ? ce(i) : r.redirectTo === void 0 ? this.matchSegmentAgainstRoute(n, i, r, s, o, u) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(n, i, e, r, s, o, u) : ce(i); }
    expandSegmentAgainstRouteUsingRedirect(n, e, r, i, s, o, a) { let { matched: u, parameters: c, consumedSegments: p, positionalParamSegments: y, remainingSegments: A } = Hr(e, i, s); if (!u)
        return ce(e); typeof i.redirectTo == "string" && i.redirectTo[0] === "/" && (this.absoluteRedirectCount++, this.absoluteRedirectCount > no && (this.allowRedirects = !1)); let _ = new ne(s, c, Object.freeze(h({}, this.urlTree.queryParams)), this.urlTree.fragment, pr(i), N(i), i.component ?? i._loadedComponent ?? null, i, gr(i)), C = ft(_, a, this.paramsInheritanceStrategy); _.params = Object.freeze(C.params), _.data = Object.freeze(C.data); let W = this.applyRedirects.applyRedirectCommands(p, i.redirectTo, y, _, n); return this.applyRedirects.lineralizeSegments(i, W).pipe(P(V => this.processSegment(n, r, e, V.concat(A), o, !1, a))); }
    matchSegmentAgainstRoute(n, e, r, i, s, o) { let a = Ki(e, r, i, n, this.urlSerializer); return r.path === "**" && (e.children = {}), a.pipe(j(u => u.matched ? (n = r._injector ?? n, this.getChildConfig(n, r, i).pipe(j(({ routes: c }) => { let p = r._loadedInjector ?? n, { parameters: y, consumedSegments: A, remainingSegments: _ } = u, C = new ne(A, y, Object.freeze(h({}, this.urlTree.queryParams)), this.urlTree.fragment, pr(r), N(r), r.component ?? r._loadedComponent ?? null, r, gr(r)), W = ft(C, o, this.paramsInheritanceStrategy); C.params = Object.freeze(W.params), C.data = Object.freeze(W.data); let { segmentGroup: V, slicedSegments: At } = fr(e, A, _, c); if (At.length === 0 && V.hasChildren())
        return this.processChildren(p, c, V, C).pipe(R(Ve => new T(C, Ve))); if (c.length === 0 && At.length === 0)
        return f(new T(C, [])); let wn = N(r) === s; return this.processSegment(p, c, V, At, wn ? d : s, !0, C).pipe(R(Ve => new T(C, Ve instanceof T ? [Ve] : []))); }))) : ce(e))); }
    getChildConfig(n, e, r) { return e.children ? f({ routes: e.children, injector: n }) : e.loadChildren ? e._loadedRoutes !== void 0 ? f({ routes: e._loadedRoutes, injector: e._loadedInjector }) : Hi(n, e, r, this.urlSerializer).pipe(P(i => i ? this.configLoader.loadChildren(n, e).pipe(w(s => { e._loadedRoutes = s.routes, e._loadedInjector = s.injector; })) : Qi(e))) : f({ routes: [], injector: n }); }
};
function io(t) { t.sort((n, e) => n.value.outlet === d ? -1 : e.value.outlet === d ? 1 : n.value.outlet.localeCompare(e.value.outlet)); }
function oo(t) { let n = t.value.routeConfig; return n && n.path === ""; }
function Wr(t) { let n = [], e = new Set; for (let r of t) {
    if (!oo(r)) {
        n.push(r);
        continue;
    }
    let i = n.find(s => r.value.routeConfig === s.value.routeConfig);
    i !== void 0 ? (i.children.push(...r.children), e.add(i)) : n.push(r);
} for (let r of e) {
    let i = Wr(r.children);
    n.push(new T(r.value, i));
} return n.filter(r => !e.has(r)); }
function pr(t) { return t.data || {}; }
function gr(t) { return t.resolve || {}; }
function so(t, n, e, r, i, s) { return P(o => ro(t, n, e, r, o.extractedUrl, i, s).pipe(R(({ state: a, tree: u }) => D(h({}, o), { targetSnapshot: a, urlAfterRedirects: u })))); }
function ao(t, n) { return P(e => { let { targetSnapshot: r, guards: { canActivateChecks: i } } = e; if (!i.length)
    return f(e); let s = new Set(i.map(u => u.route)), o = new Set; for (let u of s)
    if (!o.has(u))
        for (let c of Gr(u))
            o.add(c); let a = 0; return $(o).pipe(Xe(u => s.has(u) ? uo(u, r, t, n) : (u.data = ft(u, u.parent, t).resolve, f(void 0))), w(() => a++), Rr(1), P(u => a === o.size ? f(e) : G)); }); }
function Gr(t) { let n = t.children.map(e => Gr(e)).flat(); return [t, ...n]; }
function uo(t, n, e, r) { let i = t.routeConfig, s = t._resolve; return i?.title !== void 0 && !Lr(i) && (s[je] = i.title), co(s, t, n, r).pipe(R(o => (t._resolvedData = o, t.data = ft(t, t.parent, e).resolve, null))); }
function co(t, n, e, r) { let i = Nt(t); if (i.length === 0)
    return f({}); let s = {}; return $(i).pipe(P(o => lo(t[o], n, e, r).pipe(se(), w(a => { if (a instanceof me)
    throw pt(new K, a); s[o] = a; }))), Rr(1), R(() => s), we(o => Br(o) ? G : mt(o))); }
function lo(t, n, e, r) { let i = ke(n) ?? r, s = Se(t, i), o = s.resolve ? s.resolve(n, e) : H(i, () => s(n, e)); return X(o); }
function Dt(t) { return j(n => { let e = t(n); return e ? $(e).pipe(R(() => n)) : f(n); }); }
var Xt = (() => { class t {
    buildTitle(e) { let r, i = e.root; for (; i !== void 0;)
        r = this.getResolvedTitleForRoute(i) ?? r, i = i.children.find(s => s.outlet === d); return r; }
    getResolvedTitleForRoute(e) { return e.data[je]; }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: () => g(Qr), providedIn: "root" });
} return t; })(), Qr = (() => { class t extends Xt {
    title;
    constructor(e) { super(), this.title = e; }
    updateTitle(e) { let r = this.buildTitle(e); r !== void 0 && this.title.setTitle(r); }
    static ɵfac = function (r) { return new (r || t)(m.ɵɵinject(Sr.Title)); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), ee = new oe("", { providedIn: "root", factory: () => ({}) }), te = new oe(""), St = (() => { class t {
    componentLoaders = new WeakMap;
    childrenLoaders = new WeakMap;
    onLoadStartListener;
    onLoadEndListener;
    compiler = g(Nn);
    loadComponent(e) { if (this.componentLoaders.get(e))
        return this.componentLoaders.get(e); if (e._loadedComponent)
        return f(e._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(e); let r = X(e.loadComponent()).pipe(R(Zr), w(s => { this.onLoadEndListener && this.onLoadEndListener(e), e._loadedComponent = s; }), Et(() => { this.componentLoaders.delete(e); })), i = new ar(r, () => new Ae).pipe(ur()); return this.componentLoaders.set(e, i), i; }
    loadChildren(e, r) { if (this.childrenLoaders.get(r))
        return this.childrenLoaders.get(r); if (r._loadedRoutes)
        return f({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); let s = Kr(r, this.compiler, e, this.onLoadEndListener).pipe(Et(() => { this.childrenLoaders.delete(r); })), o = new ar(s, () => new Ae).pipe(ur()); return this.childrenLoaders.set(r, o), o; }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })();
function Kr(t, n, e, r) { return X(t.loadChildren()).pipe(R(Zr), P(i => i instanceof Un || Array.isArray(i) ? f(i) : $(n.compileModuleAsync(i))), R(i => { r && r(t); let s, o, a = !1; return Array.isArray(i) ? (o = i, a = !0) : (s = i.create(e).injector, o = s.get(te, [], { optional: !0, self: !0 }).flat()), { routes: o.map(Yt), injector: s }; })); }
function ho(t) { return t && typeof t == "object" && "default" in t; }
function Zr(t) { return ho(t) ? t.default : t; }
var yt = (() => { class t {
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: () => g(fo), providedIn: "root" });
} return t; })(), fo = (() => { class t {
    shouldProcessUrl(e) { return !0; }
    extract(e) { return e; }
    merge(e, r) { return e; }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), Jt = new oe(""), er = new oe("");
function Yr(t, n, e) { let r = t.get(er), i = t.get(bn); return t.get(Pn).runOutsideAngular(() => { if (!i.startViewTransition || r.skipNextTransition)
    return r.skipNextTransition = !1, new Promise(c => setTimeout(c)); let s, o = new Promise(c => { s = c; }), a = i.startViewTransition(() => (s(), po(t))), { onViewTransitionCreated: u } = r; return u && H(t, () => u({ transition: a, from: n, to: e })), o; }); }
function po(t) { return new Promise(n => { xn({ read: () => setTimeout(n) }, { injector: t }); }); }
var Ct = new oe(""), ze = (() => { class t {
    currentNavigation = null;
    currentTransition = null;
    lastSuccessfulNavigation = null;
    events = new Ae;
    transitionAbortSubject = new Ae;
    configLoader = g(St);
    environmentInjector = g(_n);
    destroyRef = g(jn);
    urlSerializer = g(J);
    rootContexts = g(ae);
    location = g(Ht);
    inputBindingEnabled = g(Le, { optional: !0 }) !== null;
    titleStrategy = g(Xt);
    options = g(ee, { optional: !0 }) || {};
    paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
    urlHandlingStrategy = g(yt);
    createViewTransition = g(Jt, { optional: !0 });
    navigationErrorHandler = g(Ct, { optional: !0 });
    navigationId = 0;
    get hasRequestedNavigation() { return this.navigationId !== 0; }
    transitions;
    afterPreactivation = () => f(void 0);
    rootComponentType = null;
    destroyed = !1;
    constructor() { let e = i => this.events.next(new ot(i)), r = i => this.events.next(new st(i)); this.configLoader.onLoadEndListener = r, this.configLoader.onLoadStartListener = e, this.destroyRef.onDestroy(() => { this.destroyed = !0; }); }
    complete() { this.transitions?.complete(); }
    handleNavigationRequest(e) { let r = ++this.navigationId; this.transitions?.next(D(h({}, e), { extractedUrl: this.urlHandlingStrategy.extract(e.rawUrl), targetSnapshot: null, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null, id: r })); }
    setupNavigations(e) { return this.transitions = new U(null), this.transitions.pipe(Oe(r => r !== null), j(r => { let i = !1, s = !1; return f(r).pipe(j(o => { if (this.navigationId > r.id)
        return this.cancelNavigationTransition(r, "", I.SupersededByNewNavigation), G; this.currentTransition = r, this.currentNavigation = { id: o.id, initialUrl: o.rawUrl, extractedUrl: o.extractedUrl, targetBrowserUrl: typeof o.extras.browserUrl == "string" ? this.urlSerializer.parse(o.extras.browserUrl) : o.extras.browserUrl, trigger: o.source, extras: o.extras, previousNavigation: this.lastSuccessfulNavigation ? D(h({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null }; let a = !e.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl(), u = o.extras.onSameUrlNavigation ?? e.onSameUrlNavigation; if (!a && u !== "reload") {
        let c = "";
        return this.events.next(new F(o.id, this.urlSerializer.serialize(o.rawUrl), c, fe.IgnoredSameUrlNavigation)), o.resolve(!1), G;
    } if (this.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))
        return f(o).pipe(j(c => (this.events.next(new Y(c.id, this.urlSerializer.serialize(c.extractedUrl), c.source, c.restoredState)), c.id !== this.navigationId ? G : Promise.resolve(c))), so(this.environmentInjector, this.configLoader, this.rootComponentType, e.config, this.urlSerializer, this.paramsInheritanceStrategy), w(c => { r.targetSnapshot = c.targetSnapshot, r.urlAfterRedirects = c.urlAfterRedirects, this.currentNavigation = D(h({}, this.currentNavigation), { finalUrl: c.urlAfterRedirects }); let p = new De(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(p); })); if (a && this.urlHandlingStrategy.shouldProcessUrl(o.currentRawUrl)) {
        let { id: c, extractedUrl: p, source: y, restoredState: A, extras: _ } = o, C = new Y(c, this.urlSerializer.serialize(p), y, A);
        this.events.next(C);
        let W = jr(this.rootComponentType).snapshot;
        return this.currentTransition = r = D(h({}, o), { targetSnapshot: W, urlAfterRedirects: p, extras: D(h({}, _), { skipLocationChange: !1, replaceUrl: !1 }) }), this.currentNavigation.finalUrl = p, f(r);
    }
    else {
        let c = "";
        return this.events.next(new F(o.id, this.urlSerializer.serialize(o.extractedUrl), c, fe.IgnoredByUrlHandlingStrategy)), o.resolve(!1), G;
    } }), w(o => { let a = new tt(o.id, this.urlSerializer.serialize(o.extractedUrl), this.urlSerializer.serialize(o.urlAfterRedirects), o.targetSnapshot); this.events.next(a); }), R(o => (this.currentTransition = r = D(h({}, o), { guards: Ti(o.targetSnapshot, o.currentSnapshot, this.rootContexts) }), r)), ki(this.environmentInjector, o => this.events.next(o)), w(o => { if (r.guardsResult = o.guardsResult, o.guardsResult && typeof o.guardsResult != "boolean")
        throw pt(this.urlSerializer, o.guardsResult); let a = new rt(o.id, this.urlSerializer.serialize(o.extractedUrl), this.urlSerializer.serialize(o.urlAfterRedirects), o.targetSnapshot, !!o.guardsResult); this.events.next(a); }), Oe(o => o.guardsResult ? !0 : (this.cancelNavigationTransition(o, "", I.GuardRejected), !1)), Dt(o => { if (o.guards.canActivateChecks.length !== 0)
        return f(o).pipe(w(a => { let u = new nt(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(u); }), j(a => { let u = !1; return f(a).pipe(ao(this.paramsInheritanceStrategy, this.environmentInjector), w({ next: () => u = !0, complete: () => { u || this.cancelNavigationTransition(a, "", I.NoDataFromResolver); } })); }), w(a => { let u = new it(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(u); })); }), Dt(o => { let a = u => { let c = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && c.push(this.configLoader.loadComponent(u.routeConfig).pipe(w(p => { u.component = p; }), R(() => { }))); for (let p of u.children)
        c.push(...a(p)); return c; }; return Wt(a(o.targetSnapshot.root)).pipe(mr(null), Te(1)); }), Dt(() => this.afterPreactivation()), j(() => { let { currentSnapshot: o, targetSnapshot: a } = r, u = this.createViewTransition?.(this.environmentInjector, o.root, a.root); return u ? $(u).pipe(R(() => r)) : f(r); }), R(o => { let a = Ci(e.routeReuseStrategy, o.targetSnapshot, o.currentRouterState); return this.currentTransition = r = D(h({}, o), { targetRouterState: a }), this.currentNavigation.targetRouterState = a, r; }), w(() => { this.events.next(new Ee); }), Ai(this.rootContexts, e.routeReuseStrategy, o => this.events.next(o), this.inputBindingEnabled), Te(1), w({ next: o => { i = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new M(o.id, this.urlSerializer.serialize(o.extractedUrl), this.urlSerializer.serialize(o.urlAfterRedirects))), this.titleStrategy?.updateTitle(o.targetRouterState.snapshot), o.resolve(!0); }, complete: () => { i = !0; } }), Gn(this.transitionAbortSubject.pipe(w(o => { throw o; }))), Et(() => { !i && !s && this.cancelNavigationTransition(r, "", I.SupersededByNewNavigation), this.currentTransition?.id === r.id && (this.currentNavigation = null, this.currentTransition = null); }), we(o => { if (this.destroyed)
        return r.resolve(!1), G; if (s = !0, qr(o))
        this.events.next(new L(r.id, this.urlSerializer.serialize(r.extractedUrl), o.message, o.cancellationCode)), Ii(o) ? this.events.next(new ve(o.url, o.navigationBehaviorOptions)) : r.resolve(!1);
    else {
        let a = new pe(r.id, this.urlSerializer.serialize(r.extractedUrl), o, r.targetSnapshot ?? void 0);
        try {
            let u = H(this.environmentInjector, () => this.navigationErrorHandler?.(a));
            if (u instanceof me) {
                let { message: c, cancellationCode: p } = pt(this.urlSerializer, u);
                this.events.next(new L(r.id, this.urlSerializer.serialize(r.extractedUrl), c, p)), this.events.next(new ve(u.redirectTo, u.navigationBehaviorOptions));
            }
            else
                throw this.events.next(a), o;
        }
        catch (u) {
            this.options.resolveNavigationPromiseOnError ? r.resolve(!1) : r.reject(u);
        }
    } return G; })); })); }
    cancelNavigationTransition(e, r, i) { let s = new L(e.id, this.urlSerializer.serialize(e.extractedUrl), r, i); this.events.next(s), e.resolve(!1); }
    isUpdatingInternalState() { return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString(); }
    isUpdatedBrowserUrl() { let e = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))), r = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl; return e.toString() !== r?.toString() && !this.currentNavigation?.extras.skipLocationChange; }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })();
function go(t) { return t !== Ye; }
var Xr = (() => { class t {
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: () => g(vo), providedIn: "root" });
} return t; })(), vt = class {
    shouldDetach(n) { return !1; }
    store(n, e) { }
    shouldAttach(n) { return !1; }
    retrieve(n) { return null; }
    shouldReuseRoute(n, e) { return n.routeConfig === e.routeConfig; }
}, vo = (() => { class t extends vt {
    static ɵfac = (() => { let e; return function (i) { return (e || (e = m.ɵɵgetInheritedFactory(t)))(i || t); }; })();
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), Jr = (() => { class t {
    urlSerializer = g(J);
    options = g(ee, { optional: !0 }) || {};
    canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
    location = g(Ht);
    urlHandlingStrategy = g(yt);
    urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
    currentUrlTree = new z;
    getCurrentUrlTree() { return this.currentUrlTree; }
    rawUrlTree = this.currentUrlTree;
    getRawUrlTree() { return this.rawUrlTree; }
    createBrowserPath({ finalUrl: e, initialUrl: r, targetBrowserUrl: i }) { let s = e !== void 0 ? this.urlHandlingStrategy.merge(e, r) : r, o = i ?? s; return o instanceof z ? this.urlSerializer.serialize(o) : o; }
    commitTransition({ targetRouterState: e, finalUrl: r, initialUrl: i }) { r && e ? (this.currentUrlTree = r, this.rawUrlTree = this.urlHandlingStrategy.merge(r, i), this.routerState = e) : this.rawUrlTree = i; }
    routerState = jr(null);
    getRouterState() { return this.routerState; }
    stateMemento = this.createStateMemento();
    updateStateMemento() { this.stateMemento = this.createStateMemento(); }
    createStateMemento() { return { rawUrlTree: this.rawUrlTree, currentUrlTree: this.currentUrlTree, routerState: this.routerState }; }
    resetInternalState({ finalUrl: e }) { this.routerState = this.stateMemento.routerState, this.currentUrlTree = this.stateMemento.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e ?? this.rawUrlTree); }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: () => g(mo), providedIn: "root" });
} return t; })(), mo = (() => { class t extends Jr {
    currentPageId = 0;
    lastSuccessfulId = -1;
    restoredState() { return this.location.getState(); }
    get browserPageId() { return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState()?.ɵrouterPageId ?? this.currentPageId; }
    registerNonRouterCurrentEntryChangeListener(e) { return this.location.subscribe(r => { r.type === "popstate" && setTimeout(() => { e(r.url, r.state, "popstate"); }); }); }
    handleRouterEvent(e, r) { e instanceof Y ? this.updateStateMemento() : e instanceof F ? this.commitTransition(r) : e instanceof De ? this.urlUpdateStrategy === "eager" && (r.extras.skipLocationChange || this.setBrowserUrl(this.createBrowserPath(r), r)) : e instanceof Ee ? (this.commitTransition(r), this.urlUpdateStrategy === "deferred" && !r.extras.skipLocationChange && this.setBrowserUrl(this.createBrowserPath(r), r)) : e instanceof L && (e.code === I.GuardRejected || e.code === I.NoDataFromResolver) ? this.restoreHistory(r) : e instanceof pe ? this.restoreHistory(r, !0) : e instanceof M && (this.lastSuccessfulId = e.id, this.currentPageId = this.browserPageId); }
    setBrowserUrl(e, { extras: r, id: i }) { let { replaceUrl: s, state: o } = r; if (this.location.isCurrentPathEqualTo(e) || s) {
        let a = this.browserPageId, u = h(h({}, o), this.generateNgRouterState(i, a));
        this.location.replaceState(e, "", u);
    }
    else {
        let a = h(h({}, o), this.generateNgRouterState(i, this.browserPageId + 1));
        this.location.go(e, "", a);
    } }
    restoreHistory(e, r = !1) { if (this.canceledNavigationResolution === "computed") {
        let i = this.browserPageId, s = this.currentPageId - i;
        s !== 0 ? this.location.historyGo(s) : this.getCurrentUrlTree() === e.finalUrl && s === 0 && (this.resetInternalState(e), this.resetUrlToCurrentUrlTree());
    }
    else
        this.canceledNavigationResolution === "replace" && (r && this.resetInternalState(e), this.resetUrlToCurrentUrlTree()); }
    resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)); }
    generateNgRouterState(e, r) { return this.canceledNavigationResolution === "computed" ? { navigationId: e, ɵrouterPageId: r } : { navigationId: e }; }
    static ɵfac = (() => { let e; return function (i) { return (e || (e = m.ɵɵgetInheritedFactory(t)))(i || t); }; })();
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })();
function wt(t, n) { t.events.pipe(Oe(e => e instanceof M || e instanceof L || e instanceof pe || e instanceof F), R(e => e instanceof M || e instanceof F ? 0 : (e instanceof L ? e.code === I.Redirect || e.code === I.SupersededByNewNavigation : !1) ? 2 : 1), Oe(e => e !== 2), Te(1)).subscribe(() => { n(); }); }
var Ro = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, So = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }, x = (() => { class t {
    get currentUrlTree() { return this.stateManager.getCurrentUrlTree(); }
    get rawUrlTree() { return this.stateManager.getRawUrlTree(); }
    disposed = !1;
    nonRouterCurrentEntryChangeSubscription;
    console = g(kn);
    stateManager = g(Jr);
    options = g(ee, { optional: !0 }) || {};
    pendingTasks = g(Ln);
    urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
    navigationTransitions = g(ze);
    urlSerializer = g(J);
    location = g(Ht);
    urlHandlingStrategy = g(yt);
    _events = new Ae;
    get events() { return this._events; }
    get routerState() { return this.stateManager.getRouterState(); }
    navigated = !1;
    routeReuseStrategy = g(Xr);
    onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
    config = g(te, { optional: !0 })?.flat() ?? [];
    componentInputBindingEnabled = !!g(Le, { optional: !0 });
    constructor() { this.resetConfig(this.config), this.navigationTransitions.setupNavigations(this).subscribe({ error: e => { this.console.warn(e); } }), this.subscribeToNavigationEvents(); }
    eventsSubscription = new Bn;
    subscribeToNavigationEvents() { let e = this.navigationTransitions.events.subscribe(r => { try {
        let i = this.navigationTransitions.currentTransition, s = this.navigationTransitions.currentNavigation;
        if (i !== null && s !== null) {
            if (this.stateManager.handleRouterEvent(r, s), r instanceof L && r.code !== I.Redirect && r.code !== I.SupersededByNewNavigation)
                this.navigated = !0;
            else if (r instanceof M)
                this.navigated = !0;
            else if (r instanceof ve) {
                let o = r.navigationBehaviorOptions, a = this.urlHandlingStrategy.merge(r.url, i.currentRawUrl), u = h({ browserUrl: i.extras.browserUrl, info: i.extras.info, skipLocationChange: i.extras.skipLocationChange, replaceUrl: i.extras.replaceUrl || this.urlUpdateStrategy === "eager" || go(i.source) }, o);
                this.scheduleNavigation(a, Ye, null, u, { resolve: i.resolve, reject: i.reject, promise: i.promise });
            }
        }
        Co(r) && this._events.next(r);
    }
    catch (i) {
        this.navigationTransitions.transitionAbortSubject.next(i);
    } }); this.eventsSubscription.add(e); }
    resetRootComponentType(e) { this.routerState.root.component = e, this.navigationTransitions.rootComponentType = e; }
    initialNavigation() { this.setUpLocationChangeListener(), this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), Ye, this.stateManager.restoredState()); }
    setUpLocationChangeListener() { this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((e, r, i) => { this.navigateToSyncWithBrowser(e, i, r); }); }
    navigateToSyncWithBrowser(e, r, i) { let s = { replaceUrl: !0 }, o = i?.navigationId ? i : null; if (i) {
        let u = h({}, i);
        delete u.navigationId, delete u.ɵrouterPageId, Object.keys(u).length !== 0 && (s.state = u);
    } let a = this.parseUrl(e); this.scheduleNavigation(a, r, o, s); }
    get url() { return this.serializeUrl(this.currentUrlTree); }
    getCurrentNavigation() { return this.navigationTransitions.currentNavigation; }
    get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation; }
    resetConfig(e) { this.config = e.map(Yt), this.navigated = !1; }
    ngOnDestroy() { this.dispose(); }
    dispose() { this._events.unsubscribe(), this.navigationTransitions.complete(), this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(), this.nonRouterCurrentEntryChangeSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe(); }
    createUrlTree(e, r = {}) { let { relativeTo: i, queryParams: s, fragment: o, queryParamsHandling: a, preserveFragment: u } = r, c = u ? this.currentUrlTree.fragment : o, p = null; switch (a ?? this.options.defaultQueryParamsHandling) {
        case "merge":
            p = h(h({}, this.currentUrlTree.queryParams), s);
            break;
        case "preserve":
            p = this.currentUrlTree.queryParams;
            break;
        default: p = s || null;
    } p !== null && (p = this.removeEmptyProps(p)); let y; try {
        let A = i ? i.snapshot : this.routerState.snapshot.root;
        y = Nr(A);
    }
    catch {
        (typeof e[0] != "string" || e[0][0] !== "/") && (e = []), y = this.currentUrlTree.root;
    } return Pr(y, e, p, c ?? null); }
    navigateByUrl(e, r = { skipLocationChange: !1 }) { let i = Z(e) ? e : this.parseUrl(e), s = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(s, Ye, null, r); }
    navigate(e, r = { skipLocationChange: !1 }) { return yo(e), this.navigateByUrl(this.createUrlTree(e, r), r); }
    serializeUrl(e) { return this.urlSerializer.serialize(e); }
    parseUrl(e) { try {
        return this.urlSerializer.parse(e);
    }
    catch {
        return this.urlSerializer.parse("/");
    } }
    isActive(e, r) { let i; if (r === !0 ? i = h({}, Ro) : r === !1 ? i = h({}, So) : i = r, Z(e))
        return cr(this.currentUrlTree, e, i); let s = this.parseUrl(e); return cr(this.currentUrlTree, s, i); }
    removeEmptyProps(e) { return Object.entries(e).reduce((r, [i, s]) => (s != null && (r[i] = s), r), {}); }
    scheduleNavigation(e, r, i, s, o) { if (this.disposed)
        return Promise.resolve(!1); let a, u, c; o ? (a = o.resolve, u = o.reject, c = o.promise) : c = new Promise((y, A) => { a = y, u = A; }); let p = this.pendingTasks.add(); return wt(this, () => { queueMicrotask(() => this.pendingTasks.remove(p)); }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: e, extras: s, resolve: a, reject: u, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(y => Promise.reject(y)); }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = m.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })();
function yo(t) { for (let n = 0; n < t.length; n++)
    if (t[n] == null)
        throw new b(4008, !1); }
function Co(t) { return !(t instanceof Ee) && !(t instanceof ve); }
import * as tn from "@angular/common";
import { LOCATION_INITIALIZED as wo, HashLocationStrategy as rn, LocationStrategy as ir, ViewportScroller as nn, Location as bo, PathLocationStrategy as Io } from "@angular/common";
import * as l from "@angular/core";
import { ɵRuntimeError as ps, ɵɵsanitizeUrlOrResourceUrl as Ao, booleanAttribute as tr, EventEmitter as To, createEnvironmentInjector as Oo, InjectionToken as qe, ɵperformanceMarkFeature as Mo, makeEnvironmentProviders as Do, APP_BOOTSTRAP_LISTENER as on, ENVIRONMENT_INITIALIZER as Is, provideAppInitializer as sn, inject as E, Injector as an, ApplicationRef as Eo, InjectFlags as en, NgZone as un } from "@angular/core";
import { Subject as cn, of as ue, from as rr } from "rxjs";
import { mergeAll as bt, catchError as Uo, filter as No, concatMap as Po, mergeMap as xo } from "rxjs/operators";
var It = (() => { class t {
    router;
    route;
    tabIndexAttribute;
    renderer;
    el;
    locationStrategy;
    href = null;
    target;
    queryParams;
    fragment;
    queryParamsHandling;
    state;
    info;
    relativeTo;
    isAnchorElement;
    subscription;
    onChanges = new cn;
    constructor(e, r, i, s, o, a) { this.router = e, this.route = r, this.tabIndexAttribute = i, this.renderer = s, this.el = o, this.locationStrategy = a; let u = o.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = u === "a" || u === "area", this.isAnchorElement ? this.subscription = e.events.subscribe(c => { c instanceof M && this.updateHref(); }) : this.setTabIndexIfNotOnNativeEl("0"); }
    preserveFragment = !1;
    skipLocationChange = !1;
    replaceUrl = !1;
    setTabIndexIfNotOnNativeEl(e) { this.tabIndexAttribute != null || this.isAnchorElement || this.applyAttributeValue("tabindex", e); }
    ngOnChanges(e) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this); }
    routerLinkInput = null;
    set routerLink(e) { e == null ? (this.routerLinkInput = null, this.setTabIndexIfNotOnNativeEl(null)) : (Z(e) ? this.routerLinkInput = e : this.routerLinkInput = Array.isArray(e) ? e : [e], this.setTabIndexIfNotOnNativeEl("0")); }
    onClick(e, r, i, s, o) { let a = this.urlTree; if (a === null || this.isAnchorElement && (e !== 0 || r || i || s || o || typeof this.target == "string" && this.target != "_self"))
        return !0; let u = { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state, info: this.info }; return this.router.navigateByUrl(a, u), !this.isAnchorElement; }
    ngOnDestroy() { this.subscription?.unsubscribe(); }
    updateHref() { let e = this.urlTree; this.href = e !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(e)) : null; let r = this.href === null ? null : Ao(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", r); }
    applyAttributeValue(e, r) { let i = this.renderer, s = this.el.nativeElement; r !== null ? i.setAttribute(s, e, r) : i.removeAttribute(s, e); }
    get urlTree() { return this.routerLinkInput === null ? null : Z(this.routerLinkInput) ? this.routerLinkInput : this.router.createUrlTree(this.routerLinkInput, { relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }); }
    static ɵfac = function (r) { return new (r || t)(l.ɵɵdirectiveInject(x), l.ɵɵdirectiveInject(q), l.ɵɵinjectAttribute("tabindex"), l.ɵɵdirectiveInject(l.Renderer2), l.ɵɵdirectiveInject(l.ElementRef), l.ɵɵdirectiveInject(tn.LocationStrategy)); };
    static ɵdir = l.ɵɵdefineDirective({ type: t, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (r, i) { r & 1 && l.ɵɵlistener("click", function (o) { return i.onClick(o.button, o.ctrlKey, o.shiftKey, o.altKey, o.metaKey); }), r & 2 && l.ɵɵattribute("target", i.target); }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", info: "info", relativeTo: "relativeTo", preserveFragment: [2, "preserveFragment", "preserveFragment", tr], skipLocationChange: [2, "skipLocationChange", "skipLocationChange", tr], replaceUrl: [2, "replaceUrl", "replaceUrl", tr], routerLink: "routerLink" }, features: [l.ɵɵNgOnChangesFeature] });
} return t; })(), _o = (() => { class t {
    router;
    element;
    renderer;
    cdr;
    link;
    links;
    classes = [];
    routerEventsSubscription;
    linkInputChangesSubscription;
    _isActive = !1;
    get isActive() { return this._isActive; }
    routerLinkActiveOptions = { exact: !1 };
    ariaCurrentWhenActive;
    isActiveChange = new To;
    constructor(e, r, i, s, o) { this.router = e, this.element = r, this.renderer = i, this.cdr = s, this.link = o, this.routerEventsSubscription = e.events.subscribe(a => { a instanceof M && this.update(); }); }
    ngAfterContentInit() { ue(this.links.changes, ue(null)).pipe(bt()).subscribe(e => { this.update(), this.subscribeToEachLinkOnChanges(); }); }
    subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); let e = [...this.links.toArray(), this.link].filter(r => !!r).map(r => r.onChanges); this.linkInputChangesSubscription = rr(e).pipe(bt()).subscribe(r => { this._isActive !== this.isLinkActive(this.router)(r) && this.update(); }); }
    set routerLinkActive(e) { let r = Array.isArray(e) ? e : e.split(" "); this.classes = r.filter(i => !!i); }
    ngOnChanges(e) { this.update(); }
    ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe(); }
    update() { !this.links || !this.router.navigated || queueMicrotask(() => { let e = this.hasActiveLinks(); this.classes.forEach(r => { e ? this.renderer.addClass(this.element.nativeElement, r) : this.renderer.removeClass(this.element.nativeElement, r); }), e && this.ariaCurrentWhenActive !== void 0 ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this._isActive !== e && (this._isActive = e, this.cdr.markForCheck(), this.isActiveChange.emit(e)); }); }
    isLinkActive(e) { let r = jo(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return i => { let s = i.urlTree; return s ? e.isActive(s, r) : !1; }; }
    hasActiveLinks() { let e = this.isLinkActive(this.router); return this.link && e(this.link) || this.links.some(e); }
    static ɵfac = function (r) { return new (r || t)(l.ɵɵdirectiveInject(x), l.ɵɵdirectiveInject(l.ElementRef), l.ɵɵdirectiveInject(l.Renderer2), l.ɵɵdirectiveInject(l.ChangeDetectorRef), l.ɵɵdirectiveInject(It, 8)); };
    static ɵdir = l.ɵɵdefineDirective({ type: t, selectors: [["", "routerLinkActive", ""]], contentQueries: function (r, i, s) { if (r & 1 && l.ɵɵcontentQuery(s, It, 5), r & 2) {
            let o;
            l.ɵɵqueryRefresh(o = l.ɵɵloadQuery()) && (i.links = o);
        } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], features: [l.ɵɵNgOnChangesFeature] });
} return t; })();
function jo(t) { return !!t.paths; }
var Fe = class {
}, ko = (() => { class t {
    preload(e, r) { return r().pipe(Uo(() => ue(null))); }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = l.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), Lo = (() => { class t {
    preload(e, r) { return ue(null); }
    static ɵfac = function (r) { return new (r || t); };
    static ɵprov = l.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), ln = (() => { class t {
    router;
    injector;
    preloadingStrategy;
    loader;
    subscription;
    constructor(e, r, i, s) { this.router = e, this.injector = r, this.preloadingStrategy = i, this.loader = s; }
    setUpPreloading() { this.subscription = this.router.events.pipe(No(e => e instanceof M), Po(() => this.preload())).subscribe(() => { }); }
    preload() { return this.processRoutes(this.injector, this.router.config); }
    ngOnDestroy() { this.subscription && this.subscription.unsubscribe(); }
    processRoutes(e, r) { let i = []; for (let s of r) {
        s.providers && !s._injector && (s._injector = Oo(s.providers, e, `Route: ${s.path}`));
        let o = s._injector ?? e, a = s._loadedInjector ?? o;
        (s.loadChildren && !s._loadedRoutes && s.canLoad === void 0 || s.loadComponent && !s._loadedComponent) && i.push(this.preloadConfig(o, s)), (s.children || s._loadedRoutes) && i.push(this.processRoutes(a, s.children ?? s._loadedRoutes));
    } return rr(i).pipe(bt()); }
    preloadConfig(e, r) { return this.preloadingStrategy.preload(r, () => { let i; r.loadChildren && r.canLoad === void 0 ? i = this.loader.loadChildren(e, r) : i = ue(null); let s = i.pipe(xo(o => o === null ? ue(void 0) : (r._loadedRoutes = o.routes, r._loadedInjector = o.injector, this.processRoutes(o.injector ?? e, o.routes)))); if (r.loadComponent && !r._loadedComponent) {
        let o = this.loader.loadComponent(r);
        return rr([s, o]).pipe(bt());
    }
    else
        return s; }); }
    static ɵfac = function (r) { return new (r || t)(l.ɵɵinject(x), l.ɵɵinject(l.EnvironmentInjector), l.ɵɵinject(Fe), l.ɵɵinject(St)); };
    static ɵprov = l.ɵɵdefineInjectable({ token: t, factory: t.ɵfac, providedIn: "root" });
} return t; })(), or = new qe(""), hn = (() => { class t {
    urlSerializer;
    transitions;
    viewportScroller;
    zone;
    options;
    routerEventsSubscription;
    scrollEventsSubscription;
    lastId = 0;
    lastSource = "imperative";
    restoredId = 0;
    store = {};
    constructor(e, r, i, s, o = {}) { this.urlSerializer = e, this.transitions = r, this.viewportScroller = i, this.zone = s, this.options = o, o.scrollPositionRestoration ||= "disabled", o.anchorScrolling ||= "disabled"; }
    init() { this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents(); }
    createScrollEvents() { return this.transitions.events.subscribe(e => { e instanceof Y ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof M ? (this.lastId = e.id, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment)) : e instanceof F && e.code === fe.IgnoredSameUrlNavigation && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment)); }); }
    consumeScrollEvents() { return this.transitions.events.subscribe(e => { e instanceof ge && (e.position ? this.options.scrollPositionRestoration === "top" ? this.viewportScroller.scrollToPosition([0, 0]) : this.options.scrollPositionRestoration === "enabled" && this.viewportScroller.scrollToPosition(e.position) : e.anchor && this.options.anchorScrolling === "enabled" ? this.viewportScroller.scrollToAnchor(e.anchor) : this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.scrollToPosition([0, 0])); }); }
    scheduleScrollEvent(e, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new ge(e, this.lastSource === "popstate" ? this.store[this.restoredId] : null, r)); }); }, 0); }); }
    ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe(); }
    static ɵfac = function (r) { l.ɵɵinvalidFactory(); };
    static ɵprov = l.ɵɵdefineInjectable({ token: t, factory: t.ɵfac });
} return t; })();
function $o(t, ...n) { return Do([{ provide: te, multi: !0, useValue: t }, [], { provide: q, useFactory: dn, deps: [x] }, { provide: on, multi: !0, useFactory: fn }, n.map(e => e.ɵproviders)]); }
function dn(t) { return t.routerState.root; }
function B(t, n) { return { ɵkind: t, ɵproviders: n }; }
function zo(t) { return [{ provide: te, multi: !0, useValue: t }, []]; }
function Fo(t = {}) { return B(4, [{ provide: or, useFactory: () => { let e = E(nn), r = E(un), i = E(ze), s = E(J); return new hn(s, i, e, r, t); } }]); }
function fn() { let t = E(an); return n => { let e = t.get(Eo); if (n !== e.components[0])
    return; let r = t.get(x), i = t.get(pn); t.get(sr) === 1 && r.initialNavigation(), t.get(mn, null, en.Optional)?.setUpPreloading(), t.get(or, null, en.Optional)?.init(), r.resetRootComponentType(e.componentTypes[0]), i.closed || (i.next(), i.complete(), i.unsubscribe()); }; }
var pn = new qe("", { factory: () => new cn }), sr = new qe("", { providedIn: "root", factory: () => 1 });
function gn() { let t = [{ provide: sr, useValue: 0 }, sn(() => { let n = E(an); return n.get(wo, Promise.resolve()).then(() => new Promise(r => { let i = n.get(x), s = n.get(pn); wt(i, () => { r(!0); }), n.get(ze).afterPreactivation = () => (r(!0), s.closed ? ue(void 0) : s), i.initialNavigation(); })); })]; return B(2, t); }
function vn() { let t = [sn(() => { E(x).setUpLocationChangeListener(); }), { provide: sr, useValue: 2 }]; return B(3, t); }
function qo() { let t = []; return t = [], B(1, t); }
var mn = new qe("");
function Rn(t) { return B(0, [{ provide: mn, useExisting: ln }, { provide: Fe, useExisting: t }]); }
function Bo(t) { return B(5, [{ provide: ee, useValue: t }]); }
function Vo() { return B(6, [{ provide: ir, useClass: rn }]); }
function Ho(t) { return B(7, [{ provide: Ct, useValue: t }]); }
function Sn() { return B(8, [Kt, { provide: Le, useExisting: Kt }]); }
function yn(t) { Mo("NgRouterViewTransitions"); let n = [{ provide: Jt, useValue: Yr }, { provide: er, useValue: h({ skipNextTransition: !!t?.skipInitialTransition }, t) }]; return B(9, n); }
var Cn = [bo, { provide: J, useClass: K }, x, ae, { provide: q, useFactory: dn, deps: [x] }, St, []], Wo = (() => { class t {
    constructor() { }
    static forRoot(e, r) { return { ngModule: t, providers: [Cn, [], { provide: te, multi: !0, useValue: e }, [], r?.errorHandler ? { provide: Ct, useValue: r.errorHandler } : [], { provide: ee, useValue: r || {} }, r?.useHash ? Qo() : Ko(), Go(), r?.preloadingStrategy ? Rn(r.preloadingStrategy).ɵproviders : [], r?.initialNavigation ? Zo(r) : [], r?.bindToComponentInputs ? Sn().ɵproviders : [], r?.enableViewTransitions ? yn().ɵproviders : [], Yo()] }; }
    static forChild(e) { return { ngModule: t, providers: [{ provide: te, multi: !0, useValue: e }] }; }
    static ɵfac = function (r) { return new (r || t); };
    static ɵmod = l.ɵɵdefineNgModule({ type: t });
    static ɵinj = l.ɵɵdefineInjector({});
} return t; })();
function Go() { return { provide: or, useFactory: () => { let t = E(nn), n = E(un), e = E(ee), r = E(ze), i = E(J); return e.scrollOffset && t.setOffset(e.scrollOffset), new hn(i, r, t, n, e); } }; }
function Qo() { return { provide: ir, useClass: rn }; }
function Ko() { return { provide: ir, useClass: Io }; }
function Zo(t) { return [t.initialNavigation === "disabled" ? vn().ɵproviders : [], t.initialNavigation === "enabledBlocking" ? gn().ɵproviders : []]; }
var nr = new qe("");
function Yo() { return [{ provide: nr, useFactory: fn }, { provide: on, multi: !0, useExisting: nr }]; }
import { inject as Be, Version as Xo } from "@angular/core";
import "@angular/common";
import "rxjs";
import "rxjs/operators";
import "@angular/platform-browser";
function Ls(t) { return t.map(n => (...e) => Be(n).canMatch(...e)); }
function $s(t) { return t.map(n => (...e) => Be(n).canActivate(...e)); }
function zs(t) { return t.map(n => (...e) => Be(n).canActivateChild(...e)); }
function Fs(t) { return t.map(n => (...e) => Be(n).canDeactivate(...e)); }
function qs(t) { return (...n) => Be(t).resolve(...n); }
var Bs = new Xo("19.2.14");
export { q as ActivatedRoute, ne as ActivatedRouteSnapshot, lt as ActivationEnd, ct as ActivationStart, vt as BaseRouteReuseStrategy, ut as ChildActivationEnd, at as ChildActivationStart, ae as ChildrenOutletContexts, Qr as DefaultTitleStrategy, K as DefaultUrlSerializer, S as EventType, rt as GuardsCheckEnd, tt as GuardsCheckStart, L as NavigationCancel, I as NavigationCancellationCode, M as NavigationEnd, pe as NavigationError, F as NavigationSkipped, fe as NavigationSkippedCode, Y as NavigationStart, Lo as NoPreloading, ht as OutletContext, d as PRIMARY_OUTLET, ko as PreloadAllModules, Fe as PreloadingStrategy, ee as ROUTER_CONFIGURATION, nr as ROUTER_INITIALIZER, $r as ROUTER_OUTLET_DATA, te as ROUTES, me as RedirectCommand, it as ResolveEnd, nt as ResolveStart, st as RouteConfigLoadEnd, ot as RouteConfigLoadStart, Xr as RouteReuseStrategy, x as Router, O as RouterEvent, It as RouterLink, _o as RouterLinkActive, It as RouterLinkWithHref, Wo as RouterModule, Qt as RouterOutlet, ln as RouterPreloader, Ue as RouterState, Ne as RouterStateSnapshot, De as RoutesRecognized, ge as Scroll, Xt as TitleStrategy, yt as UrlHandlingStrategy, Q as UrlSegment, v as UrlSegmentGroup, J as UrlSerializer, z as UrlTree, Bs as VERSION, ie as convertToParamMap, Ur as createUrlTreeFromSnapshot, yr as defaultUrlMatcher, $s as mapToCanActivate, zs as mapToCanActivateChild, Fs as mapToCanDeactivate, Ls as mapToCanMatch, qs as mapToResolve, $o as provideRouter, zo as provideRoutes, Sn as withComponentInputBinding, qo as withDebugTracing, vn as withDisabledInitialNavigation, gn as withEnabledBlockingInitialNavigation, Vo as withHashLocation, Fo as withInMemoryScrolling, Ho as withNavigationErrorHandler, Rn as withPreloading, Bo as withRouterConfig, yn as withViewTransitions, Zt as ɵEmptyOutletComponent, Cn as ɵROUTER_PROVIDERS, wt as ɵafterNextNavigation, Kr as ɵloadChildren }; /*! Bundled license information:

@angular/router/fesm2022/router-Dwfin5Au.mjs:
@angular/router/fesm2022/router_module-DTJgGWLd.mjs:
@angular/router/fesm2022/router.mjs:
  (**
   * @license Angular v19.2.14
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
