{
  "version": 3,
  "sources": ["../../@angular/core/fesm2022/primitives/signals.mjs"],
  "sourcesContent": ["/**\n * @license Angular v19.2.14\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { consumerMarkDirty, SIGNAL, consumerDestroy, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation, REACTIVE_NODE } from '../untracked-BKcld_ew.mjs';\nexport { SIGNAL_NODE, createComputed, createLinkedSignal, createSignal, defaultEquals, getActiveConsumer, isReactive, linkedSignalSetFn, linkedSignalUpdateFn, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostSignalSetFn, setActiveConsumer, setAlternateWeakRefImpl, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalSetFn, signalUpdateFn, untracked } from '../untracked-BKcld_ew.mjs';\nfunction createWatch(fn, schedule, allowSignalWrites) {\n  const node = Object.create(WATCH_NODE);\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n  node.fn = fn;\n  node.schedule = schedule;\n  const registerOnCleanup = cleanupFn => {\n    node.cleanupFn = cleanupFn;\n  };\n  function isWatchNodeDestroyed(node) {\n    return node.fn === null && node.schedule === null;\n  }\n  function destroyWatchNode(node) {\n    if (!isWatchNodeDestroyed(node)) {\n      consumerDestroy(node); // disconnect watcher from the reactive graph\n      node.cleanupFn();\n      // nullify references to the integration functions to mark node as destroyed\n      node.fn = null;\n      node.schedule = null;\n      node.cleanupFn = NOOP_CLEANUP_FN;\n    }\n  }\n  const run = () => {\n    if (node.fn === null) {\n      // trying to run a destroyed watch is noop\n      return;\n    }\n    if (isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    node.dirty = false;\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n    node.hasRun = true;\n    const prevConsumer = consumerBeforeComputation(node);\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn(),\n    destroy: () => destroyWatchNode(node),\n    [SIGNAL]: node\n  };\n  return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => {};\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: node => {\n      if (node.schedule !== null) {\n        node.schedule(node.ref);\n      }\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN\n  };\n})();\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,SAAS,YAAY,IAAI,UAAU,mBAAmB;AACpD,QAAM,OAAO,OAAO,OAAO,UAAU;AACrC,MAAI,mBAAmB;AACrB,SAAK,4BAA4B;AAAA,EACnC;AACA,OAAK,KAAK;AACV,OAAK,WAAW;AAChB,QAAM,oBAAoB,eAAa;AACrC,SAAK,YAAY;AAAA,EACnB;AACA,WAAS,qBAAqBA,OAAM;AAClC,WAAOA,MAAK,OAAO,QAAQA,MAAK,aAAa;AAAA,EAC/C;AACA,WAAS,iBAAiBA,OAAM;AAC9B,QAAI,CAAC,qBAAqBA,KAAI,GAAG;AAC/B,sBAAgBA,KAAI;AACpB,MAAAA,MAAK,UAAU;AAEf,MAAAA,MAAK,KAAK;AACV,MAAAA,MAAK,WAAW;AAChB,MAAAA,MAAK,YAAY;AAAA,IACnB;AAAA,EACF;AACA,QAAM,MAAM,MAAM;AAChB,QAAI,KAAK,OAAO,MAAM;AAEpB;AAAA,IACF;AACA,QAAI,sBAAsB,GAAG;AAC3B,YAAM,IAAI,MAAM,mEAAmE;AAAA,IACrF;AACA,SAAK,QAAQ;AACb,QAAI,KAAK,UAAU,CAAC,+BAA+B,IAAI,GAAG;AACxD;AAAA,IACF;AACA,SAAK,SAAS;AACd,UAAM,eAAe,0BAA0B,IAAI;AACnD,QAAI;AACF,WAAK,UAAU;AACf,WAAK,YAAY;AACjB,WAAK,GAAG,iBAAiB;AAAA,IAC3B,UAAE;AACA,+BAAyB,MAAM,YAAY;AAAA,IAC7C;AAAA,EACF;AACA,OAAK,MAAM;AAAA,IACT,QAAQ,MAAM,kBAAkB,IAAI;AAAA,IACpC;AAAA,IACA,SAAS,MAAM,KAAK,UAAU;AAAA,IAC9B,SAAS,MAAM,iBAAiB,IAAI;AAAA,IACpC,CAAC,MAAM,GAAG;AAAA,EACZ;AACA,SAAO,KAAK;AACd;AACA,IAAM,kBAAkB,MAAM;AAAC;AAI/B,IAAM,aAA6B,uBAAM;AACvC,SAAO,iCACF,gBADE;AAAA,IAEL,sBAAsB;AAAA,IACtB,2BAA2B;AAAA,IAC3B,qBAAqB,UAAQ;AAC3B,UAAI,KAAK,aAAa,MAAM;AAC1B,aAAK,SAAS,KAAK,GAAG;AAAA,MACxB;AAAA,IACF;AAAA,IACA,QAAQ;AAAA,IACR,WAAW;AAAA,EACb;AACF,GAAG;",
  "names": ["node"]
}
