import{a as p,b as h}from"./chunk-4CLCTAJ7.js";import{assertInInjectionContext as d,inject as l,DestroyRef as a,ɵRuntimeError as f,ɵgetOutputDestroyRef as x,Injector as m,effect as j,untracked as b,ɵmicrotaskEffect as S,signal as v,computed as O,PendingTasks as R,resource as E}from"@angular/core";import{Observable as g,ReplaySubject as w}from"rxjs";import{takeUntil as q}from"rxjs/operators";function k(n){n||(d(k),n=l(a));let e=new g(t=>n.onDestroy(t.next.bind(t)));return t=>t.pipe(q(e))}var y=class{source;destroyed=!1;destroyRef=l(a);constructor(e){this.source=e,this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(e){if(this.destroyed)throw new f(953,!1);let t=this.source.pipe(k(this.destroyRef)).subscribe({next:r=>e(r)});return{unsubscribe:()=>t.unsubscribe()}}};function N(n,e){return new y(n)}function P(n){let e=x(n);return new g(t=>{e?.onDestroy(()=>t.complete());let r=n.subscribe(u=>t.next(u));return()=>r.unsubscribe()})}function D(n,e){!e?.injector&&d(D);let t=e?.injector??l(m),r=new w(1),u=j(()=>{let o;try{o=n()}catch(i){b(()=>r.error(i));return}b(()=>r.next(o))},{injector:t,manualCleanup:!0});return t.get(a).onDestroy(()=>{u.destroy(),r.complete()}),r.asObservable()}function A(n,e){!e?.injector&&d(D);let t=e?.injector??l(m),r=new w(1),u=S(()=>{let o;try{o=n()}catch(i){b(()=>r.error(i));return}b(()=>r.next(o))},{injector:t,manualCleanup:!0});return t.get(a).onDestroy(()=>{u.destroy(),r.complete()}),r.asObservable()}function M(n,e){let t=!e?.manualCleanup;t&&!e?.injector&&d(M);let r=t?e?.injector?.get(a)??l(a):null,u=C(e?.equal),o;e?.requireSync?o=v({kind:0},{equal:u}):o=v({kind:1,value:e?.initialValue},{equal:u});let i,c=n.subscribe({next:s=>o.set({kind:1,value:s}),error:s=>{if(e?.rejectErrors)throw s;o.set({kind:2,error:s})},complete:()=>{i?.()}});if(e?.requireSync&&o().kind===0)throw new f(601,!1);return i=r?.onDestroy(c.unsubscribe.bind(c)),O(()=>{let s=o();switch(s.kind){case 1:return s.value;case 2:throw s.error;case 0:throw new f(601,!1)}},{equal:e?.equal})}function C(n=Object.is){return(e,t)=>e.kind===1&&t.kind===1&&n(e.value,t.value)}function I(n){n===void 0&&(d(I),n=l(m));let e=n.get(R);return t=>new g(r=>{let u=e.add(),o=!1;function i(){o||(u(),o=!0)}let c=t.subscribe({next:s=>{r.next(s),i()},complete:()=>{r.complete(),i()},error:s=>{r.error(s),i()}});return c.add(()=>{r.unsubscribe(),i()}),c})}function T(n){return n?.injector||d(T),E(h(p({},n),{loader:void 0,stream:e=>{let t,r=()=>t.unsubscribe();e.abortSignal.addEventListener("abort",r);let u=v({value:void 0}),o,i=new Promise(s=>o=s);function c(s){u.set(s),o?.(u),o=void 0}return t=n.loader(e).subscribe({next:s=>c({value:s}),error:s=>{c({error:s}),e.abortSignal.removeEventListener("abort",r)},complete:()=>{o&&c({error:new Error("Resource completed before producing a value")}),e.abortSignal.removeEventListener("abort",r)}}),i}}))}export{N as outputFromObservable,P as outputToObservable,I as pendingUntilEvent,T as rxResource,k as takeUntilDestroyed,D as toObservable,M as toSignal,A as ɵtoObservableMicrotask};/*! Bundled license information:

@angular/core/fesm2022/rxjs-interop.mjs:
  (**
   * @license Angular v19.2.14
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/